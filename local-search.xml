<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++学习总结</title>
    <link href="/2023/08/05/test/"/>
    <url>/2023/08/05/test/</url>
    
    <content type="html"><![CDATA[<h1 id="c学习思考总结">C++学习思考总结</h1><h2 id="知识点">知识点</h2><ul><li><strong>圆括号初始化不能用于对类内变量初始化，其它均可。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> units_sold = <span class="hljs-number">0</span><br><span class="hljs-type">int</span> units_sold = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> units_sold&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">units_sold</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//int units_sold = 0;</span><br>    <span class="hljs-comment">//int units_sold = &#123;0&#125;;</span><br>    <span class="hljs-comment">//int units_sold&#123;0&#125;;</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">units_sold</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">//ERROR</span><br>&#125;;<br></code></pre></td></tr></table></figure><hr /><ul><li><strong>变量何时必须初始化？</strong></li></ul><p><code>auto</code>类型变量必须初始化：需要知道其右值类型，让编译器通过初始值来推算<code>auto</code>变量的类型。<code>const</code>类型变量必须初始化：<strong>常量对象</strong>必须初始化；<strong>常量指针</strong>必须初始化，指向常量的指针不用初始化。<code>&amp;</code>引用类型变量必须初始化：引用与指针不同，不单独占用内存，是某块内存的别名。<code>void *</code>类型的指针必须初始化：可以指向任意非常量的指针类型，不能执行解引用操作。</p><hr /><ul><li><strong>位于头文件的代码一般来说不应该使用<code>using</code>声明</strong>。</li></ul><p>这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个<code>using</code>声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p><ul><li><p>但凡使用了迭代器的循环体，都不要向迭代器所属的容器中添加元素，因为循环体执行时已经预存了容器的循环次数，当再次添加元素后改变容器大小，但循环次数不发生改变，会造成不可预料的结果。</p></li><li><p><strong><code>c_str()</code>函数与<code>data()</code>函数</strong></p></li></ul><p><code>string</code>类型转<code>const char *</code>类型字符串，使用<code>c_str()</code>函数，<code>c_str()</code>生成一个<code>const char *</code>指针，指向以空字符<code>\0</code>终止的数组；<code>vector&lt;type&gt;</code>类型转<code>type</code>类型指针，使用<code>data()</code>函数，<code>data()</code>返回<code>vector</code>元素集合的首地址。</p><p>具体应用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;string&gt; vec = &#123;<span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&quot;efgg&quot;</span>, <span class="hljs-string">&quot;awfe&quot;</span>&#125;;<br>    string *ptr = vec.<span class="hljs-built_in">data</span>();          <span class="hljs-comment">//ptr指向&quot;abcd&quot; ptr+1指向下一个字符串</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr1 = (*ptr).<span class="hljs-built_in">c_str</span>(); <span class="hljs-comment">//取ptr指向的string 转为const char *</span><br>    <span class="hljs-keyword">while</span>(*ptr1 != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        cout &lt;&lt; *ptr1++;               <span class="hljs-comment">//abcd</span><br><br>    vector&lt;<span class="hljs-type">char</span>&gt; c = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br>    <span class="hljs-type">char</span> *p = c.<span class="hljs-built_in">data</span>();                <span class="hljs-comment">//p指向c的首元素地址 p+1指向下一个字符b</span><br>    cout &lt;&lt; *p &lt;&lt; endl;                <span class="hljs-comment">//输出a</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>补充：对于有<code>'\0'</code>结尾的<code>str</code>字符数组，通过首地址可直接打印字符串（无<code>'\0'</code>也可打印字符串，但我们知道字符串打印以<code>\0</code>结尾，因此无<code>\0</code>结果也可能可以达到预期，但这不是一个安全的操作行为）；但对于整型数组，通过首地址打印的仅为首地址，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> str[] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br>    <span class="hljs-type">char</span> *p = str;<br>    cout &lt;&lt; str &lt;&lt; endl; <span class="hljs-comment">//输出字符串</span><br><br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">//首元素地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr /><ul><li>使用关键字<code>decltype</code>的时候，左值与右值也有所不同，如果表达式的求值结果是左值，<code>decltype</code>作用于该表达式（不是变量）得到一个引用类型。举个例子，假定<code>p</code>的类型是<code>int *</code>，因为解引用运算符生成左值，所以<code>decltype(*p)</code>的结果是<code>int &amp;</code>。另一方面，因为取地址运算符生成右值，所以<code>decltype(&amp;p)</code>的结果是<code>int **</code>，也就是说，结果是一个指向整型指针的指针。</li></ul><hr /><ul><li>进行位运算中移位操作<code>&gt;&gt;</code>、<code>&lt;&lt;</code>时，右移运算<code>&gt;&gt;</code>涉及逻辑移位和算数移位，所以右移得到的结果不一定和我们想的一样，<strong>因此我们在进行移位操作时，尽量避免使用有符号数</strong>。</li></ul><table style="width:10%;"><tbody><tr class="odd"><td>#### static_cast类型转换</td></tr><tr class="even"><td>用于编译器认可的静态转换，比如说从<code>char</code>到<code>int</code>、从<code>double</code>到<code>int</code>。*编译器隐式执行的任何类型转换都可由<code>static_cast&lt;T&gt;</code>完成。*<strong><code>static_cast&lt;T&gt;</code>对于编译器无法自动执行的类型转换也非常有用</strong>。如，可以使用<code>static_cast</code>找回存在于<code>void *</code>指针中的值，换句话说，可以将<code>void *</code>指针转换为某一类型的指针：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> *p = &amp;d;<br><span class="hljs-type">double</span> *dp = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span> *&gt;(p); <span class="hljs-comment">//若访问d，*dp等价于*(double *)p</span><br></code></pre></td></tr></table></figure>当我们把指针存放在<code>void *</code>中，并且使用<code>static_cast</code>将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果与原始的地址值相等，因此<strong>我们必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果</strong>。</td></tr><tr class="odd"><td>* 可以将基类指针转换为派生类指针。（讲到继承时会说） *无法将<code>const</code>转化为非<code>const</code>，这个只有<code>const_cast&lt;T&gt;</code>才能做到。</td></tr><tr class="even"><td>#### const_cast类型转换</td></tr><tr class="odd"><td>用于去除常量属性，但使用<code>const_cast&lt;T&gt;</code>时，<strong>无法直接对常量进行去常量属性操作，一般需要使用指针或者引用对其进行操作</strong>（解除底层<code>const</code>）。普通指针或引用无法接收<code>const</code>常量，如果非要接收，就得使用<code>const_cast&lt;T&gt;</code>来消除常量属性，同样，消除常量属性的目的不是为了修改其内容，而是为了能让指针、引用或函数接受这个实际参数。当然也可用于增加常量属性，比如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> *&gt;(&amp;a); <span class="hljs-comment">//给a增加const属性</span><br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td><strong>使用指针</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">200</span>;<br><span class="hljs-comment">//int *p = a;  //Error</span><br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(&amp;a);<br><span class="hljs-comment">//或者拆分为两句 int *p = NULL; p = const_cast&lt;int *&gt;(&amp;a);</span><br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td><strong>使用引用</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">200</span>;<br><span class="hljs-comment">//int &amp;ref = a;  //Error</span><br><span class="hljs-type">int</span> &amp;ref = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> &amp;&gt;(a);<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td><strong>用于函数参数传递</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;ref)</span></span>&#123;<br>    ref = <span class="hljs-number">400</span>; <span class="hljs-comment">//更改临时变量的值 但不更改main中a的值</span><br>    <span class="hljs-type">int</span> b = <span class="hljs-number">100</span>;<br>    cout &lt;&lt; ref+b &lt;&lt; endl; <span class="hljs-comment">//输出500 但main中a仍为300</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">300</span>;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> &amp;&gt;(a));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td><strong>比较疑惑的问题：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *b = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(&amp;a); <span class="hljs-comment">//解除底层const</span><br>*b = <span class="hljs-number">11</span>;<br>cout &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *b &lt;&lt; endl; <span class="hljs-comment">//打印结果 0x7ffee29f5968 11</span><br>cout &lt;&lt; &amp;a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">//打印结果 0x7ffee29f5968 10</span><br></code></pre></td></tr></table></figure>上述代码，<code>b</code>指针存放的地址和<code>a</code>的地址一致，为什么<code>b</code>解引用的结果与<code>a</code>存放的结果不一致呢？</td></tr><tr class="even"><td>可能会给予<code>*b</code>一个临时值，但是<code>b</code>指针存放的地址仍然和<code>a</code>的地址一致。就像上述用于函数参数传递的情况一样，<code>ref</code>所引用的地址和<code>main</code>中<code>a</code>的地址一致，但在<code>func</code>函数中，ref的值却是一个临时值，并且更改<code>ref</code>的同时，不会修改到<code>main</code>中<code>a</code>的值。</td></tr><tr class="odd"><td>#### reinterpret_cast类型转换用于编译器不认可的静态转换，比如从<code>int *</code>转为<code>int</code>，在转型过程中不做任何对齐操作。对于受保护继承或私有继承，如果基类指针（引用）指向（引用）派生类对象，或者派生类指针（引用）指向（引用）基类对象，则需要对等号右侧的派生类对象、指针或等号右侧的基类对象、指针进行该转换。</td></tr><tr class="even"><td>#### dynamic_cast类型转换常常用于多态的检测，就比如说一个基类<code>A</code>指针<code>p</code>指向一个派生类<code>B</code>对象<code>Obj</code>，如果调用的是一个虚函数方法<code>Func()</code>，此时就会发生多态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A *p;<br>B Obj;<br>p = &amp;Obj;<br>p-&gt;<span class="hljs-built_in">Func</span>(); <span class="hljs-comment">//调用B类对象的Func方法</span><br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td>那么<code>dynamic_cast</code>则用于检测如果基类发生多态后转向调用哪种派生类。对于上述情况来说，<code>dynamic_cast&lt;B *&gt;(p)</code>则返回<code>p</code>所指向的地址，如果<code>p</code>发生多态后并不非调用<code>B</code>派生类对象，而是其他派生类如<code>C</code>类对象，那么则返回<code>nullptr</code>。我们可以使用<code>dynamic_cast</code>进行动态转型，而非使用多态，但是这样的话开销也会比较大，比如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A *p; <span class="hljs-comment">//基类指针p</span><br>B *p1 = <span class="hljs-built_in">dynamic_cast</span>&lt;B *&gt;(p); <span class="hljs-comment">//将基类指针p安全向下转型为派生类指针类型 将指向内存传递给派生类指针p1</span><br>p1-&gt;<span class="hljs-built_in">Func</span>(); <span class="hljs-comment">//派生类p1指针直接调用其方法</span><br></code></pre></td></tr></table></figure>那么多态基类指针转为派生类指针类型，这种向下转型是安全的。</td></tr><tr class="even"><td>那么<code>static_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code>均为静态转型，不需要运行时支持，还有一种转型需运行时支持，即<code>dynamic_cast</code>，用于动态转型，安全的向下转型。</td></tr><tr class="odd"><td>* 静态转型，不需要运行时支持 *<code>static_cast</code>用于编译器认可的转型 *<code>reinterpret_cast</code>用于编译器不认可的转型，不做对齐操作，可能不具备可移植性* <code>const_cast</code>去除常量限定 * 动态转型，需要运行时支持 *<code>dynamic_cast</code>安全的向下转型</td></tr><tr class="even"><td><ahref="http://c.biancheng.net/cpp/biancheng/view/3297.html">C++四种类型转换运算符：static_cast、dynamic_cast、const_cast和reinterpret_cast</a></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> val = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a = val;<br></code></pre></td></tr></table></figure><p>以上代码操作时，val会先将值赋值给临时变量<code>const int temp</code>，然后将<code>const int temp</code>的结果作为<code>a</code>的引用，但是值得注意的是，引用<code>a</code>必须被<code>const</code>修饰，如果是如下操作，则会报错：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> val = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> &amp;a = val;<br></code></pre></td></tr></table></figure></p><table style="width:10%;"><thead><tr class="header"><th>* <strong>使用内联函数的注意事项</strong></th></tr></thead><tbody><tr class="odd"><td>*在<code>C</code>语言和<code>C++</code>语言中，<code>struct</code>结构体在定义对象时是有区别的。</td></tr><tr class="even"><td>1.如果在<code>C</code>语言中，需要使用<code>struct Test obj;</code>，要在语句前加上<code>struct</code>关键字。2.但在<code>C++</code>语言中，只需要使用<code>Test obj;</code>即可，<code>Test</code>结构体被认为是一个对象。</td></tr></tbody></table><ul><li>如果两个类<code>A</code>、<code>B</code>的定义中，分别定义了另一个类，如<code>A</code>类中定义了<code>B</code>类对象，<code>B</code>类中定义了<code>A</code>类对象，那么当我要在<code>B</code>中定义<code>A</code>类对象时，需要加入<code>A</code>头文件，但是<code>A</code>又要用到<code>B</code>类，然后继续<code>B</code>类用到<code>A</code>类，因此这是一个无限递归的过程，这样显然是不合理的。这时候需要使用<strong>前向声明</strong>，同时前向声明的类<code>A</code>不能实例化，我们只能在相应的<code>B</code>类中定义该<code>A</code>类的指针或引用，如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;    <span class="hljs-comment">//当B调用A时，前向声明A</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    A *ptr; <span class="hljs-comment">//只能声明A类指针或引用，不能声明一个A类对象</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>局部类</strong>：类也可以定义在函数体内，这样的类被称为局部类（<code>local class</code>），局部类只在定义它的局部域内可见。<strong>局部类的成员函数必须被声明在类体中</strong>（意思就是说局部类中的函数实现应当直接在类中实现好，而不是加上命名空间以后，拿在类外去实现）；而且<strong>局部类中是不能有静态成员</strong>的（<strong>疑问：为什么这里的局部类中无法定义静态变量呢？</strong>不太确定是否正确：静态变量是在编译时分配的，但是如果将静态变量定义在局部类中，那么只有在函数调用时才会分配，这显然不符合静态变量本身设计的理念，所以这样定义静态变量是错误的）。对于如下的实现，编译器会告知：<code>error: function definition is not allowed here</code>错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalClass</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> num_;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;num_ = num;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//对局部类来说 将成员函数实现写在类外会报错</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> num2_; <span class="hljs-comment">//局部类内部不能定义静态变量</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LocalClass::Display</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;num=&quot;</span> &lt;&lt; num_ &lt;&lt; endl; <span class="hljs-comment">//Error</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上，对于局部类，需要着重注意： 1.局部类的成员函数必须被实现在类体中 2. 局部类中不能有静态成员</p><p><strong>学习局部类和嵌套类时，我的另一个疑问：</strong></p><p><strong>疑问一：</strong>回想学到的知识，那么如果直接在类中实现成员函数，其函数是附带<code>inline</code>内联属性的，虽然编译器会根据代码的长度判断是否让该代码附加内联属性，但是我有一个疑问，是不是局部类的成员函数实现尽量还是简短一点好呢？因为如果类内实现函数的话，就会被定义为内联函数，但又因为其函数功能较长，被编译器取消<code>inline</code>属性，这样的反复折腾一遍，是否会影响代码性能呢？对于局部类的情况，如果真要实现复杂的功能，就会出现添加又取消内联属性的操作，或许会影响性能吧？</p><p><strong>疑问二：</strong>对于嵌套类的情况，为什么不使用类的继承功能而是将一个类嵌套到另一个类中？嵌套类和继承的本质区别到底是什么？如果嵌套类就可以满足继承的意思，那干嘛还要将两者都设计出来？</p><p><strong>疑问二答案：</strong>嵌套类和继承是两种不同的概念，能设计出来，必然有其各自的用途。当我学到继承的时候发现，嵌套类通常被称为<strong>组合</strong>，对于疑问二，实际上就是要理解继承与组合之间的区别。无论是继承还是组合，本质上都是把子对象放在新类型中，两者都是使用构造函数的初始化列表去构造这些子对象。<strong>组合通常是希望新类内部具有已存在的类的功能时使用，而不是希望已存在类作为它的接口。组合通过嵌入一个对象以实现新类的功能，而新类用户看到的是新定义的接口，而不是来自老类的接口。</strong>如果希望新类与已存在的类有相同的接口（在这基础上可以增加自己的成员）。这时候需要用继承，也称为<strong>子类型化</strong>。</p><hr /><p>在学习构造函数的时候，学到了<strong>类型转换构造函数（ConversionConstructor）</strong>，其概念如下： *定义类型转换构造函数的<strong>目的是实现类型的自动转换</strong>。 *<strong>只要一个参数，而且不是拷贝构造函数的构造函数</strong>，一般就可以看作是转换构造函数。* 当需要时，编译系统会自动调用转换构造函数，建立一个无名的临时对象。</p><p>我们看下面代码，就理解了什么是类型转换构造函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)&#123;<br>        num_ = a;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A obj;            <span class="hljs-comment">//调用无参数的构造函数A()&#123;&#125; 且num_为任意值</span><br>    <br>    A obj2 = <span class="hljs-number">34</span>;      <span class="hljs-comment">//等价于A obj2(34); 自动隐式类型转换调用A(int a)&#123;num_ = a&#125;构造函数</span><br>                      <span class="hljs-comment">//=不是运算符 表示初始化 此处不创建临时对象</span><br>    <br>    A obj3;           <span class="hljs-comment">//调用无参数的构造函数A()&#123;&#125;</span><br>    obj3 = <span class="hljs-number">55</span>;        <span class="hljs-comment">//一个值怎么能赋值给一个对象呢？因此：</span><br>                      <span class="hljs-comment">//1. 此处进行隐式类型转换首先通过A(int a)创建临时对象</span><br>                      <span class="hljs-comment">//2. 再通过=运算符重载将临时对象赋值给obj3</span><br>                      <span class="hljs-comment">//3. 销毁临时对象 调用临时对象的析构函数</span><br>                      <span class="hljs-comment">//如果等号右侧不是字面值而是A类对象，则调用默认拷贝构造函数</span><br>                      <span class="hljs-comment">//如果自己实现了拷贝构造函数，则不调用默认而调用自己实现的拷贝构造函数</span><br>                      <br>    A obj4;           <span class="hljs-comment">//定义obj4用于检测临时对象是否在=运算符结束后和obj4创建前销毁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>对于上述代码，我们最值得注意的就是，在调用类型转换构造函数的时候，我们所创建的临时对象会在<code>=</code>赋值结束后就立刻销毁，也就是说此时如果有析构函数，也会调用该临时对象的析构函数，那么此时这个<strong>临时对象的存在和销毁的周期是特别值得我们注意的点</strong>。</p><p>那么接下来我们加上析构函数，并添加一些打印信息，来看一下输出结果，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A()..&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int a)..&quot;</span> &lt;&lt; endl;<br>        num_ = a;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num_ &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num_ &lt;&lt; <span class="hljs-string">&quot; end!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A obj;<br>    obj.<span class="hljs-built_in">Display</span>(); <span class="hljs-comment">//调用无参数构造函数</span><br><br>    A obj2 = <span class="hljs-number">34</span>;<br>    obj2.<span class="hljs-built_in">Display</span>();<span class="hljs-comment">//调用一个参数的构造函数</span><br><br>    A obj3;        <span class="hljs-comment">//调用无参数构造函数</span><br>    obj3 = <span class="hljs-number">66</span>;     <span class="hljs-comment">//调用类型转换构造函数和默认的=运算符重载</span><br><br>    A obj4;        <span class="hljs-comment">//检测66创建的临时对象是否在obj4创建前销毁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 输出的结果如下，我们加上注释对对象销毁特殊说明：<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>..<br>num = <span class="hljs-number">391376933</span><br><span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params">int a</span>)</span>..<br>num = <span class="hljs-number">34</span><br><span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>..<br><span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params">int a</span>)</span>..<br>num = <span class="hljs-number">66</span> end!         <span class="hljs-comment">//此处为临时对象销毁</span><br><span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>..<br>num = <span class="hljs-number">0</span> end!          <span class="hljs-comment">//此处为obj4对象销毁</span><br>num = <span class="hljs-number">66</span> end!         <span class="hljs-comment">//此处为obj3对象销毁</span><br>num = <span class="hljs-number">34</span> end!         <span class="hljs-comment">//此处为obj2对象销毁</span><br>num = <span class="hljs-number">391376933</span> end!  <span class="hljs-comment">//此处为obj 对象销毁</span><br></code></pre></td></tr></table></figure></p><p>那么我们在看代码的时候发现临时对象使用默认的<code>=</code>运算符重载进行了赋值，<strong>一般默认的对象之间的赋值操作是对两个对象相同成员名的成员变量进行的一一对应的赋值</strong>，如果此时我们想要自己写一个<code>=</code>运算符重载呢？需要写如下成员函数，我们直接将其实现写在外部，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A &amp;A::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A &amp;other)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;other)<br>        <span class="hljs-keyword">this</span>-&gt;num_ = other.num_;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 以上就是在学习类型转换构造函数时学习到的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A obj = <span class="hljs-number">66</span>;<br>B obj2;<br>obj2 = obj; <span class="hljs-comment">//等价于 obj2.operator=(obj);</span><br></code></pre></td></tr></table></figure></p><p>如果我们要<strong>取消这样的隐式类型转换</strong>，也就是说不能执行以下两种情况：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A obj = <span class="hljs-number">30</span>; <span class="hljs-comment">//自动隐式转换为A obj(30) 调用一个参数的构造函数</span><br><br>A obj2;<br>obj2 = <span class="hljs-number">30</span>;  <span class="hljs-comment">//右值自动隐式转换 生成临时对象调用一个参数的构造函数 然后进行=运算符操作</span><br></code></pre></td></tr></table></figure></p><p>我们需要给一个参数的构造函数前加上<code>explicit</code>关键字，<code>explicit</code>是一个只提供给类构造函数使用的关键字，编译器不会把声明为<code>explicit</code>的构造函数用于隐式转换，用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上<code>explicit</code>关键字也没有什么意义。<strong>特别值得注意的是：这个关键字只能在类内声明或定义的函数前出现（意思就是如果某个构造函数的实现写在了外面，我们的关键字<code>explicit</code>只加在<code>class</code>中所声明或定义的部分之前，而并不需要加在外部实现部分的前面，如果加了那就会出错），用于让构造函数避免不必要的隐式转换，避免让隐式转换带来一些不易察觉的错误。</strong></p><p>就比如说如果构造函数的实现写在了<code>class</code>内，<code>explicit</code>关键字加在<code>class</code>的对应构造函数前：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;&#125; <span class="hljs-comment">//正确</span><br>&#125;;<br></code></pre></td></tr></table></figure>如果构造函数实现写在了<code>class</code>外，<code>explicit</code>关键字也只加在<code>class</code>中的对应构造函数前：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>; <span class="hljs-comment">//只需要将explicit写在class内部</span><br>&#125;;<br><br>A::<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)&#123;...&#125; <span class="hljs-comment">//这里就不需要写成explicit A::A(int a)&#123;...&#125;</span><br></code></pre></td></tr></table></figure>当加入<code>explicit</code>关键字后，对于上述两种隐式转换的情况，都会无法编译通过：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A obj = <span class="hljs-number">30</span>; <span class="hljs-comment">//Error</span><br><br>A obj2;<br>obj2 = <span class="hljs-number">30</span>;  <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure>以上即说明了类型转换构造函数、<code>=</code>运算符的重载、临时对象的生存周期还有关键字<code>explicit</code>用于消除隐式类型转换的使用方法等。那么<strong>类型转换构造函数实际上是将其它类型转换为类类型，与之相反的是类型转换运算符重载，是将类类型转换为其它类型。</strong>具体可参考链接：<ahref="https://blog.csdn.net/small_prince_/article/details/80518982">[C++重载之类型转换运算符]</a></p><hr /><ul><li><strong>对象创建与初始化列表的顺序无关，而与对象定义的顺序有关</strong>，如下代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> num):<span class="hljs-built_in">num_</span>(num)&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Container</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b):<span class="hljs-built_in">obj1_</span>(a), <span class="hljs-built_in">obj2_</span>(b)&#123;&#125;<br>    <span class="hljs-comment">//Container(int a, int b):obj2_(b), obj1_(a)&#123;&#125;</span><br>    <span class="hljs-comment">//调换初始化列表 依然先构造obj1_ 再狗仔obj2_ 构造顺序与初始化列表无关</span><br><span class="hljs-keyword">private</span>:<br>    Object obj1_;<br>    Object obj2_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么此时当我们在主函数中创建了一个有内存大小的<code>Container</code>类的对象的时候，按照我的理解，我们分析一下，如果要调用<code>Container</code>类的构造函数，我们没办法完全构造出来，因为在构造的过程中，初始化列表中<code>obj1_</code>和<code>obj2_</code>这两个<code>Object</code>类对象并没有构造出来，所以<code>C++</code>语言在设计的时候，当我们要创建这个类对象的时候，首先会按照类成员变量的顺序调用类成员所在的类的构造函数，放在上述代码上的话，则将<code>Container</code>中定义的所有类对象均先构造出来，因此我们首先会构造<code>obj1_</code>和<code>obj2_</code>这两个<code>Object</code>类对象，调用<code>Object</code>类的一个参数的构造函数（为什么调用一个参数的构造函数呢？因为初始化列表实际上就是一个初始化的操作，等价于<code>Object obj = num;</code>操作，就相当于<code>int a = 30；</code>而不是<code>int a; a= 30;</code>，可以细细品味一下，这是一步完成的），然后当类的所有<code>Object</code>构造完毕了，再执行<code>Container</code>类构造。</p><p>如果仍然难以理解，可以看下面的代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Object</span>()&#123;cout &lt;&lt; <span class="hljs-string">&quot;Object()..&quot;</span> &lt;&lt; endl;&#125;<br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> num):<span class="hljs-built_in">num_</span>(num)&#123;cout &lt;&lt; <span class="hljs-string">&quot;Object(int)..&quot;</span> &lt;&lt; num_ &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Object</span>()&#123;cout &lt;&lt; <span class="hljs-string">&quot;~Object..&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Container</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">obj1_</span>(a), <span class="hljs-built_in">obj2_</span>(b)&#123;cout &lt;&lt; <span class="hljs-string">&quot;Container..&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Container</span>()&#123;cout &lt;&lt; <span class="hljs-string">&quot;~Container..&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-keyword">public</span>:<br>    Object obj3_;<br><span class="hljs-keyword">private</span>:<br>    Object obj1_;<br>    Object obj2_;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Container <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>该代码在<code>main</code>实例化一个对象的时候，首先我们会发现<code>Container</code>类中定义了另外三个类对象，按照顺序，我们会先构造这三个类，首先调用<code>Object</code>类的无参构造函数用于创建<code>obj3_</code>对象，然后调用<code>Object</code>类的一个参数的构造函数，分别先创建<code>obj1_</code>对象，再创建<code>obj2_</code>对象。只不过我们需要注意的是，<code>obj1_</code>和<code>obj2_</code>的创建，调用的是<code>Object</code>类的一个参数的构造函数，为什么呢？因为在<code>Container</code>类的初始化列表中<code>obj1_(a), obj2_(b)</code>这样的写法实际上等同于传一个参数，去构造对象，因此我们需要调用<code>Object</code>类的一个参数的构造函数。上述代码结果及注释如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Object()..          //为obj3_对象的创建调用无参构造函数<br>Object(int)..1.     //为obj1_对象的创建调用一个参数的构造函数<br>Object(int)..2.     //为obj2_对象的创建调用一个参数的构造函数<br>Container..         //调用Container构造函数<br>~Container..        //调用Container析构函数<br>~Object..           //为obj2_对象的创建调用析构函数<br>~Object..           //为obj1_对象的创建调用析构函数<br>~Object..           //为obj3_对象的创建调用析构函数<br></code></pre></td></tr></table></figure></p><p>那如果<code>Container</code>类的初始化列表改为： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Container</span>():<span class="hljs-built_in">obj1_</span>(), <span class="hljs-built_in">obj2_</span>()&#123;&#125;<br><span class="hljs-built_in">Container</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b):<span class="hljs-built_in">obj1_</span>(), <span class="hljs-built_in">obj2_</span>()&#123;&#125;<br><span class="hljs-built_in">Container</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b):<span class="hljs-built_in">obj2_</span>(), <span class="hljs-built_in">obj1_</span>()&#123;&#125;<br></code></pre></td></tr></table></figure></p><p>改为以上任何一种类型，我们在创建<code>obj1_</code>和<code>obj2_</code>对象的时候，都调用的是<code>Object</code>类的无参构造函数。</p><table style="width:7%;"><thead><tr class="header"><th>*类的成员变量，如果成员变量是普通变量，可以不进行初始化，但<strong>如果是<code>const</code>类型的成员变量或引用类型的成员变量，必须在构造函数的初始化列表中进行初始化操作</strong>。</th></tr></thead><tbody><tr class="odd"><td>* 拷贝构造函数的参数类型<strong>必须是引用类型</strong></td></tr><tr class="even"><td>并非为了减少一次内存拷贝，唯一的原因在于：如果拷贝构造函数中的参数不是一个引用，即形如<code>A(const A obj)</code>，那么就相当于采用了<strong>传值的方式</strong>，而<strong>传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数</strong>。因此拷贝构造函数的参数必须是一个引用。需注意，传指针其实也是传值，如果上面的拷贝构造函数写成<code>A(const A *obj)</code>，也是不行的。<strong>只有传引用不是传值外，其他所有的传递方式都是传值。</strong></td></tr></tbody></table><p>拷贝构造函数调用的几种情况： *当函数的形参是类的对象，调用函数时，进行形参与实参结合时使用。这时要在内存新建立一个局部对象，并把实参拷贝到新的对象中。理所当然也调用拷贝构造函数。</p><ul><li>当函数的返回值是类对象，函数执行完成返回调用者时使用。理由也是要建立一个临时对象中，再返回调用者。为什么不直接要返回的局部对象呢？因为局部对象在离开建立它的函数时就消亡了，不可能在返回调用函数后继续生存，所以在处理这种情况时，编译系统会在调用函数的表达式中创建一个无名临时对象，该临时对象的生存周期只在函数调用处的表达式中。所谓<code>return</code>对象，实际上是调用拷贝构造函数把该对象的值拷入临时对象。如果返回的是变量，处理过程类似，只是不调用构造函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>():<span class="hljs-built_in">num_</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>:num_(num)&#123;</span>&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A &amp;other):<span class="hljs-built_in">num_</span>(other.num_)&#123;&#125;<br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A &amp;other)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;other) <span class="hljs-keyword">this</span>-&gt;num_ = other.num_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp;obj)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    obj = <span class="hljs-built_in">func</span>(obj);    <span class="hljs-comment">//调用拷贝构造函数创建临时对象 再通过=运算符重载将临时对象拷贝给obj</span><br>    <br>    A obj2 = <span class="hljs-built_in">func</span>(obj); <span class="hljs-comment">//调用拷贝构造函数创建临时对象 临时对象直接转正为obj2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述代码，需要注意的是，<code>obj = func(obj);</code>语句和<code>A obj2 = func(obj);</code>语句执行的过程是不同的，我们具体来分析一下，对于前者而言经过了以下几步：1.实参<code>obj</code>传入，一个引用形参<code>obj</code>接收该对象，然后当函数<code>func</code>返回形参<code>obj</code>时，我们形参的生命周期就会结束，需要在函数体结束前释放该内存，但返回值是一个<code>A</code>类对象，为了返回该对象，我们会创建一个临时对象用于开辟一个新的临时内存，保存函数中的<code>obj</code>对象，此时要将<code>obj</code>所引用的对象传递给临时对象，因此我们要调用返回值<code>A</code>类的临时对象的拷贝构造函数。2.调用完毕后函数体中<code>obj</code>所引用的对象就传递给了新创建的临时对象，此时函数体会结束，释放引用（这里不会调用析构函数，只是对引用本身进行释放，而不是对具体引用的地址进行释放，这里需要注意。同时这里返回所引用对象时，该对象会作为返回值所在类的拷贝构造函数的传入参数传递进去，以此来构造临时对象）。3.当函数体结束，内存释放完毕后，同时也创建了一个临时对象，我们会将临时对象赋值给<code>A</code>类对象<code>obj</code>，此时会调用<code>A</code>类中实现的<code>=</code>运算符重载，最终<code>obj</code>被成功修改。4.紧接着当<code>=</code>运算符重载赋值操作完毕后，就立即开始调用临时对象的析构函数来释放临时对象的内存，而非等到<code>main</code>函数结束时才开始调用析构函数。5.以上执行完毕后，即<code>main</code>函数体中的<code>obj</code>对象的赋值操作完毕。</p><p>那么以上五步则是<code>obj = func(obj);</code>语句的过程，对于<code>A obj2 = func(obj);</code>这个语句，执行过程与上述步骤唯一不同的点在于第三、四步，这里的临时对象不需要进行<code>=</code>运算符重载的赋值操作，直接将临时对象作为我们的<code>obj2</code>对象即可。</p><p>以上两个语句的不同点就和下面的代码不同点一样，可以细细品一下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*创建+赋值 分两步完成*/</span><br><span class="hljs-type">int</span> a;        <span class="hljs-comment">//A obj;</span><br>a = <span class="hljs-number">20</span>;       <span class="hljs-comment">//obj = func(20);</span><br><br><span class="hljs-comment">/*直接创建的时候初始化 一次性完成*/</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;   <span class="hljs-comment">//A obj = func(20);</span><br></code></pre></td></tr></table></figure></p><p>那么在学习和分析上述代码传参及返回值的过程中，突然又遇到了另一个问题，比如对于下面的代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>():<span class="hljs-built_in">num_</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>:num_(num)&#123;</span>&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A &amp;other):<span class="hljs-built_in">num_</span>(other.num_)&#123;&#125;<br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A &amp;other)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;other) <span class="hljs-keyword">this</span>-&gt;num_ = other.num_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp;obj)</span></span>&#123; <span class="hljs-comment">//此处返回值为A 而非const A</span><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    A &amp;obj2 = <span class="hljs-built_in">func</span>(obj); <span class="hljs-comment">//正确的写法应该是：const A &amp;obj2 = func(obj);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>此代码与上面不同点在于<code>func</code>函数返回了一个临时对象，但是作为<code>obj2</code>引用的右值，被其所引用，是的，在<code>Microsoft Visual Studio</code>上面是正确的，这或许是编译器的优化，使得临时对象作为引用的右值得以保留下来而不被销毁（当然这只是我的猜测，具体因编译器而异），就比如在我自己电脑使用<code>Apple clang version 12.0.0</code>去编译代码是不通过的，给我报的错误是引用作为非<code>const</code>左值，是不能绑定到一个临时对象上的。</p><p>我现在的疑问是：<strong>为什么非<code>const</code>引用不能绑定临时对象？</strong>是因为临时对象会立即销毁所以引用失效，为了避免出现引用失效的情况因此才编译失败？那么问题又来了，既然临时对象会销毁，为什么在<code>Microsoft Visual Studio</code>上又可以保留（其实是编译器优化的结果）？那还有个问题，<strong>既然创建的临时对象是会销毁的，为什么引用加入<code>const</code>关键字后变成<code>const A &amp;obj2 = func(obj);</code>就又可以编译通过了呢？</strong>带着以上问题，作出如下解答：</p><h4id="为什么非const类型的左值引用不能绑定临时对象呢"><strong>为什么非<code>const</code>类型的左值引用不能绑定临时对象呢？</strong></h4><p>对于这个问题，<code>C++</code>的设计必然有它存在的意义，我在看<code>More Effective C++</code>的条款<code>19</code>的时候，说到了这样一个场景：首先我们的<strong>类型转换发生在传值方式传递对象或传递<code>const</code>引用参数</strong>时，当传一个非<code>const</code>引用参数对象时就不会发生，为什么呢？考虑一下这个函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">uppercasify</span><span class="hljs-params">(string &amp;str)</span></span>; <span class="hljs-comment">//用于把str所有字符改变为大写</span><br></code></pre></td></tr></table></figure>在这里试图用<code>char</code>数组调用<code>uppercasify</code>函数，这样做是错误的，并不会成功：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;Effective C++&quot;</span>;<br><span class="hljs-built_in">uppercasify</span>(s);              <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure>按道理，我们的<code>s</code>数组传入时，因为要让一个<code>string</code>类型的引用接收，为了使类型匹配，首先会创建一个临时的<code>string</code>对象来拷贝一份<code>s</code>数组的内容，然后将形参<code>str</code>引用绑定至刚创建的临时对象上，如果形参形如<code>const string &amp;str</code>的话，就可以这么做，但非<code>const</code>就不行，这到底是为啥呢？为啥我加上<code>const</code>关键字就可以引用我临时创建的对象了呢？假设现在用非<code>const</code>引用接收临时对象，临时对象将被传递到<code>uppercasify</code>中，函数的功能是将字符变为大写，就会去修改这个临时对象，把它的字符改成大写。但是函数<code>uppercasify</code>调用的非<code>const</code>参数引用的是临时对象，和原本传入的<code>s</code>数组之间没有任何关系；当我们期望修改非临时对象时，对非<code>const</code>引用进行的隐式类型转换去修改临时对象，而不是实际的非临时对象数组<code>s</code>，那我们的修改将无济于事，这不是我们所期望的，那干嘛还要用非<code>const</code>引用去接收一个临时对象呢是吧？因此<code>C++</code>语言禁止让非<code>const</code>引用去接收临时对象。</p><p>函数返回时，也会产生临时对象： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>;<span class="hljs-comment">//Matrix是一个矩阵类型</span><br><span class="hljs-type">const</span> Matrix <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Matrix &amp;l, <span class="hljs-type">const</span> Matrix &amp;r)&#123;<br>    Matrix sum;<br>    ...<br>    <span class="hljs-keyword">return</span> sum;<span class="hljs-comment">//sum存储最后结果</span><br>&#125;<br></code></pre></td></tr></table></figure>由于<code>operator+</code>调用结束时<code>sum</code>会被销毁，因此需要构造一临时<code>Matrix</code>对象，在<code>return</code>时将<code>sum</code>的值拷贝给该临时对象（具体过程可参考《深度探索C++面向对象模型》第二章“返回值的优化”）。</p><p>所以我们<strong>在通过引用去接收临时对象或返回一个临时对象时，一定要在适当位置加上关键字<code>const</code>。</strong></p><h4id="既然临时对象会销毁那么const引用为何能够绑定临时对象呢"><strong>既然临时对象会销毁，那么const引用为何能够绑定临时对象呢？</strong></h4><p>具体原因是：<strong><code>const</code>引用可以延长函数返回的临时对象的生命周期</strong>。<code>stackoverflow</code>中讨论了用<code>const</code>引用接收临时对象，也谈及到引用对临时对象生命周期的延长。（<ahref="https://stackoverflow.com/questions/38226443/const-reference-to-member-of-temporary-object">参考链接</a>）</p><p>那么接下来对于以下代码，<code>func</code>函数此时如果返回引用类型，又该怎么写？如果返回引用，那就必须加上<code>const</code>关键字返回了，或者通过类型转换<code>const_cast&lt;&gt;</code>对返回值进行转换，那该怎么理解下面的代码呢？<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>():<span class="hljs-built_in">num_</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>:num_(num)&#123;</span>&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A &amp;other):<span class="hljs-built_in">num_</span>(other.num_)&#123;&#125;<br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A &amp;other)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;other) <span class="hljs-keyword">this</span>-&gt;num_ = other.num_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_;<br>&#125;;<br><span class="hljs-comment">//错误的写法</span><br><span class="hljs-function">A &amp;<span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp;obj)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><span class="hljs-comment">//正确的写法1</span><br><span class="hljs-function"><span class="hljs-type">const</span> A &amp;<span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp;obj)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><span class="hljs-comment">//正确的写法2</span><br><span class="hljs-function">A &amp;<span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp;obj)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;A &amp;&gt;(obj);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    A obj2 = <span class="hljs-built_in">func</span>(obj);<br>    <br>    A obj3;<br>    obj3 = <span class="hljs-built_in">func</span>(obj);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>以上写法为何加<code>const</code>后就正确了呢？我们或许会把此处和上面讲的关联起来思考，这就让理解变得更加复杂了。其实加<code>const</code>原因很简单，因为<code>func</code>函数形参加了<code>const</code>，要返回这个形参，那么返回值也需要<code>const</code>属性，我们不可能将一个<code>const</code>属性的引用，让他取消掉<code>const</code>属性然后返回吧？这里需要注意和理解。</p><p>然后在<code>main</code>中用<code>obj2</code>去接收，实际上返回引用相当于返回一个对象，那么用对象去接收，就调用了<code>obj2</code>对象所对应类的拷贝构造函数，将<code>func</code>中引用的对象传递给<code>obj2</code>对象所在类的拷贝构造函数中，以此来生成<code>obj2</code>对象。那如果是<code>obj3</code>所对应的情况，则是将引用的对象传递给<code>obj3</code>对象所在类的<code>=</code>等号运算符重载函数，进行一个运算符重载的过程。</p><table style="width:10%;"><thead><tr class="header"><th>总结三条对象优化的规则： 1.函数参数传递过程中，对象优化按引用传递，不要按值传递 2.函数返回对象时，应优先返回一个临时对象，而不要返回一个定义过的对象 3.接收返回值是对象的函数调用的时候，优先按初始化的方式接收，不要按赋值的方式接收</th></tr></thead><tbody><tr class="odd"><td>创建一个空类，默认会有哪些成员被创建呢？默认产生的成员有：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span>&#123;&#125;;<br><span class="hljs-built_in">Empty</span>();                          <span class="hljs-comment">//1. 默认构造函数</span><br><span class="hljs-built_in">Empty</span>(<span class="hljs-type">const</span> Empty &amp;);             <span class="hljs-comment">//2. 默认拷贝构造函数</span><br>~<span class="hljs-built_in">Empty</span>();                         <span class="hljs-comment">//3. 默认析构函数</span><br>Empty &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Empty &amp;);  <span class="hljs-comment">//4. 默认=赋值运算符重载</span><br>Empty *<span class="hljs-keyword">operator</span>&amp;();               <span class="hljs-comment">//5. 取址运算符</span><br><span class="hljs-type">const</span> Empty *<span class="hljs-keyword">operator</span>&amp;() <span class="hljs-type">const</span>;   <span class="hljs-comment">//6. 取址运算符 const</span><br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>那么第五和第六个取地址运算符重载实际上就是对比普通对象和常量对象进行取地址：</td></tr><tr class="odd"><td><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Empty obj;<br>Empty *ptr = &amp;obj;         <span class="hljs-comment">//等价于 Empty *ptr = obj.operator&amp;();</span><br><br><span class="hljs-type">const</span> Empty obj2;<br><span class="hljs-type">const</span> Empty *ptr2 = &amp;obj2; <span class="hljs-comment">//等价于 const Empty *ptr2 = &amp;obj2.operator&amp;() const;</span><br></code></pre></td></tr></table></figure></td></tr></tbody></table><p><code>static</code>的作用： 1.<strong>保持变量内容持久</strong>：<code>static</code>作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。2.<strong>隐藏</strong>：<code>static</code>作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）3.<strong><code>static</code>作用于类的成员变量和类的成员函数</strong>：使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。</p><p><code>static</code>作用于类成员变量和类成员函数： *<code>static</code>成员是命名空间，属于类的全局变量，存储在<code>data</code>区。*<code>static</code>成员函数只能返回<code>static</code>成员，不能用<code>this</code>指针，<code>static</code>成员函数属于类而不属于类对象。（补充：友元函数也没有指针）*非<code>static</code>成员函数可以访问<code>static</code>成员函数或变量，但<code>static</code>成员函数不可以访问非<code>static</code>成员函数或变量（静态成员函数无隐含的<code>this</code>指针指向某个对象，因此无法访问对象的非静态成员）。</p><h4 id="static成员变量">static成员变量</h4><p>这里需要注意的是，有以下两种情况静态成员变量的定义和使用，一种是普通类静态成员变量，一种是带有<code>const</code>的类静态成员变量。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> s;<br>&#125;;<br><br><span class="hljs-type">int</span> A::s = <span class="hljs-number">100</span>; <span class="hljs-comment">//如果不指定值 默认为0 但是必须在类外进行定义性说明</span><br></code></pre></td></tr></table></figure>对于上述代码，静态成员变量<code>s</code>在类<code>A</code>中仅为声明，不分配内存，同时内部不能初始化一个值，我们需要在外部定义或初始化，同时注意，外部的定义不能加关键字<code>static</code>。那么对于带<code>const</code>的静态成员变量，我们看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> s = <span class="hljs-number">100</span>;<br>&#125;;<br><br><span class="hljs-comment">//const int A::s = 200; 无需进行类外的定义性说明</span><br></code></pre></td></tr></table></figure><p>对于带<code>const</code>关键字的静态成员变量来说： 1.首先<code>const</code>只能修饰<code>int</code>或<code>char</code>类型，那么在类<code>A</code>中如果声明了静态的<code>double</code>成员，即<code>const static double s = 100;</code>，则是错误的，去掉关键字<code>const</code>则正确。2.其次呢，带<code>const</code>的静态成员变量，在类<code>A</code>中声明的时候，必须给定一个初始值（在<code>VC++6.0</code>中是错误的，因为其版本较老，不支持该语法）。3.对于带有<code>const</code>修饰的静态成员变量，可以不在外部定义，当创建类对象时，如果其为<code>public</code>，直接可以进行访问。</p><p>对于以上三点，需注意：<code>const</code>只能修饰<code>int</code>和<code>char</code>类型，还有<code>const</code>静态成员变量声明时必须给定初始值，带<code>const</code>的静态成员变量，可以不需进行类外的定义性说明（当然写了也没事），这三个地方与非<code>const</code>成员变量是有区分的。</p><p>最后对于静态成员变量，需要注意： 1.在类外对静态成员变量进行定义性说明时，不要带有<code>static</code>关键字，不带<code>static</code>关键字的目的是为了避免与一般的静态成员变量或对象进行混淆，也不要带有<code>private</code>、<code>public</code>、<code>protected</code>访问规则。2.静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。3.静态成员变量可以作为成员函数的参数，而普通成员变量不可以。（参考示例代码一）4.静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。（参考示例代码二）</p><p>示例代码一： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> s_var;<br>    <span class="hljs-type">int</span> var;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> i = s_var)</span></span>; <span class="hljs-comment">// 正确，静态成员变量可以作为成员函数的参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">int</span> i = var)</span></span>;   <span class="hljs-comment">//  error: invalid use of non-static data member &#x27;A::var&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>示例代码二： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> A s_var; <span class="hljs-comment">// 正确，静态数据成员</span><br>    A var;          <span class="hljs-comment">// error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27;</span><br>    A *p;           <span class="hljs-comment">// 正确，指针</span><br>    A &amp;var1;        <span class="hljs-comment">// 正确，引用</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><h4 id="static成员函数">static成员函数</h4><p>静态成员函数只能访问和调用静态成员变量或函数，因为静态成员函数没有<code>this</code>指针。静态成员函数做为类作用域的全局函数。静态成员函数不能声明成虚函数（<code>virtual</code>）、<code>const</code>函数和<code>volatile</code>函数。</p><p>如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; x_ &lt;&lt; endl;<br>        <span class="hljs-built_in">TestStaticFunc</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">TestStaticFunc</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//cout &lt;&lt; y_ &lt;&lt; endl; // error static函数不能访问非static变量或函数</span><br>        cout &lt;&lt; x_ &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> x_;<br>    <span class="hljs-type">int</span> y_;<br>&#125;;<br></code></pre></td></tr></table></figure>我们发现静态成员函数，只能访问静态成员函数或变量。<strong>同时我们需要注意，当访问一个类静态变量或函数时，可以通过<code>对象.func()</code>的方式，也可以通过<code>类名::func()</code>的方式，在书写可读性方面，推荐按照后者去书写。</strong>如果我们想要访问静态成员函数所在类的非静态成员函数或成员变量，那么需要在传参处传入一个<code>this</code>指针，我们可以使用<code>void *arg</code>去接收。对于上述例子，假设在外部定义了静态函数<code>TestStaticFunc(void *arg)</code>，还需要一个辅助函数传入<code>this</code>指针，即可改为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestStaticFunc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>    A *obj = <span class="hljs-built_in">static_cast</span>&lt;A *&gt;(arg);<br>    std::cout &lt;&lt; obj-&gt;x_ &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::Func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">TestStaticFunc</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//将Func函数隐含的第一个参数this传入给静态函数，让静态函数能够在函数体中调用类成员</span><br>&#125;<br></code></pre></td></tr></table></figure></p><table style="width:8%;"><tbody><tr class="odd"><td>* <strong>类大小计算</strong>： 1. 类大小计算遵循结构体对齐原则 2.类大小<strong>与数据成员有关，与成员函数无关</strong> 3.类大小<strong>与静态成员无关</strong>（因为静态成员可用于多个类对象共享，所以不单独计算至类中）4. 虚函数对类大小的影响（虚函数表指针，学到后面会补充） 5.虚继承对类大小的影响</td></tr></tbody></table><p><strong>单例模式：</strong>保证一个类只有一个实例,并提供一个全局访问点。禁止拷贝。要想实现单例模式，也就是说我们能创建的类对象仅仅只有一个，那么我们需要将构造函数写入到类的<code>private</code>属性当中去，以此来避免外部显式创建多个对象。那这个时候我们又要访问这个构造函数，因此，我们人为的去提供一个全局的访问点，这样的全局访问点不属于某一个对象，而是属于这个类，那就涉及到了<code>static</code>，即我们会提供一个静态的成员函数来返回实例，那么如何实现一个单例模式呢？来看下面代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton *<span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(instance_ == <span class="hljs-literal">NULL</span>)<br>            instance_ = <span class="hljs-keyword">new</span> Singleton; <span class="hljs-comment">//instance_指向Singleton对象 对象在堆上</span><br>        <span class="hljs-keyword">return</span> instance_; <span class="hljs-comment">//我们说静态成员是不属于某个对象的 因此不能使用this指针</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>()&#123;&#125;<br>    <span class="hljs-type">static</span> Singleton *instance_; <span class="hljs-comment">//声明</span><br>&#125;;<br><br>Singleton *Singleton::instance_; <span class="hljs-comment">//定义</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Singleton *s1 = Singleton::<span class="hljs-built_in">GetInstance</span>();<br>    Singleton *s2 = Singleton::<span class="hljs-built_in">GetInstance</span>();<br>    cout &lt;&lt; s1 &lt;&lt; endl; <span class="hljs-comment">//0x1322eb0</span><br>    cout &lt;&lt; s2 &lt;&lt; endl; <span class="hljs-comment">//0x1322eb0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>我们将构造函数设置为<code>private</code>属性，然后通过静态成员函数返回一个对象指针，那么这个指针必须是静态的，因为这个指针不属于任何某个对象，而是属于这个类，我们通过这个静态指针来访问其指向的堆空间，这个堆空间是我们通过全局访问点<code>GetInstance</code>函数来创建的，我们通过<code>new</code>调用该类的构造函数<code>Singleton()&#123;&#125;</code>来在堆上开辟一个空间。尽管我们调用了两次全局访问点，但只调用了一次构造函数，通过上述代码输出，可以看到单例模式所创建的对象仅仅只能有一个，代码中的两个类指针<code>s1</code>和<code>s2</code>均指向同一块内存地址。</p><p>只不过以上代码的缺点在于，首先，未对<code>new</code>的内存空间进行释放。我们知道，当我们在外部函数定义一个对象时，当对象销毁时必然会调用其析构函数，但是此时我们定义的仅仅是一个对象指针，因此不会调用其构造函数，但是我们发现输出的结果还是调用了一次构造函数，那是因为我们在调用静态成员函数<code>Singleton::GetInstance()</code>时，其内部调用了<code>new</code>关键字，所以在对对象分配堆空间时会调用对象所在类的构造函数，但是此时当我们程序结束时，不会自动的调用类所在的析构函数去释放空间，C++内部缺少这一机制，当我们在使用<code>new</code>分配空间时，也一定要记得在使用完毕后通过<code>delete</code>关键字释放空间。其次，允许调用拷贝构造函数（但实际上单例模式不允许拷贝）。所以也算不上是一个完全正确的单例模式，接下来我们对上述代码进行完善。</p><h4 id="单例模式中的禁止拷贝">单例模式中的禁止拷贝</h4><p>那么单例模式中<strong>不允许拷贝</strong>的意思强调的就是说，不允许调用拷贝构造函数，也不允许调用等号运算符重载，因此只需要人为在<code>private</code>中进行如下声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;other);            <span class="hljs-comment">//禁止外部调用拷贝构造函数</span><br>    Singleton &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;other); <span class="hljs-comment">//禁止外部进行等号赋值拷贝</span><br></code></pre></td></tr></table></figure></p><h4 id="单例模式中资源空间的释放">单例模式中资源空间的释放</h4><p><strong>方法一：</strong>那么接下来我们对<code>new</code>出的内存空间进行释放，我们首先想到的解决方法是，在<code>Singleton</code>类中声明一个静态的<code>Free</code>函数，然后在对应外部代码手动去调用<code>Free</code>，对创建的堆空间进行释放，那么我们在类的<code>public</code>属性下声明静态的<code>Free</code>函数，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Free</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(instance_ != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">delete</span> instance_;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>但是这样做也存在一定的问题，我们认为，将释放空间的代码交接给人为去进行是一种非常危险的操作，如果人为操作不当，可能会出现不必要的错误。</p><p><strong>方法二：</strong>我们想要类生命周期结束前自动释放，因此我们采用了嵌套类的方法巧妙的进行了释放操作，完整代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton *<span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(instance_ == <span class="hljs-literal">NULL</span>)<br>            instance_ = <span class="hljs-keyword">new</span> Singleton;<br>        <span class="hljs-keyword">return</span> instance_;<br>    &#125;<br>    <br>    <span class="hljs-comment">/* 提供嵌套类用于垃圾回收</span><br><span class="hljs-comment">     * 当嵌套类的静态对象garbo_释放时会调用~Garbo()&#123;..&#125;析构函数</span><br><span class="hljs-comment">     * ～Garbo()&#123;..&#125;析构函数会调用delete关键字释放instance_指向的内存</span><br><span class="hljs-comment">     * delete关键字又会触发~Singleton()&#123;..&#125;析构函数 */</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Garbo</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        ~<span class="hljs-built_in">Garbo</span>()&#123;<br>            <span class="hljs-keyword">if</span>(Singleton::instance_ != <span class="hljs-literal">NULL</span>)<br>                <span class="hljs-keyword">delete</span> instance_;<br>        &#125;<br>    &#125;;<br>    ~<span class="hljs-built_in">Singleton</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Singleton ...&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    static void Free()&#123;</span><br><span class="hljs-comment">        if(instance_ != NULL)</span><br><span class="hljs-comment">            delete instance_;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;other);            <span class="hljs-comment">//禁止外部调用拷贝构造函数</span><br>    Singleton &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;other); <span class="hljs-comment">//禁止外部进行等号赋值拷贝</span><br>    <span class="hljs-built_in">Singleton</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Singleton ...&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">static</span> Singleton *instance_;       <span class="hljs-comment">//声明</span><br>    <span class="hljs-type">static</span> Garbo garbo_;<br>&#125;;<br><br>Singleton::Garbo Singleton::garbo_;    <span class="hljs-comment">//定义</span><br>Singleton *Singleton::instance_;       <span class="hljs-comment">//定义</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Singleton *s1 = Singleton::<span class="hljs-built_in">GetInstance</span>();<br>    Singleton *s2 = Singleton::<span class="hljs-built_in">GetInstance</span>();<br>    <span class="hljs-comment">//Singleton::Free();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>以上代码巧妙利用嵌套类，首先全局区创建两个静态变量，首先因为外部对<code>garbo_</code>类对象进行定义，因此会调用内部嵌套类<code>Garbo</code>的构造函数；但是需要注意的是尽管定义了<code>instance_</code>指针，但指针定义并不会触发<code>Singleton</code>类的构造函数，只有创建对象时才会调用构造函数。</p><p>当用户显示调用<code>Singleton</code>类的静态方法<code>GetInstance()</code>去开辟一个内存空间后，因为单例模式下并不会创建一个实例对象，因此析构函数也无法调用，不能将内存回收相关代码写至析构函数当中，那我们该如何释放空间呢？我们明确知道<code>Garbo</code>类对象<code>garbo_</code>在程序结束后一定会调用其析构函数<code>~Garbo</code>的，因此可以通过在嵌套类的析构函数中定义内存回收方法，以此来达到回收单例模式下内存空间的效果。所以当代码生命周期结束，静态对象<code>garbo_</code>释放并调用析构函数<code>~Garbo</code>，在析构函数<code>~Garbo</code>中通过<code>delete</code>关键字，对<code>Singleton</code>类<code>instance_</code>指针指向的堆内存空间进行释放，此时在释放的过程中触发<code>Singleton</code>类的析构函数<code>~Singleton</code>，当嵌套类中外层的<code>~Singleton</code>析构函数执行完毕后，内层析构函数<code>~Garbo</code>再从<code>delete</code>关键字下面继续执行。</p><p><strong>方法三：</strong>我们还可以对上述代码进一步优化，我们知道，对于一个函数而言，当函数内部定义一个静态变量时，静态变量的生存周期存在于整个程序运行周期中，而非仅仅该函数，也就是说如果下次再次进入该函数，那么局部静态变量的值应该为上一次修改后的值，那么同样的，我们也可以创建一个静态的局部对象，当下次再次调用函数的时候，我们依旧使用上次的对象，依据这个特点，我们将代码修改为如下形式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton &amp;<span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">//返回对象地址也可以</span><br>    <span class="hljs-comment">//然后main中需要使用指针接收 Singleton *s3 = Singleton::GetInstance();</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    static Singleton *GetInstance()&#123;</span><br><span class="hljs-comment">        static Singleton instance;</span><br><span class="hljs-comment">        return &amp;instance;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    ~<span class="hljs-built_in">Singleton</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Singleton ...&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;other);<br>    Singleton &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;other);<br>    <span class="hljs-built_in">Singleton</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Singleton ...&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Singleton &amp;s1 = Singleton::<span class="hljs-built_in">GetInstance</span>(); <span class="hljs-comment">//通过引用接收</span><br>    Singleton &amp;s2 = Singleton::<span class="hljs-built_in">GetInstance</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>上述方法返回一个静态对象引用，在静态成员函数<code>GetInstance</code>中，创建一个静态对象<code>instance</code>，然后将其返回即可，那么如果下次我们在此调用静态成员函数<code>GetInstance</code>时，依然使用的是当前所引用的静态对象<code>instance</code>，当<code>main</code>程序周期结束时，会调用该静态成员对象的析构函数，将对象释放掉。</p><p>这个改进方法的单例模式是最简单的，但是仍然有缺点，它不是线程安全的，那么如何实现一个线程安全的单例模式呢？后面学完会过来再讨论一下如何编写一个线程安全的单例模式，<del>并将其修改为模板</del>。<strong>“构造函数在什么场景下定义为私有的”这个问题，这在思考9中也有涉及到，也就是我们这里说的当采用单例模式场景时，会将构造函数设置为私有。</strong></p><p>补充模板的方法，通过模板来实现一个简单的单例模式，主要有两部分，一部分为<code>Singleton.h</code>头文件，另一部分为测试文件<code>main.cpp</code>：<strong>Singleton.h：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _SINGLETON_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SINGLETON_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> T &amp;<span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> T instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;other);<br>    Singleton &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;other);<br>    <span class="hljs-built_in">Singleton</span>();<br>    ~<span class="hljs-built_in">Singleton</span>();<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><p><strong>main.cpp：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Singleton.h&quot;</span></span><br><br><span class="hljs-comment">// 包装器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationImpl</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ApplicationImpl</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;ApplicationImpl ...&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">ApplicationImpl</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~ApplicationImpl ...&quot;</span> &lt;&lt; endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Run ...&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> Singleton&lt;ApplicationImpl&gt; Application;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// Application a; // 无法直接定义 因为Singleton中构造函数在私有部分</span><br>    <span class="hljs-comment">// Singleton&lt;ApplicationImpl&gt;::GetInstance();</span><br>    Application::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">Run</span>();<br>    Application::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">Run</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>运行上述代码，得到的结果是： <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">ApplicationImpl</span></span> ...<br><span class="hljs-function"><span class="hljs-title">Run</span></span> ...<br><span class="hljs-function"><span class="hljs-title">Run</span></span> ...<br>~ApplicationImpl ...<br></code></pre></td></tr></table></figure></p><p>模板最重要的是传入的<strong>类型参数</strong>，上述代码给模板传入了一个类类型，即<code>ApplicationImpl</code>类类型；然后我们在<code>Singleton.h</code>头文件中可以看到<code>Singleton</code>类的构造函数写在<code>private</code>中，因此<code>main.cpp</code>中无法直接创建一个传入类型为<code>ApplicationImpl</code>的模板对象，同时也可以看到<code>Singleton.h</code>中的静态方法返回的是一个<code>T</code>类型对象引用，即<code>ApplicationImpl</code>类类型对象，因此这个对象既有单例的特性，又可以调用其方法<code>Run()</code>。我们看到模板传入<code>ApplicationImpl</code>类类型后，通过<code>static T instance</code>语句创建静态类对象，因为模板传入的<code>T</code>是类类型，因此会调用该类的构造函数和析构函数，但是该静态对象只有一份，所以我们看到当在<code>main.cpp</code>中调用两次<code>Run()</code>成员方法之前仅调用一次<code>ApplicationImpl</code>类的类构造函数。</p><p>我们还可以通过模板，实现以指针指向堆空间的方式进行单例模式的创建，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _SINGLETON_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SINGLETON_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> T &amp;<span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">Init</span>(); <span class="hljs-comment">//初始化对象</span><br>        <span class="hljs-keyword">return</span> *instance_;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//静态成员函数GetInstance不能调用非静态成员 因此将Init设置为静态函数</span><br>        <span class="hljs-keyword">if</span>(instance_ == <span class="hljs-literal">nullptr</span>) &#123;<br>            instance_ = <span class="hljs-keyword">new</span> T;<br>            <span class="hljs-built_in">atexit</span>(Destory); <span class="hljs-comment">//atexit 函数指针接收一个函数 在程序结束时回调该函数 此处回调Destory</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Destory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">delete</span> instance_;<br>    &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;other);<br>    Singleton &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;other);<br>    <span class="hljs-built_in">Singleton</span>();<br>    ~<span class="hljs-built_in">Singleton</span>();<br><br>    <span class="hljs-type">static</span> T *instance_;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T *Singleton&lt;T&gt;::instance_ = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//static指针在外定义时无需加static关键字</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>上述代码实现中，得利用函数<code>atexit</code>注册一个回调函数，待整个程序执行结束后，调用该注册的回调函数。若有多个注册，则先注册的函数最后调用，<code>atexit</code>函数包含在头文件<code>stdlib</code>中。推荐使用这种方式而非智能指针的方式进行内存的释放。但是以上改进后的单例模式依然不是线程安全的。比如两个线程同时访问<code>Init()</code>，判断<code>instance_</code>均为空，则会<code>new</code>申请调用两次。因此如果要避免这种线程安全问题，可在<code>Init()</code>调用时加上锁机制，大致如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">LOCK</span><br><span class="hljs-function">    <span class="hljs-title">if</span><span class="hljs-params">(instance_ == <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br>        instance_ = <span class="hljs-keyword">new</span> T;<br>        <span class="hljs-built_in">atexit</span>(Destory);<br>    &#125;<br>    UNLOCK<br>&#125;<br></code></pre></td></tr></table></figure>如果在<code>Linux</code>平台，推荐使用<code>pthread_once()</code>，用于解决线程安全问题。</p><p><strong>懒汉模式/饿汉模式实现模板（线程安全）</strong>懒汉模式：内部静态变量，在全局访问点<code>getInstance</code>中定义静态实例。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">pthread_mutex_t</span> mutex;<br>    <span class="hljs-built_in">Singleton</span>()&#123;<br>        <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp; temp)&#123;&#125;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp; temp)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> Singleton* <span class="hljs-built_in">getInstance</span>()&#123; <br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> &amp;instance;<br>    &#125;<br>&#125;;<br><span class="hljs-type">pthread_mutex_t</span> Singleton::mutex; <br></code></pre></td></tr></table></figure></p><p>饿汉模式：饿汉模式本身就是线程安全的不用加锁。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp; temp)&#123;&#125;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp; temp)&#123;&#125;<br><span class="hljs-keyword">protected</span>:<br> <span class="hljs-built_in">Singleton</span>()&#123;&#125; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> Singleton* <span class="hljs-built_in">getInstance</span>()&#123; <br>        <span class="hljs-keyword">return</span> instance;    <br>    &#125;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br></code></pre></td></tr></table></figure></p><hr /><p>如果说一个类中的成员函数用<code>const</code>修饰，说明无法通过<code>this</code>指针对成员变量进行修改，那如果非要修改呢？<code>C++</code>其实给我们提供了这样的操作，就比如遇到以下场景：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">outputTimes_</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Output</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x=&quot;</span> &lt;&lt; x_ &lt;&lt; endl;<br>        ++outputTimes_;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetOutputTimes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> outputTimes_;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_;<br>    <span class="hljs-type">int</span> outputTimes_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    obj.<span class="hljs-built_in">Output</span>();<br>    obj.<span class="hljs-built_in">Output</span>();<br>    cout &lt;&lt; obj.<span class="hljs-built_in">GetOutputTimes</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>我们可以看到，上述代码中<code>Output</code>成员函数想要打印成员变量<code>x_</code>，并且统计打印的次数，可以看到内部每次都对<code>outputTimes_</code>进行<code>++</code>操作，但是实际上这种行为是错误的，因为<code>Output</code>成员函数被<code>const</code>修饰了，那么<code>const</code>修饰是为了避免一些不必要的修改，那么对于我们的成员变量<code>outputTimes_</code>来说，它恰好是需要被修改的，符合我们所要实现的场景，因此呢为了实现对被<code>const</code>修饰的成员函数的修改，我们可以对要修改的成员变量加上关键字<code>mutable</code>，修改以后的代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">outputTimes_</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Output</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x=&quot;</span> &lt;&lt; x_ &lt;&lt; endl;<br>        ++outputTimes_;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetOutputTimes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> outputTimes_;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> outputTimes_; <span class="hljs-comment">//或者 int mutable outputTimes_; 均可</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    obj.<span class="hljs-built_in">Output</span>();<br>    obj.<span class="hljs-built_in">Output</span>();<br>    cout &lt;&lt; obj.<span class="hljs-built_in">GetOutputTimes</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>以上，则是<code>mutable</code>关键字试用的场景，用<code>mutable</code>修饰的数据成员即使在<code>const</code>对象或<code>const</code>成员函数中都可以被修改。<code>mutable</code>还可用于<code>Lambda</code>表达式，当传值接收的外部变量只读时，通过这样的关键字可以对只读外部变量进行修改。</p><table style="width:6%;"><thead><tr class="header"><th><strong>友元</strong>是一种允许非类成员函数访问类的非公有成员的一种机制。总的来说就是为了让非成员函数即普通函数或其他类可以访问类的私有成员，这确实破坏了类的封装性和数据的隐蔽性，但为什么要这么做呢？<code>C++ Primer</code>中说到：尽管友元授予外部函数、成员函数或其他类从外部访问某类内私有部分的权限，但它并不与面向对象的编程思想相悖，相反，友元的出现提高了公有接口的灵活性。我们知道，任何函数或者成员函数或者类想成为某个类的友元，这都是由这个类自己来决定的，而不能从外部强加友元。</th></tr></thead><tbody><tr class="odd"><td>### 重载相关重载时，如果要对两个有实部（<code>real_</code>）和虚部（<code>imag_</code>）的数进行加法运算的重载，那么有两种重载方式，第一种是类成员函数重载，第二种则是以友元函数的方式重载；对于成员函数重载，加法操作的第一个数是类对象本身，因此参数传递的时候会隐藏其本身。对于友元函数，其不属于任何类，因此在进行友元函数重载加法运算时，需要传递两个参数，如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*成员函数重载*/</span><br>Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;other) &#123;<br>    <span class="hljs-type">int</span> r = real_ + other.real_;<br>    <span class="hljs-type">int</span> i = imag_ + other.imag_;<br>    <span class="hljs-comment">//使用构造函数构造一个新对象 并返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(r, i);<br>&#125;<br><br><span class="hljs-comment">/*友元函数重载*/</span><br><span class="hljs-comment">//在类中声明时 需加上friend关键字</span><br><span class="hljs-comment">//friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2);</span><br>Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;c1, <span class="hljs-type">const</span> Complex &amp;c2) &#123;<br>    <span class="hljs-type">int</span> r = c1.real_ + c2.real_;<br>    <span class="hljs-type">int</span> i = c1.imag_ + c2.imag_;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(r, i);<br>&#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>在我的<code>CentOS</code>下，<code>GCC 8.4.1</code>版本下编译，成员函数重载和友元函数重载是可以共存的，并且当我们调用加法运算时，会优先调用成员函数重载。但是对于前置<code>++</code>运算符的重载，成员函数重载与友元函数重载不能共存，两者共存时会编译出错。</td></tr><tr class="odd"><td>这些运算符不能重载：<code>作用域解析运算符::</code>、<code>条件运算符?:</code>、<code>直接成员访问运算符.</code>、<code>类成员指针引用的运算符.*</code>、<code>sizeof运算符sizeof</code>、<code>new运算符</code>、<code>delete运算符</code>。</td></tr><tr class="even"><td><strong>一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。</strong>这些双目运算符<strong>不能重载为类的友元函数</strong>：<code>=</code>、<code>()</code>、<code>[]</code>、<code>-&gt;</code>，类型转换运算符<strong>只能以成员函数方式重载</strong>，流运算符<code>&lt;&lt;</code>、<code>&gt;&gt;</code>等<strong>只能以友元的方式重载</strong>。</td></tr></tbody></table><h4id="运算符重载成员函数方式友元函数方式重载推荐使用成员函数方式重载"><code>++</code>运算符重载（成员函数方式、友元函数方式重载，推荐使用成员函数方式重载）</h4><ul><li>前置<code>++</code>运算符重载<ul><li>成员函数方式重载：<code>函数类型 &amp;operator++();</code></li><li>友元函数方式重载：<code>friend 函数类型 &amp;operator++(类类型 &amp;);</code></li></ul></li><li>后置自增或后置自减的重载<ul><li>成员函数方式重载：<code>函数类型 &amp;operator++(int);</code></li><li>友元函数方式重载：<code>friend 函数类型 &amp;operator++(类类型 &amp;, int);</code></li></ul></li></ul><p>前置<code>++</code>的成员函数和友元函数较容易实现，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//前置++的重载</span><br><span class="hljs-comment">//因为返回的是引用 所以不会调用拷贝构造函数</span><br><span class="hljs-comment">//如果返回的是对象 则调用拷贝构造函数</span><br>Integer &amp;Integer::<span class="hljs-keyword">operator</span>++() &#123; <span class="hljs-comment">//成员函数</span><br>    ++n_;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">//类中声明时 需加friend关键字</span><br>Integer &amp;<span class="hljs-keyword">operator</span>++(Integer &amp;i) &#123; <span class="hljs-comment">//友元函数</span><br>    ++i.n_;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>对于后置<code>++</code>的成员函数，如果按照和前置<code>++</code>的成员函数相同的实现方式，会出现问题，比如对于<code>obj2 = obj1++</code>这样的语句，在赋值时<code>obj2</code>应该得到的是<code>++</code>前的结果，但是如果按照和前置<code>++</code>成员函数相同的实现方法，得到的<code>obj1</code>和<code>obj2</code>均为<code>++</code>后的结果，因此需要对其进行改进，<strong>创建临时变量，并返回其值而非引用，因为临时变量在函数外时生命周期就会结束</strong>，具体实现代码如下，包含成员函数的后置<code>++</code>重载和友元函数的后置<code>++</code>重载：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//后置++的重载</span><br><span class="hljs-comment">//成员函数的重载（与直接返回*this不同，返回的是临时变量，这点需注意区分，同时返回的不是引用）</span><br>Integer Integer::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> i) &#123;<br>    <span class="hljs-function">Integer <span class="hljs-title">tmp</span><span class="hljs-params">(n_)</span></span>;<br>    n_++;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br>Integer <span class="hljs-keyword">operator</span>++(Integer &amp;i, <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-function">Integer <span class="hljs-title">tmp</span><span class="hljs-params">(i.n_)</span></span>;<br>    i.n_++;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure>对于<code>++</code>和<code>--</code>运算符，推荐使用成员函数的方式进行重载，看起来会更加直观些。</p><p>--</p><h4id="运算符重载成员函数方式重载"><code>=</code>运算符重载（成员函数方式重载）</h4><p>假设现在我要实现一个<code>String</code>类的<code>=</code>运算符重载，需注意实现两个构造函数，一个是接收字符串并创建对象的类型转换构造函数，另一个是为了接收另一对象而实现的拷贝构造函数，以上两个构造函数都需另外创建空间，而非对传过来的地址进行引用或指向（也就是我们所说的深拷贝）。那么接下来就是<code>=</code>运算符重载操作，首先<code>=</code>重载不能作为友元函数重载，其次<code>=</code>右侧可以是对象也可以是字符串，因此<code>=</code>运算符重载有两种实现，那么对于<code>String</code>类关于<code>=</code>运算符的重载实现的代码，我直接展示出来，分别是<code>String.h</code>和<code>String.cpp</code>，后续还会补充<code>[]</code>、<code>+</code>、<code>+=</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>等运算符在<code>String</code>类中的重载实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*String.h*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _STRING_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _STRING_H_</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//前面加explicit后 初始化String str = &quot;xxx&quot;就得改为String str(&quot;xxx&quot;);</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;other);<br>    String &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;other);<br>    String &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str);<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!() <span class="hljs-type">const</span>;<br>    ~<span class="hljs-built_in">String</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">AllocAndCpy</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span></span>;<br>    <span class="hljs-type">char</span> *str_;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*String.cpp*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;String.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//类型转换构造函数</span><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str) &#123; str_ = <span class="hljs-built_in">AllocAndCpy</span>(str); &#125;  <br><br><span class="hljs-comment">//拷贝构造函数</span><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;other) &#123;<br>    str_ = <span class="hljs-built_in">AllocAndCpy</span>(other.str_);<br>&#125;<br><br><span class="hljs-comment">//=运算符重载 将other传进来 如果this != &amp;other 那么如果要拷贝 得创建新的空间 让str_指向这个空间</span><br>String &amp;String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;other) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;other)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-keyword">delete</span> []str_;<br>    str_ = <span class="hljs-built_in">AllocAndCpy</span>(other.str_);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//=运算符重载 传入字符串 并申请新空间拷贝字符串字面值 让str_指向这个新创建的空间</span><br>String &amp;String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str) &#123;<br>    <span class="hljs-keyword">delete</span> []str_;<br>    str_ = <span class="hljs-built_in">AllocAndCpy</span>(str);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//!运算符重载</span><br><span class="hljs-type">bool</span> String::<span class="hljs-keyword">operator</span>!() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strlen</span>(str_) == <span class="hljs-number">0</span>); &#125;<br><br><span class="hljs-comment">//析构函数释放str_指向的空间</span><br>String::~<span class="hljs-built_in">String</span>() &#123; <span class="hljs-keyword">delete</span> []str_; &#125;<br><br><span class="hljs-comment">//将str指向的字符串拷贝到类对象的成员变量str_中 深拷贝操作</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">String::AllocAndCpy</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">char</span> *newstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len];<br>    <span class="hljs-built_in">memset</span>(newstr, <span class="hljs-number">0</span>, len);<br>    <span class="hljs-built_in">strcpy</span>(newstr, str);<br><br>    <span class="hljs-keyword">return</span> newstr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::Display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; str_ &lt;&lt; endl; &#125;<br></code></pre></td></tr></table></figure><p>我们发现<code>=</code>运算符重载两个重载函数是有相互重复的部分的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">delete</span> []str_;<br>str_ = <span class="hljs-built_in">AllocAndCpy</span>(other.str_);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br></code></pre></td></tr></table></figure>因此，我们可以对<code>=</code>运算符重载再进一步优化，在<code>private</code>中声明新函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">String &amp;<span class="hljs-title">Assign</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span></span>;<br></code></pre></td></tr></table></figure> 代码实现如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">String &amp;<span class="hljs-title">String::Assign</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span> []str_;<br>    str_ = <span class="hljs-built_in">AllocAndCpy</span>(str);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>接下来，对<code>=</code>运算符进行化简，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String &amp;String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;other) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Assign</span>(other.str_);<br>&#125;<br><br>String &amp;String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Assign</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure></p><table style="width:4%;"><thead><tr class="header"><th>#### <code>[]</code>运算符重载（成员函数方式重载）此时要为<code>String</code>类实现一个<code>[]</code>运算符重载，需要注意两点：1. 通过<code>[]</code>来获取字符串对应位置或对对应位置进行修改。 2.对<code>const</code>类型的字符串，要避免对其的修改。</th></tr></thead><tbody><tr class="odd"><td>#### <code>+</code>运算符重载（友元函数方式重载）一般情况下，<strong>单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数</strong>，这里我们采用友元的方式对<code>+</code>运算符进行重载。其实采用友元函数还有一个原因，比如对于下述测试代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String s1 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;aaa&quot;</span> + s1; <span class="hljs-comment">//成员函数方式重载 无法实现当前语句</span><br></code></pre></td></tr></table></figure><strong>如果采用成员函数的方式，对于第二行<code>+</code>运算，第一个应该是对象而非字符串，因此对于以上操作，成员函数的方式进行<code>+</code>重载是不可行的，这就是为什么我们要将<code>+</code>通过友元的方式进行重载的原因了。</strong>同时如果采用下述的成员函数重载去实现，我们可以对其进行连<code>+</code>操作，如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String s1 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;aaa&quot;</span> + s1 + <span class="hljs-string">&quot;xxx&quot;</span> + ....;<br></code></pre></td></tr></table></figure>但是需要注意前两个加法必须有一个是对象，如果前两个均不为对象，我们还需要对两个<code>char *</code>参数的<code>+</code>运算符进行重载，形如<code>String operator+(char *s1, char *s2);</code>。</td></tr><tr class="even"><td>那么我们开始实现<code>+</code>运算符重载。首先，用友元函数重载的方式实现一个简易版的<code>String</code>类的<code>+</code>运算符，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//String类中声明需加上friend关键字</span><br><span class="hljs-comment">//friend String operator+(const String &amp;s1, const String &amp;s2);</span><br>String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String &amp;s1, <span class="hljs-type">const</span> String &amp;s2) &#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s1.str_) + <span class="hljs-built_in">strlen</span>(s2.str_) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len];<br>    <span class="hljs-built_in">strcpy</span>(str, s1.str_);<br>    <span class="hljs-built_in">strcat</span>(str, s2.str_);<br><br>    <span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(str)</span></span>;<br>    <span class="hljs-keyword">delete</span> []str;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure> &gt; 补充：这里之所以加上9、10行代码，而非直接returnString(str);目的是防止多次+重载调用导致str指针多次申请内存产生内存泄漏。若提前将申请的空间释放，构造出一个对象，那么会利用RAII机制使得对象析构时自动释放内存，避免出现内存泄漏。</td></tr><tr class="odd"><td>在实现<code>+</code>运算符重载的时候我遇到了一个问题，当我执行下述代码进行测试时：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String s1 = <span class="hljs-string">&quot;xxx&quot;</span>;   <span class="hljs-comment">//采用类型转换构造函数</span><br>String s2 = <span class="hljs-string">&quot;yyy&quot;</span>;   <span class="hljs-comment">//采用类型转换构造函数</span><br>String s3 = s1 + s2; <span class="hljs-comment">//先调用友元的+重载 再调用类型转换构造函数，原因是在实现+重载时 tmp通过拷贝构造进行初始化</span><br></code></pre></td></tr></table></figure><strong>疑问：第三行的初始化操作首先对<code>=</code>右侧的友元函数的<code>+</code>运算符重载进行了调用，返回一个<code>String</code>类对象，按理说由于这个对象内存会在<code>operator+</code>重载函数结束前被释放掉，因此会有一个临时对象被创建用于接收这个返回的<code>String</code>类对象，因此应该是会调用拷贝构造函数的，然后这个临时对象会被<code>String</code>类对象<code>s3</code>直接接收，但是此处代码却没有用返回值拷贝构造出一个临时对象，这一点让我很困惑和不解（我的猜测是，或许和编译器的优化又关系）</strong>，因为之前对于以下代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>():<span class="hljs-built_in">num_</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>:num_(num)&#123;</span>&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A &amp;other):<span class="hljs-built_in">num_</span>(other.num_)&#123;&#125;<br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A &amp;other)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;other) <span class="hljs-keyword">this</span>-&gt;num_ = other.num_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp;obj)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    A obj2 = <span class="hljs-built_in">func</span>(obj); <span class="hljs-comment">//调用拷贝构造函数创建临时对象 临时对象直接转正为obj2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><code>A obj2 = func(obj);</code>这条语句中，<code>func</code>返回的形参<code>obj</code>是要被销毁的，所以形参<code>obj</code>会在函数结束前先通过拷贝构造函数拷贝至一个新创建的临时对象中，然后因为这条语句是初始化语句，就不去执行<code>=</code>运算符重载，而是直接将临时对象转正为所谓的<code>obj2</code>对象，但是对于上面提到的疑问，就出现了冲突，这让我一直无法理解。</td></tr><tr class="even"><td>关于类型转换构造函数和拷贝构造函数的实现，我贴在下面：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//类型转换构造函数</span><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str) &#123; str_ = <span class="hljs-built_in">AllocAndCpy</span>(str); &#125;  <br><br><span class="hljs-comment">//拷贝构造函数</span><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;other) &#123; str_ = <span class="hljs-built_in">AllocAndCpy</span>(other.str_); &#125;<br><br><span class="hljs-comment">//将str指向的字符串拷贝到类对象的成员变量str_中</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">String::AllocAndCpy</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> *newstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len];<br>    <span class="hljs-built_in">memset</span>(newstr, <span class="hljs-number">0</span>, len);<br>    <span class="hljs-built_in">strcpy</span>(newstr, str);<br>    <span class="hljs-keyword">return</span> newstr;<br>&#125;<br></code></pre></td></tr></table></figure></td></tr></tbody></table><h4id="运算符重载成员函数方式重载-1"><code>+=</code>运算符重载（成员函数方式重载）</h4><p>因为<code>+=</code>以后的结果要作为对象返回，因此最好使用成员函数的方式进行重载，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String &amp;String::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> String &amp;other) &#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str_) + <span class="hljs-built_in">strlen</span>(other.str_) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> *newstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len];<br>    <span class="hljs-built_in">memset</span>(newstr, <span class="hljs-number">0</span>, len);<br>    <span class="hljs-built_in">strcpy</span>(newstr, str_);<br>    <span class="hljs-built_in">strcat</span>(newstr, other.str_);<br>    <span class="hljs-keyword">delete</span> []str_;<br><br>    str_ = newstr;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>实现完<code>+=</code>运算符重载以后，就可以优化<code>+</code>运算符重载了，优化后的代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String &amp;s1, <span class="hljs-type">const</span> String &amp;s2) &#123;<br>    String str = s1;<br>    str += s2; <span class="hljs-comment">//直接调用+=运算符重载</span><br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure></p><table style="width:4%;"><thead><tr class="header"><th>#### 流运算符重载（只能友元函数方式重载）友元输入流需要注意，我们要对类进行更改，因此传入参数需要是非<code>const</code>的类型，<code>String</code>类中流的实现代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//类中声明要加friend关键字</span><br><span class="hljs-comment">//friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const String &amp;str);</span><br><span class="hljs-comment">//friend istream &amp;operator&gt;&gt;(istream &amp;is, String &amp;str);</span><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> String &amp;str) &#123;<br>    os &lt;&lt; str.str_; <span class="hljs-comment">//&lt;&lt;已经将char *重载好了 所以直接把char *写入os流</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br>istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, String &amp;str) &#123;<br>    <span class="hljs-type">char</span> tmp[<span class="hljs-number">1024</span>];<br>    is &gt;&gt; tmp;<br>    str = tmp;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure></th></tr></thead><tbody><tr class="odd"><td>#### 类型转换运算符（只能成员函数方式重载）比如对一个整型类，现在如果将一个数<code>200</code>赋值给整型类，如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Integer <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>n = <span class="hljs-number">200</span>;<br></code></pre></td></tr></table></figure>通过类型转换构造函数将字面值<code>200</code>转换为构造函数，调用<code>=</code>运算符重载即可。那如果对于下面的操作，<code>add</code>函数的两个参数为整型，当我们传入对象时，需要将对象转为整型，那这个时候就需要对类型转换运算符进行重载：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>...<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Integer <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-built_in">add</span>(n, <span class="hljs-number">200</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 类型转换重载形式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">operator</span> 类型名() <span class="hljs-comment">//无返回值</span><br></code></pre></td></tr></table></figure>那对于我们自定义的整型类，其实现为： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*Integer.h*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _INTEGER_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _INTEGER_H_</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Integer</span>(<span class="hljs-type">int</span>);<br>    ~<span class="hljs-built_in">Integer</span>();<br>    Integer &amp;<span class="hljs-keyword">operator</span>++();<br>    <span class="hljs-comment">// friend Integer &amp;operator++(Integer &amp;);</span><br>    Integer <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>);<br>    <span class="hljs-comment">// friend Integer operator++(Integer &amp;, int);</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//类型转换重载</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n_;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure> 函数具体实现为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*Integer.cpp*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Integer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>Integer::<span class="hljs-built_in">Integer</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n_</span>(n) &#123;&#125;<br>Integer::~<span class="hljs-built_in">Integer</span>() &#123;&#125;<br><br><span class="hljs-comment">//前置++的重载</span><br><span class="hljs-comment">//因为返回的是引用 所以不会调用拷贝构造函数 如果返回的是对象 则调用拷贝构造函数</span><br>Integer &amp;Integer::<span class="hljs-keyword">operator</span>++() &#123; ++n_; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br><span class="hljs-comment">// Integer &amp;operator++(Integer &amp;i) &#123;</span><br><span class="hljs-comment">//     ++i.n_;</span><br><span class="hljs-comment">//     return i;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">//后置++的重载</span><br>Integer Integer::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-function">Integer <span class="hljs-title">tmp</span><span class="hljs-params">(n_)</span></span>;<br>    n_++;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-comment">// Integer operator++(Integer &amp;i, int) &#123;</span><br><span class="hljs-comment">//     Integer tmp(i.n_);</span><br><span class="hljs-comment">//     i.n_++;</span><br><span class="hljs-comment">//     return tmp;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">//类型转换重载</span><br><span class="hljs-function">Integer::<span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> n_; &#125; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Integer::Display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; n_ &lt;&lt; endl; &#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>如果要将整型对象转为<code>int</code>类型，那么可以隐式转换，调用类型转换重载，然后赋值给<code>int</code>类型，如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = n; <span class="hljs-comment">//n为Integer类对象 n会调用类型转换重载，取类私有成员n_ 返回赋值给x</span><br></code></pre></td></tr></table></figure> 也可使用显式的方式进行转换： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(n); <span class="hljs-comment">//n会调用类型转换重载</span><br></code></pre></td></tr></table></figure></td></tr></tbody></table><h4id="指针运算符成员函数方式重载"><code>-&gt;</code>指针运算符（成员函数方式重载）</h4><p>比如对于以下场景，使用<code>DB</code>类去包装<code>DBHelper</code>类指针，通过指针运算符重载来让一个类调用另一个类成员函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBHelper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DBHelper</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;DBHelper()..&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">DBHelper</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~DBHelper()..&quot;</span> &lt;&lt; endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Open</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Open...&quot;</span> &lt;&lt; endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Close...&quot;</span> &lt;&lt; endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Query</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Query...&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DB</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DB</span> () &#123;db_ = <span class="hljs-keyword">new</span> DBHelper;&#125;<br>    ~<span class="hljs-built_in">DB</span> () &#123;<span class="hljs-keyword">delete</span> db_;&#125;<br>    DBHelper *<span class="hljs-keyword">operator</span>-&gt;() &#123;<span class="hljs-keyword">return</span> db_;&#125;<br><span class="hljs-keyword">private</span>:<br>    DBHelper *db_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    DB db;<br>    <span class="hljs-comment">//重载-&gt;运算符</span><br>    db-&gt;<span class="hljs-built_in">Open</span>(); <span class="hljs-comment">//db是一个对象 但是-&gt;重载返回对象的指针DBHelper *db_ 用于调用其所指向的函数</span><br>    db-&gt;<span class="hljs-built_in">Query</span>();<br>    db-&gt;<span class="hljs-built_in">Close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>上述方式使得我们对内存的控制更加方便，因为<code>DB</code>类对象创建的时候，构造函数会自动帮我们申请空间，但<code>DB</code>销毁的时候析构函数也会自动帮我们释放空间，然后通过<code>db_</code>指针来调用另一个类的成员，这实际上也是智能指针实现的一个技巧，<code>DB</code>就相当于时一个智能指针，其内部包装了一个指针，巧妙使用智能指针可避免内存泄漏。</p><p>所以当我们看到一个对象而非一个指针去使用指针运算符的时候，我们不应该感到惊讶，其内部正是因为对<code>-&gt;</code>指针运算符进行了重载（<code>overload</code>），使得一个对象最终<code>overload</code>为一个指针。</p><table style="width:7%;"><thead><tr class="header"><th>#### <code>new/delete</code>内存分配运算符</th></tr></thead><tbody><tr class="odd"><td><code>string</code>类型实际上是一个模版类，其模版类的函数在参考手册中搜索<code>std::basic_string</code>既可找到，具体在<code>stringfwd.h</code>中定义如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">_GLIBCXX_BEGIN_NAMESPACE_CXX11<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _CharT, <span class="hljs-keyword">typename</span> _Traits = char_traits&lt;_CharT&gt;,<br>           <span class="hljs-keyword">typename</span> _Alloc = allocator&lt;_CharT&gt; &gt;<br>    <span class="hljs-keyword">class</span> basic_string;<br><br>  <span class="hljs-comment">/// A string of @c char</span><br>  <span class="hljs-keyword">typedef</span> basic_string&lt;<span class="hljs-type">char</span>&gt;    string;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _GLIBCXX_USE_WCHAR_T</span><br>  <span class="hljs-comment">/// A string of @c wchar_t</span><br>  <span class="hljs-keyword">typedef</span> basic_string&lt;<span class="hljs-type">wchar_t</span>&gt; wstring;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>可以看到<code>basic_string</code>由三个参数<code>_CharT</code>（<code>char</code>）、<code>char_traits&lt;char&gt;</code>、<code>allocator&lt;char&gt;</code>组成，而且后面两个参数均有默认值，<code>string</code>则是<code>basic_string</code>的<code>typedef</code>，因此我们在定义一个<code>string</code>类对象时，只需要在<code>&lt;&gt;</code>中传入第一个参数<code>char</code>既可，具体定义方法如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">basic_string&lt;<span class="hljs-type">char</span>&gt; s;            <span class="hljs-comment">//等价于string s; 但是这样写更装逼</span><br><span class="hljs-function">basic_string&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">s1</span><span class="hljs-params">(s)</span></span>;        <span class="hljs-comment">//string s1(s);</span><br>basic_string&lt;<span class="hljs-type">char</span>&gt; s2 = <span class="hljs-string">&quot;abcd&quot;</span>;  <span class="hljs-comment">//string s2 = &quot;abcd&quot;;</span><br><span class="hljs-function">basic_string&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;   <span class="hljs-comment">//string s3(&quot;abcd&quot;);</span><br><span class="hljs-function">basic_string&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-number">2</span>)</span></span>;<span class="hljs-comment">//string s4(&quot;abcd&quot;, 2); 得到的是&quot;ab&quot;字符串</span><br><span class="hljs-function">basic_string&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">s5</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;   <span class="hljs-comment">//s5=&quot;ccc&quot; 即三个&#x27;c&#x27;</span><br><span class="hljs-function">basic_string&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">s6</span><span class="hljs-params">(s3, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">//s6=&quot;abc&quot; 即从s3的第0位开始后3个字符</span><br></code></pre></td></tr></table></figure>那么查阅参考文档后，上述调用的具体<strong>构造函数定义</strong>如下，<code>Allocator()</code>为内存分配器：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::basic_string&lt;CharT,Traits,Allocator&gt;::basic_string<br><br><span class="hljs-comment">//C++20前 和 C++20起</span><br><span class="hljs-comment">//拷贝构造函数 构造拥有other内容副本的string</span><br><span class="hljs-built_in">basic_string</span>( <span class="hljs-type">const</span> basic_string&amp; other, <span class="hljs-type">const</span> Allocator&amp; alloc ); <span class="hljs-comment">//s1</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">basic_string</span><span class="hljs-params">( <span class="hljs-type">const</span> basic_string&amp; other, <span class="hljs-type">const</span> Allocator&amp; alloc )</span></span>;<br><br><br><span class="hljs-comment">//C++20前 和 C++20起</span><br><span class="hljs-built_in">basic_string</span>( <span class="hljs-type">const</span> CharT* s,<br>              <span class="hljs-type">const</span> Allocator&amp; alloc = <span class="hljs-built_in">Allocator</span>() ); <span class="hljs-comment">//s2 s3</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">basic_string</span><span class="hljs-params">( <span class="hljs-type">const</span> CharT* s,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;<br><br><br><span class="hljs-comment">//C++20前 和 C++20起</span><br><span class="hljs-comment">//以s所指向的字符串的首count个字符构造string</span><br><span class="hljs-comment">//s能包含空字符 string的长度为count 若[s, s + count)不是合法范围则行为未定义</span><br><span class="hljs-built_in">basic_string</span>( <span class="hljs-type">const</span> CharT* s,<br>              size_type count,<br>              <span class="hljs-type">const</span> Allocator&amp; alloc = <span class="hljs-built_in">Allocator</span>() ); <span class="hljs-comment">//s4</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">basic_string</span><span class="hljs-params">( <span class="hljs-type">const</span> CharT* s,</span></span><br><span class="hljs-params"><span class="hljs-function">                        size_type count,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;<br><br><span class="hljs-comment">//C++20前 和 C++20起</span><br><span class="hljs-comment">//构造拥有字符ch的count个副本的string</span><br><span class="hljs-built_in">basic_string</span>( size_type count,<br>              CharT ch,<br>              <span class="hljs-type">const</span> Allocator&amp; alloc = <span class="hljs-built_in">Allocator</span>() ); <span class="hljs-comment">//s5</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">basic_string</span><span class="hljs-params">( size_type count,</span></span><br><span class="hljs-params"><span class="hljs-function">                        CharT ch,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;<br><br><span class="hljs-comment">//C++17起C++20前 和 C++20起</span><br><span class="hljs-comment">//以other的子串[pos, pos+count)构造string</span><br><span class="hljs-comment">//若count==npos或未指定count或若请求的子串越过字符串的结尾 则产生的子串为[pos, other.size())</span><br><span class="hljs-built_in">basic_string</span>( <span class="hljs-type">const</span> basic_string&amp; other,<br>              size_type pos,<br>              size_type count,<br>              <span class="hljs-type">const</span> Allocator&amp; alloc = <span class="hljs-built_in">Allocator</span>() ); <span class="hljs-comment">//s6</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">basic_string</span><span class="hljs-params">( <span class="hljs-type">const</span> basic_string&amp; other,</span></span><br><span class="hljs-params"><span class="hljs-function">                        size_type pos,</span></span><br><span class="hljs-params"><span class="hljs-function">                        size_type count,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;<br><br><span class="hljs-comment">//C++20前 和 C++20起             </span><br><span class="hljs-comment">//通过迭代器 构造拥有范围[first, last)内容的string</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt &gt;</span><br><span class="hljs-function"><span class="hljs-title">basic_string</span><span class="hljs-params">( InputIt first, InputIt last,</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt &gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">basic_string</span><span class="hljs-params">( InputIt first, InputIt last,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td><code>string</code>类的成员函数： <imgsrc="media/16224350022491/16313669872393.jpg" alt="-w1218" /></td></tr><tr class="odd"><td>除了以上成员函数，还有<code>c_str()</code>成员函数，定义如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//C++11前</span><br><span class="hljs-function"><span class="hljs-type">const</span> CharT* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">//C++11起到C++20前</span><br><span class="hljs-function"><span class="hljs-type">const</span> CharT* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-comment">//C++20起</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> CharT* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure>即<code>string</code>模板类对象调用<code>c_str()</code>，返回一个<code>const char*</code>类型的字符串，如果要让一个<code>char *</code>指针去接收，就要去掉<code>const</code>属性，可以使用<code>const_cast&lt;char *&gt;(s.c_str())；</code>对<code>string</code>类对象转化为字符串并去除其<code>const</code>属性。</td></tr><tr class="even"><td><code>str1.find_first_of(str2)</code>，找<code>str1</code>内第一个存在于<code>str2</code>中的元素位置，返回<code>size_type</code>类型的位置下标。<code>str1.find_last_of(str2)</code>，找<code>str1</code>内最后一个存在于<code>str2</code>中的元素位置，返回<code>size_type</code>类型的位置下标。<code>str1.find_first_not_of(str2)</code>，找<code>str1</code>内第一个不存在<code>str2</code>中的元素位置，返回<code>size_type</code>类型的位置下标。<code>str1.find_last_not_of(str2)</code>，找<code>str1</code>内最后一个不存在<code>str2</code>中的元素位置，返回<code>size_type</code>类型的位置下标。</td></tr><tr class="odd"><td>场景：现如今要对一个字符串<code>basic_string&lt;char&gt; s = "  dwaf e!fae    "</code>去除其左、右空格，该如何实现？<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">basic_string&lt;<span class="hljs-type">char</span>&gt; drop = <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//空格字符</span><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">find_first_not_of</span>(drop)); <span class="hljs-comment">//去除左空格</span><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">find_last_not_of</span>(drop)+<span class="hljs-number">1</span>, string::npos); <span class="hljs-comment">//去除右空格</span><br><span class="hljs-comment">//等价于s.erase(find_last_not_of(drop)+1);</span><br><br><span class="hljs-comment">//也可省略第二个参数 因为erase定义如下：</span><br><span class="hljs-function">basic_string&amp; <span class="hljs-title">erase</span><span class="hljs-params">( size_type index = <span class="hljs-number">0</span>, size_type count = npos )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> basic_string&amp; <span class="hljs-title">erase</span><span class="hljs-params">( size_type index = <span class="hljs-number">0</span>, size_type count = npos )</span></span>;<br></code></pre></td></tr></table></figure></td></tr></tbody></table><p><code>vector</code>的部分构造函数如下（还有迭代器方式的初始化操作等，具体详见<code>cppreference</code>参考手册）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//默认构造</span><br><span class="hljs-built_in">vector</span>(); <span class="hljs-comment">//C++17以前</span><br><span class="hljs-built_in">vector</span>() <span class="hljs-built_in">noexcept</span>(<span class="hljs-built_in">noexcept</span>(<span class="hljs-built_in">Allocator</span>())); <span class="hljs-comment">//C++17起到C++20以前</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">vector</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(Allocator()))</span></span>; <span class="hljs-comment">//C++20起</span><br><br><span class="hljs-comment">//拷贝构造</span><br><span class="hljs-built_in">vector</span>( <span class="hljs-type">const</span> vector&amp; other ); <span class="hljs-comment">//C++20前</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">vector</span><span class="hljs-params">( <span class="hljs-type">const</span> vector&amp; other )</span></span>; <span class="hljs-comment">//C++20起</span><br><span class="hljs-built_in">vector</span>( <span class="hljs-type">const</span> vector&amp; other, <span class="hljs-type">const</span> Allocator&amp; alloc ); <span class="hljs-comment">//C++11起到C++20前</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">vector</span><span class="hljs-params">( <span class="hljs-type">const</span> vector&amp; other, <span class="hljs-type">const</span> Allocator&amp; alloc )</span></span>; <span class="hljs-comment">//C++20起</span><br><br><span class="hljs-comment">//构造count个value</span><br><span class="hljs-built_in">vector</span>( size_type count,<br>        <span class="hljs-type">const</span> T&amp; value,<br>        <span class="hljs-type">const</span> Allocator&amp; alloc = <span class="hljs-built_in">Allocator</span>()); <span class="hljs-comment">//C++11起到C++20前</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">vector</span><span class="hljs-params">( size_type count,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">const</span> T&amp; value,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">const</span> Allocator&amp; alloc = Allocator())</span></span>; <span class="hljs-comment">//C++20起</span><br><br><span class="hljs-comment">//构造count个默认元素(0)</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">vector</span><span class="hljs-params">( size_type count )</span></span>; <span class="hljs-comment">//C++11起到C++14前</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">vector</span><span class="hljs-params">( size_type count,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> Allocator&amp; alloc = Allocator() )</span></span>; <span class="hljs-comment">//C++14起到C++20前</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">explicit</span> <span class="hljs-title">vector</span><span class="hljs-params">( size_type count,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">const</span> Allocator&amp; alloc = Allocator() )</span></span>; <span class="hljs-comment">//C++20起</span><br></code></pre></td></tr></table></figure></p><p><code>vector</code>成员函数如下： <imgsrc="media/16224350022491/16314132478714.jpg" alt="-w1021" /></p><table style="width:8%;"><tbody><tr class="odd"><td><code>map</code>是关联式容器，基于<code>key</code>、<code>value</code>存储，内部采用红黑树，插入到<code>map</code>的元素默认是按照<code>key</code>从小到大进行排序的。</td></tr><tr class="even"><td><code>map</code>插入元素的常规操作是像数组一样给<code>key</code>、<code>value</code>赋值即可，需要特别注意也可进行如下操作：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;string, <span class="hljs-type">int</span>&gt; m;<br>m[<span class="hljs-string">&quot;aaa&quot;</span>] = <span class="hljs-number">100</span>;<br>m.<span class="hljs-built_in">insert</span>(map&lt;string, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-string">&quot;hhh&quot;</span>, <span class="hljs-number">200</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-number">300</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">400</span>));<br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td>其实，在<code>map</code>的源码中，<code>value_type</code>是这样定义的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Key, <span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Compare = std::less&lt;_Key&gt;,<br>   <span class="hljs-keyword">typename</span> _Alloc = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> _Key, _Tp&gt; &gt; &gt;<br>  <span class="hljs-keyword">class</span> map<br>  &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> _Keykey_type;<br>    <span class="hljs-keyword">typedef</span> _Tpmapped_type;<br>    <span class="hljs-keyword">typedef</span> std::pair&lt;<span class="hljs-type">const</span> _Key, _Tp&gt;value_type; <span class="hljs-comment">//可以看到value_type就是pair</span><br>      ...<br></code></pre></td></tr></table></figure>可以发现，<code>value_type</code>类型实际上就是一个<code>pair</code>键值对的<code>typedef</code>，那么我们可以使用<code>make_pair</code>模板函数传入<code>key</code>和<code>value</code>，构成一个<code>pair</code>键值对来传入到<code>map</code>当中，也可直接传入一个<code>pair&lt;key, value&gt;()</code>键值对。但是如果要更新相同<code>key</code>所对应的<code>value</code>值，只能使用数组的方式更新，即<code>m[key]=changed_value</code>。</td></tr><tr class="even"><td><code>map</code>可通过传统迭代器方式遍历，<code>C++11</code>以后可通过<code>auto</code>关键字遍历，遍历方式如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(map&lt;string, <span class="hljs-type">int</span>&gt;::const_iterator it=m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); ++it)<br>    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:m)<br>    cout &lt;&lt; x.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; x.second &lt;&lt; endl;<br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td>至于为什么用<code>const_iterator</code>，这又和<code>iterator</code>有何区别？详见：<ahref="https://www.cnblogs.com/greatverve/archive/2012/09/12/const-iterator.html">iterator与const_iterator及constiterator区别</a></td></tr><tr class="even"><td>模板类<code>map</code>查找操作的成员函数<code>find</code>如下，返回的是一个迭代器：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">( <span class="hljs-type">const</span> Key&amp; key )</span></span>;<br><span class="hljs-function">const_iterator <span class="hljs-title">find</span><span class="hljs-params">( <span class="hljs-type">const</span> Key&amp; key )</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> K &gt; iterator <span class="hljs-title">find</span><span class="hljs-params">( <span class="hljs-type">const</span> K&amp; x )</span></span>; <span class="hljs-comment">//C++14起</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> K &gt; const_iterator <span class="hljs-title">find</span><span class="hljs-params">( <span class="hljs-type">const</span> K&amp; x )</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//C++14起</span><br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td>模板类<code>map</code>的删除操作<code>erase</code>可以传入<code>key</code>，也可传入迭代器：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//移除位于pos的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">( iterator pos )</span></span>; <span class="hljs-comment">//C++11前</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">( const_iterator pos )</span></span>; <span class="hljs-comment">//C++11起</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">( iterator pos )</span></span>; <span class="hljs-comment">//C++17起</span><br><br><span class="hljs-comment">//移除范围[first; last)中的元素，它必须是*this中的合法范围</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">( iterator first, iterator last )</span></span>; <span class="hljs-comment">//C++11前</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">( const_iterator first, const_iterator last )</span></span>; <span class="hljs-comment">//C++11起</span><br><br><span class="hljs-comment">//移除关键等于key的元素（若存在一个）</span><br><span class="hljs-function">size_type <span class="hljs-title">erase</span><span class="hljs-params">( <span class="hljs-type">const</span> key_type&amp; key )</span></span>;<br></code></pre></td></tr></table></figure>只不过<code>erase</code>操作需要注意迭代器的<code>++</code>不应放在<code>for</code>的第三个参数部分，如果要擦除，迭代器作为<code>erase</code>的返回值，即擦出位置的下一个位置，如果不擦出，在循环体内进行迭代器的<code>++</code>操作。</td></tr></tbody></table><p>继承： <img src="media/16224350022491/16320381735517.jpg"alt="-w1324" /></p><h4 id="接口继承与实现继承">接口继承与实现继承</h4><ul><li>我们将类的<strong>公有成员函数</strong>称为<strong>接口</strong>。</li><li>公有继承，基类的公有成员函数在派生类中仍然是公有的，换句话说是基类的接口成为了派生类的接口，因而将它称为<strong>接口继承</strong>（公有继承，派生类对象及类内继续使用基类公有成员函数）。</li><li>对于私有、保护继承，派生类不继承基类的接口。派生类将不支持基类的公有接口，它希望能重用基类的实现而已，因而将它称为<strong>实现继承</strong>（私有、保护继承，派生类对象不能使用公有成员函数，而仅能类内使用其功能）。</li></ul><h4 id="继承与重定义">继承与重定义</h4><ul><li>对基类的数据成员的重定义</li><li>对基类成员函数的重定义分为两种<ul><li><code>overwrite</code><ul><li>与基类完全相同</li><li>与基类成员函数名相同，参数不同</li></ul></li><li><code>override</code></li></ul></li></ul><p>对于以上<code>overwrite</code>的第一种情况，当基类和派生类内均声明公有成员<code>x_</code>时，创建如果是派生类对象，访问并修改<code>x_</code>，改变的是派生类自己的<code>x_</code>，而非基类。第二种情况，当基类有不传参数的<code>void Show()</code>函数时，此时基类对应的派生类中定义了带一个参数的<code>void Show(int n)</code>，那么此时定义的派生类对象调用不带参数的<code>Show()</code>时，调用失败，报错：<code>error: no matching function...</code>，简单来说，带参数的<code>void Show(int n)</code>，将基类的<code>void Show()</code>覆盖掉了，我们不能够调用基类的<code>Show()</code>函数了，如果这时候在派生类中定义无参数的<code>void Show()</code>，派生类对象依然访问派生类的方法，那么该如何访问基类方法呢？在对象调用的成员函数前加上<code>BaseClass::</code>基类的作用域即可。</p><p><strong>重载</strong>：<code>overload重载</code>的前提是：作用域相同，即同一个类中。函数重载的四个条件：<strong>函数名相同，形参数量不同，形参类型不一样，形参顺序不一样</strong>，重载不关心函数返回值类型。重载中，<code>virtual</code>关键字可有可无。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">float</span> tmp)</span></span>;            <span class="hljs-comment">// 重载 参数类型不同（相对于上一个函数）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp, <span class="hljs-type">float</span> tmp1)</span></span>;  <span class="hljs-comment">// 重载 参数个数不同（相对于上一个函数）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">float</span> tmp, <span class="hljs-type">int</span> tmp1)</span></span>;  <span class="hljs-comment">// 重载 参数顺序不同（相对于上一个函数）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp)</span></span>;               <span class="hljs-comment">// error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>重定义/隐藏</strong>：<code>overwrite重定义</code>发生在基类和派生类之间，当函数名与参数相同并且无<code>virtual</code>关键字时构成重定义；当函数名相同，参数不同（<code>virtual</code>关键字可有可无）时，构成重定义，又称为隐藏，即派生类的函数屏蔽了与其同名的基类函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp, <span class="hljs-type">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun(int tmp)&quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">// 隐藏基类中的同名函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive ex;<br>    ex.<span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>);       <span class="hljs-comment">// Derive::fun(int tmp)</span><br>    ex.<span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.01</span>); <span class="hljs-comment">// error: candidate expects 1 argument, 2 provided</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：上述代码中 ex.fun(1, 0.01);出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明ex.Base::fun(1, 0.01);，这样就可以调用基类中的同名函数。</p><p><strong>重写</strong>：<code>override重写（覆盖）</code>发生在基类和派生类之间，是指派生类中存在的函数名、参数、返回值类型均必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有<code>virtual</code>修饰，发生<code>override</code>重写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 此处virtual可有可无 基类必须有</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125; <span class="hljs-comment">// 重写基类中的 fun 函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    p-&gt;<span class="hljs-built_in">fun</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// Derived::fun(int) : 3 // 发生多态</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重写和重载的区别：</strong> *范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。*参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有<code>virtual</code>修饰。*<code>virtual</code>关键字：重写的函数基类中必须有<code>virtual</code>关键字的修饰，重载的函数可以有<code>virtual</code>关键字的修饰也可以没有。</p><p><strong>隐藏和重写，重载的区别：</strong> *范围区别：隐藏与重载范围不同，隐藏发生在不同类中。 *参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被virtual 修饰，基类函数都是被隐藏，而不是重写。</p><p><ahref="https://www.cnblogs.com/nbk-zyc/p/12356271.html">[C++中函数重载、函数重定义、函数重写参考链接]</a></p><p>里氏代换原则<code>Liskov Substitution Principle</code><ahref="https://www.labri.fr/perso/clement/enseignements/ao/LSP.pdf">[paperlink]</a>，用于检验继承的质量。</p><h4 id="不能自动继承的成员函数">不能自动继承的成员函数</h4><ul><li>构造函数</li><li>析构函数</li><li><code>=</code>运算符</li></ul><p>基类的构造函数不能被继承，派生类中需要声明自己的构造函数，派生类在声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化需调用基类构造函数完成。派生类的构造函数需要给基类的构造函数传递参数，若不传参数则调用默认无参构造函数，若无无参构造则必须执行基类的某种构造函数。所以派生类对象创建时，仅能在初始化列表中先调用基类的构造函数，再去调用派生类的构造函数，与参数构造的书写顺序无关：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> b) : <span class="hljs-built_in">b_</span>(b) &#123;&#125;<br>    <span class="hljs-type">int</span> b_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> d) : <span class="hljs-built_in">d_</span>(d), <span class="hljs-built_in">Base</span>(<span class="hljs-number">10</span>) &#123;&#125; <span class="hljs-comment">//尽管d_写在前面，依然先调用基类构造</span><br>    <span class="hljs-type">int</span> d_;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>如果在<code>Derived</code>类中声明<code>ObjectD</code>类对象成员时，此时如果定义一个<code>Derived</code>类对象，其构造顺序将变为：先调用基类构造函数，再调用<code>Derived</code>的类对象成员<code>ObjectD</code>的构造函数，最后调用<code>Derived</code>类构造函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectD</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ObjectD</span>() &#123;&#125; <span class="hljs-comment">//第二步调用ObjectD类构造函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> b) : <span class="hljs-built_in">b_</span>(b) &#123;&#125; <span class="hljs-comment">//首先调用Base类构造函数</span><br>    <span class="hljs-type">int</span> b_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> d) : <span class="hljs-built_in">d_</span>(d), <span class="hljs-built_in">Base</span>(<span class="hljs-number">10</span>) &#123;&#125; <span class="hljs-comment">//最后调用Derived类构造函数</span><br>    <span class="hljs-type">int</span> d_;<br>    ObjectD objd_;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>那如果在上面的基础上，基类有个其它类的对象成员，那么构造函数顺序则变为：先调用基类对象成员的构造函数、然后调用基类构造函数、再调用派生类对象成员构造函数、再调用派生类自身构造函数。</p><p>那如果上述代码中<code>ObjectD</code>类仅定义有参构造，此时<code>Derived</code>中的类成员对象需要在<code>Derived</code>初始化列表中构造，如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectD</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ObjectD</span>(<span class="hljs-type">int</span> a) : <span class="hljs-built_in">a_</span>(a) &#123;&#125;<br>    <span class="hljs-type">int</span> a_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> b) : <span class="hljs-built_in">b_</span>(b) &#123;&#125;<br>    <span class="hljs-type">int</span> b_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> b, <span class="hljs-type">int</span> d) : <span class="hljs-built_in">d_</span>(d), <span class="hljs-built_in">Base</span>(b), <span class="hljs-built_in">objd_</span>(<span class="hljs-number">100</span>) &#123;&#125;<br>    <span class="hljs-type">int</span> d_;<br>    ObjectD objd_;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>此时如果给<code>Derived</code>类定义拷贝构造函数，则需要提前给<code>Derived</code>类的成员类<code>ObjectD</code>也定义拷贝构造函数，并且在<code>Derived</code>类中的拷贝构造函数需要在初始化列表给其基类、类成员进行初始化，具体代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectD</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ObjectD</span>(<span class="hljs-type">int</span> a) : <span class="hljs-built_in">a_</span>(a) &#123;&#125;<br>    <span class="hljs-built_in">ObjectD</span>(<span class="hljs-type">const</span> ObjectD &amp;other) &#123; a_ = other.a_; &#125;<br>    <span class="hljs-type">int</span> a_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> b) : <span class="hljs-built_in">b_</span>(b) &#123;&#125;<br>    <span class="hljs-type">int</span> b_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> b, <span class="hljs-type">int</span> d) : <span class="hljs-built_in">d_</span>(d), <span class="hljs-built_in">Base</span>(b), <span class="hljs-built_in">objd_</span>(<span class="hljs-number">100</span>) &#123;&#125;<br>    <span class="hljs-comment">//这里需要对类成员对象进行初始化列表</span><br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">const</span> Derived &amp;other) : <span class="hljs-built_in">objd_</span>(other.objd_), <span class="hljs-built_in">d_</span>(other.d_), <span class="hljs-built_in">Base</span>(<span class="hljs-number">100</span>) &#123;&#125; <span class="hljs-comment">//objd_(other.objd_)需调用ObjectD类拷贝构造函数</span><br>    <span class="hljs-type">int</span> d_;<br>    ObjectD objd_;<br>&#125;;<br></code></pre></td></tr></table></figure></p><ul><li><code>static</code>成员即使被继承，内存中也仅有一份。</li></ul><h4 id="派生类到基类的转换">派生类到基类的转换</h4><ul><li>当派生类以<code>public</code>方式继承基类时，编译器可自动执行的转换（向上转型<code>upcasting</code>安全转换）：</li><li>基类指针（引用）可指向（引用）派生类对象</li><li>派生类对象可赋值给基类对象（派生类特有成员消失）</li><li>当派生类以<code>protected/private</code>方式继承基类时：</li><li>基类指针（引用）可指向（引用）派生类对象需强制转换，但不能使用<code>static_cast</code>而要用<code>reinterpret_cast</code></li><li>不能将派生类对象赋值给基类对象</li></ul><p>代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> string &amp;name, <span class="hljs-type">const</span> <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">int</span> deptno) : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">age_</span>(age), <span class="hljs-built_in">deptno_</span>(deptno) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    string name_;<br>    <span class="hljs-type">int</span> age_;<br>    <span class="hljs-type">int</span> deptno_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Employee &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Manager</span>(<span class="hljs-type">const</span> string &amp;name, <span class="hljs-type">const</span> <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">int</span> deptno, <span class="hljs-type">int</span> level) : <span class="hljs-built_in">Employee</span>(name, age, deptno), <span class="hljs-built_in">level_</span>(level) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> level_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager2</span> : <span class="hljs-keyword">private</span> Employee &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Manager2</span>(<span class="hljs-type">const</span> string &amp;name, <span class="hljs-type">const</span> <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">int</span> deptno, <span class="hljs-type">int</span> level) : <span class="hljs-built_in">Employee</span>(name, age, deptno), <span class="hljs-built_in">level_</span>(level) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> level_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Employee <span class="hljs-title">e1</span><span class="hljs-params">(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Manager <span class="hljs-title">m1</span><span class="hljs-params">(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">38</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Manager2 <span class="hljs-title">m2</span><span class="hljs-params">(<span class="hljs-string">&quot;wangwu&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>)</span></span>;<br>    Employee *pe;<br>    Manager *pm;<br>    Manager2 *pm2;<br><br>    pe = &amp;m1; <span class="hljs-comment">//public继承中 基类指针指向派生类对象</span><br>    e1 = m1; <span class="hljs-comment">//public继承中 派生类对象赋值给基类对象</span><br>    pe = <span class="hljs-built_in">reinterpret_cast</span>&lt;Employee *&gt;(&amp;m2); <span class="hljs-comment">//protected/private继承中 基类指针指向派生类对象</span><br>    <span class="hljs-comment">// e1 = m2; //protected/private继承中 不能赋值 即使强制转换也不行</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="基类到派生类的转换">基类到派生类的转换</h4><ul><li>派生类指针（引用）指向（引用）基类指针或对象时，若派生类<code>public</code>继承，可以使用<code>static_cast</code>进行静态强制转换，但是不安全，当然也可以使用<code>reinterpret_cast</code>。若派生类<code>protected/private</code>继承，仅能使用<code>reinterpret_cast</code>进行强制转换。</li><li>向下转型不安全，没有自动转换的机制，即基类对象无法直接赋值给派生类对象，要想实现赋值也可以，通过类型转换构造函数即可，不过仅仅只是通过了语法检测，这种做法并不安全。</li></ul><p>以下代码则是将基类对象赋值给派生类对象的实现，之所以可以成功，是因为我们在派生类中声明了类型转换构造函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> string &amp;name, <span class="hljs-type">const</span> <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">int</span> deptno) : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">age_</span>(age), <span class="hljs-built_in">deptno_</span>(deptno) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    string name_;<br>    <span class="hljs-type">int</span> age_;<br>    <span class="hljs-type">int</span> deptno_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Employee &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Manager</span>(<span class="hljs-type">const</span> string &amp;name, <span class="hljs-type">const</span> <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">int</span> deptno, <span class="hljs-type">int</span> level) : <span class="hljs-built_in">Employee</span>(name, age, deptno), <span class="hljs-built_in">level_</span>(level) &#123;&#125;<br>    <span class="hljs-built_in">Manager</span>(<span class="hljs-type">const</span> Employee &amp;other) : <span class="hljs-built_in">Employee</span>(other), <span class="hljs-built_in">level_</span>(<span class="hljs-number">10</span>) &#123;&#125; <span class="hljs-comment">//类型转换</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> level_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Employee <span class="hljs-title">e1</span><span class="hljs-params">(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Manager <span class="hljs-title">m1</span><span class="hljs-params">(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">38</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>)</span></span>;<br>    m1 = e1; <span class="hljs-comment">//成功了 但不建议这么做（先调用类型转换构造函数创建临时对象，再通过默认=重载赋值）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>需要注意的一点细节是，在<code>gdb</code>调试过程中，当调用默认<code>=</code>运算符重载时，发现先执行调用派生类<code>=</code>运算符重载，然后再去执行基类的<code>=</code>运算符重载：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Manager::<span class="hljs-keyword">operator</span>= (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdee0</span>) at <span class="hljs-number">02.</span>cpp:(line)<br>(line)      <span class="hljs-keyword">class</span> Manager : <span class="hljs-keyword">public</span> Employee &#123;<br>Employee::<span class="hljs-keyword">operator</span>= (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdee0</span>) at <span class="hljs-number">02.</span>cpp:(line)<br>(line)      <span class="hljs-keyword">class</span> Employee &#123;<br></code></pre></td></tr></table></figure></p><p>如果不采用类型转换构造函数，而使用类型转换运算符重载<code>operator 类型名&#123;&#125;</code>，则实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span>; <span class="hljs-comment">//下面声明要用 因此在前面提前声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> string &amp;name, <span class="hljs-type">const</span> <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">int</span> deptno) : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">age_</span>(age), <span class="hljs-built_in">deptno_</span>(deptno) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">Manager</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//类型转换运算符重载 无返回值</span><br><span class="hljs-keyword">private</span>:<br>    string name_;<br>    <span class="hljs-type">int</span> age_;<br>    <span class="hljs-type">int</span> deptno_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Employee &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Manager</span>(<span class="hljs-type">const</span> string &amp;name, <span class="hljs-type">const</span> <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">int</span> deptno, <span class="hljs-type">int</span> level) : <span class="hljs-built_in">Employee</span>(name, age, deptno), <span class="hljs-built_in">level_</span>(level) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> level_;<br>&#125;;<br><br><span class="hljs-function">Employee::<span class="hljs-keyword">operator</span> <span class="hljs-title">Manager</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Manager</span>(name_, age_, deptno_, <span class="hljs-number">-1</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Employee <span class="hljs-title">e1</span><span class="hljs-params">(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Manager <span class="hljs-title">m1</span><span class="hljs-params">(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">38</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>)</span></span>;<br>    m1 = e1; <span class="hljs-comment">//将Employee类类型对象转换为其它类型（Manager类类型）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里需要注意搞清楚类型转换构造函数和类型转换运算符重载的区别，<strong>类型转换构造函数为将其它类型转为当前类类型，而类型转换运算符重载则是将当前类类型转换为其它类型。</strong></p><h4 id="虚基类及其派生类的构造函数">虚基类及其派生类的构造函数</h4><ul><li>虚基类的成员由<strong>最远派生类的构造函数通过调用虚基类的构造函数进行初始化</strong>。</li><li>在整个继承结构中，直接或间接继承虚基类的<strong>所有派生类都必须在构造函数的成员初始化列表中给出对虚基类的构造函数的调用</strong>。如果未列出，则表示调用该虚基类的默认构造函数。</li><li>在建立对象时，只有最远派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。</li></ul><h4 id="多态的实现方法">多态的实现方法</h4><ul><li>静态绑定</li><li>函数重载</li><li>运算符重载</li><li>模版</li><li>动态绑定</li><li>虚函数</li></ul><p>当我在学习多态的时候，学到了虚函数，比如现在有如下类声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun3</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*virtual*/</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun1</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">//基类定义虚函数后 派生类也是虚函数 写不写virtual都可以</span><br>    <span class="hljs-comment">/*virtual*/</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun3</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><strong>疑问</strong>：那么我们知道，基类指针指向派生类对象时，如果基类指针调用的是<code>Fun1()</code>或<code>Fun2()</code>，那么会调用派生类的函数，这就是所谓的多态，那如果基类指针调用的是非虚函数<code>Fun3()</code>，那么调用的则是指针类型所对应类的方法，也就是基类中的<code>Fun3()</code>。学到这里我就在想，那什么样的情况下我可以调用派生类的<code>Fun3()</code>呢？首先排除最正常的调用方法（即派生类指针指向派生类对象再去调用），于是我通过派生类指针指向基类对象，为了让其语法通过，我使用<code>reinterpret_cast</code>进行强制转换，然后使用派生类指针调用<code>Fun3()</code>，成功实现了对派生类<code>Fun3</code>的调用，可是派生类指针指向的是基类对象呀，这样的调用会不会出现所谓的越界或者访问了一个不安全的内存呢？或许学完虚函数表等概念后会对虚函数和非虚函数的内存调用有所了解吧，后续再想想这个问题。</p><p>关于虚函数、虚表、虚继承、虚基类表等，可参考：https://segmentfault.com/a/1190000023098876</p><h4 id="抽象类">抽象类</h4><ul><li>作用</li><li>抽象类为抽象和设计的目的而声明，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。</li><li>对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。</li><li>注意</li><li>抽象类只能作为基类来使用。</li><li>不能声明抽象类对象。</li><li>构造函数不能是虚函数，析构函数可以是虚函数。</li></ul><p>构造函数不能是虚函数。当我们调用构造函数时，如果有虚函数，则构造出来的对象内存的前几个字节表示的是虚表指针<code>vptr</code>，我们通过构造出对象，再通过虚表指针去访问虚表，以此来确定虚函数，那么此时如果构造函数是虚函数，那么构造函数应当在虚表中，如果构造函数在虚表中，那首先对象没有办法提前构造出来，我们就无从找到<code>vptr</code>的内存地址，因而无法通过虚指针找到虚表，也就无法找到虚构造函数了，这显然很矛盾，所以<strong>构造函数本身不能作为虚函数</strong>。以下为采用抽象类<code>Draw()</code>实现多态： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//抽象类 只要有一个纯虚函数 就是抽象类 不能声明对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//声明抽象类</span><br>&#125;;<br><br><span class="hljs-comment">//派生类需要实现纯虚函数 如果派生类未实现 则派生类也是抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Circle::Draw() ...&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Square::Draw() ...&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DrawAllShapes</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Shape *&gt; &amp;v)</span> </span>&#123;<br>    vector&lt;Shape *&gt;::const_iterator it;<br>    <span class="hljs-keyword">for</span>(it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it)<br>        (*it)-&gt;<span class="hljs-built_in">Draw</span>(); <span class="hljs-comment">//多态</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Shape s; //不能实例化抽象类</span><br>    Circle c;<br>    vector&lt;Shape *&gt; v;<br>    Shape *ps;<br>    ps = <span class="hljs-keyword">new</span> Circle;<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br>    ps = <span class="hljs-keyword">new</span> Square;<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br><br>    <span class="hljs-built_in">DrawAllShapes</span>(v); <span class="hljs-comment">//分别调用Circle和Square中的Draw()函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>对于上面的抽象类，我们如果不在基类抽象类中定义析构函数，而是在派生类中定义各自的析构函数，那么如果遍历<code>vector</code>去<code>delete</code>删除<code>Shape</code>指针指向的对象，因为没有<code>virtual</code>函数，不会出现多态，因此基类指针尽管指向了派生类，但是当<code>delete</code>时却不会触发派生类对象的析构函数，所以为了让其能够出发，即在基类中声明虚析构抽象类，代码改进如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() &#123;&#125; <span class="hljs-comment">//虚析构抽象类</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Circle::Draw() ...&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Circle</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~Circle ...&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Square::Draw() ...&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Square</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~Square ...&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Rectangle::Draw() ...&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Rectangle</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~Rectangle ...&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DrawAllShapes</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Shape *&gt; &amp;v)</span> </span>&#123;<br>    vector&lt;Shape *&gt;::const_iterator it;<br>    <span class="hljs-keyword">for</span>(it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it)<br>        (*it)-&gt;<span class="hljs-built_in">Draw</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DeleteAllShapes</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Shape *&gt; &amp;v)</span> </span>&#123;<br>    vector&lt;Shape *&gt;::const_iterator it;<br>    <span class="hljs-keyword">for</span>(it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it)<br>        <span class="hljs-built_in">delete</span>(*it); <span class="hljs-comment">//因为定义了虚析构抽象类 此处实现多态 调用对应对象所属类的析构函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;Shape *&gt; v;<br>    Shape *ps;<br>    ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br>    ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Square</span>();<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br>    ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rectangle</span>();<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br><br>    <span class="hljs-built_in">DrawAllShapes</span>(v);<br>    <span class="hljs-built_in">DeleteAllShapes</span>(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>我们发现上述代码定义抽象类后，如果要扩展新的类，只需要定义新类方法，继承抽象类，然后在<code>main</code>中创建这个新类对象即可。不需要修改旧的代码，提高了可扩展性，但是对于上述代码依然可以进一步优化，在<code>main</code>中创建新类对象时，可使用<code>简单工厂模式</code>去构建。</p><h4 id="简单工厂模式">简单工厂模式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-comment">//工厂模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Shape *<span class="hljs-title">CreateShape</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;name)</span> </span>&#123;<br>        Shape *ps = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(name == <span class="hljs-string">&quot;Circle&quot;</span>) &#123;<br>            ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(name == <span class="hljs-string">&quot;Square&quot;</span>) &#123;<br>            ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Square</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(name == <span class="hljs-string">&quot;Rectangle&quot;</span>) &#123;<br>            ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rectangle</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ps;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Shape *ps;<br>    ps = ShapeFactory::<span class="hljs-built_in">CreateShape</span>(<span class="hljs-string">&quot;Circle&quot;</span>);<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br>    ps = ShapeFactory::<span class="hljs-built_in">CreateShape</span>(<span class="hljs-string">&quot;Square&quot;</span>);<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br>    ps = ShapeFactory::<span class="hljs-built_in">CreateShape</span>(<span class="hljs-string">&quot;Rectangle&quot;</span>);<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br><br>    <span class="hljs-built_in">DrawAllShapes</span>(v);<br>    <span class="hljs-built_in">DeleteAllShapes</span>(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述静态代码，我们可以替换掉<code>main</code>中的<code>new</code>语句，而是将其统一放入到<code>ShapeFactory</code>类中，如果在<code>main</code>中多次<code>new</code>了某个<code>Shape</code>比如<code>Circle</code>，那此时如果需要对<code>Circle</code>进行扩展，将<code>Circle</code>名称改为<code>Circle_Pro</code>，就需要人工手动修改<code>main</code>中所有<code>new Circle()</code>。但如果使用工厂模式代替手动<code>new</code>过程，我们只需要将类中静态函数出现的<code>Circle</code>改为<code>Circle_Pro</code>即可，大大增强了可扩展性。但是上述代码多次使用<code>if-else</code>语句，增加了代码的耦合性，我们可通过<strong>动态创建</strong>对其进一步改进，让其展现多态性。动态创建有四个文件，分别为<code>Shape.cpp</code>、<code>Shape.h</code>、<code>DynBase.h</code>、<code>DynTest.cpp</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Shape.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _SHAPE_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SHAPE_H_</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() &#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span></span>;<br>    ~<span class="hljs-built_in">Circle</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span></span>;<br>    ~<span class="hljs-built_in">Square</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span></span>;<br>    ~<span class="hljs-built_in">Rectangle</span>();<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//DynBase.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _DYN_BASE_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _DYN_BASE_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DynObjectFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">CreateObject</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;name)</span> </span>&#123;<br>        map&lt;basic_string&lt;<span class="hljs-type">char</span>&gt;, <span class="hljs-type">void</span> *(*)()&gt;::const_iterator it;<br>        it = mapCls_.<span class="hljs-built_in">find</span>(name);<br>        <span class="hljs-keyword">if</span>(it == mapCls_.<span class="hljs-built_in">end</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> it-&gt;<span class="hljs-built_in">second</span>(); <span class="hljs-comment">//it-&gt;second() 相当于 调用NewInstance() 返回该函数的返回值</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Register</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;name, <span class="hljs-type">void</span> *(*func)())</span> </span>&#123;<br>        mapCls_[name] = func;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> map&lt;basic_string&lt;<span class="hljs-type">char</span>&gt;, <span class="hljs-type">void</span> *(*)()&gt; mapCls_;<br>&#125;;<br><br><span class="hljs-comment">//当运行DyTest时，Shape.cpp中包含DynBase.h DyTest.cpp也包含DynBase.h 因此此句被定义两次 需要使用__attribute__((weak))去重</span><br>__attribute__((weak)) map&lt;basic_string&lt;<span class="hljs-type">char</span>&gt;, <span class="hljs-type">void</span> *(*)()&gt; DynObjectFactory::mapCls_;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Register</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Register</span>(<span class="hljs-type">const</span> string &amp;name, <span class="hljs-type">void</span> *(*func)()) &#123;<br>        DynObjectFactory::<span class="hljs-built_in">Register</span>(name, func);<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_CLASS(class_name) \</span><br><span class="hljs-meta">class class_name##Register &#123; \</span><br><span class="hljs-meta">public: \</span><br><span class="hljs-meta">    static void *NewInstance() &#123; \</span><br><span class="hljs-meta">        return new class_name; \</span><br><span class="hljs-meta">    &#125; \</span><br><span class="hljs-meta">private: \</span><br><span class="hljs-meta">    static Register reg_; \</span><br><span class="hljs-meta">&#125;; \</span><br><span class="hljs-meta">Register class_name##Register::reg_(#class_name, class_name##Register::NewInstance)</span><br><br><span class="hljs-comment">//类为 ShapeRigister等</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Shape.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DynBase.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Circle::Draw</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Circle::Draw() ...&quot;</span> &lt;&lt; endl;<br>&#125;<br>Circle::~<span class="hljs-built_in">Circle</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;~Circle ...&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Square::Draw</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Square::Draw() ...&quot;</span> &lt;&lt; endl;<br>&#125;<br>Square::~<span class="hljs-built_in">Square</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;~Square ...&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Rectangle::Draw</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Rectangle::Draw() ...&quot;</span> &lt;&lt; endl;<br>&#125;<br>Rectangle::~<span class="hljs-built_in">Rectangle</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;~Rectangle ...&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">REGISTER_CLASS</span>(Circle);<br><span class="hljs-comment">// class CircleRegister &#123;</span><br><span class="hljs-comment">// public:</span><br><span class="hljs-comment">//     static void *NewInstance() &#123;</span><br><span class="hljs-comment">//         return new Circle;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// private:</span><br><span class="hljs-comment">//     static Register reg_; //声明</span><br><span class="hljs-comment">// &#125;;</span><br><span class="hljs-comment">// Register CircleRegister::reg_(&quot;Circle&quot;, CircleRegister::NewInstance)</span><br><span class="hljs-built_in">REGISTER_CLASS</span>(Square);<br><span class="hljs-built_in">REGISTER_CLASS</span>(Rectangle);<br></code></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//DynTest.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DynBase.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DrawAllShapes</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Shape *&gt; &amp;v)</span> </span>&#123;<br>    vector&lt;Shape *&gt;::const_iterator it;<br>    <span class="hljs-keyword">for</span>(it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it)<br>        (*it)-&gt;<span class="hljs-built_in">Draw</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DeleteAllShapes</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Shape *&gt; &amp;v)</span> </span>&#123;<br>    vector&lt;Shape *&gt;::const_iterator it;<br>    <span class="hljs-keyword">for</span>(it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it)<br>        <span class="hljs-built_in">delete</span>(*it);<br>&#125;<br><br><span class="hljs-comment">//工厂模式</span><br><span class="hljs-comment">// class ShapeFactory &#123;</span><br><span class="hljs-comment">// public:</span><br><span class="hljs-comment">//     static Shape *CreateShape(const string &amp;name) &#123;</span><br><span class="hljs-comment">//         Shape *ps = 0;</span><br><span class="hljs-comment">//         if(name == &quot;Circle&quot;) &#123;</span><br><span class="hljs-comment">//             ps = new Circle();</span><br><span class="hljs-comment">//         &#125; else if(name == &quot;Square&quot;) &#123;</span><br><span class="hljs-comment">//             ps = new Square();</span><br><span class="hljs-comment">//         &#125; else if(name == &quot;Rectangle&quot;) &#123;</span><br><span class="hljs-comment">//             ps = new Rectangle();</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//         return ps;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;Shape *&gt; v;<br><br>    Shape *ps;<br>    ps = <span class="hljs-built_in">static_cast</span>&lt;Shape *&gt;(DynObjectFactory::<span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;Circle&quot;</span>));<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br>    ps = <span class="hljs-built_in">static_cast</span>&lt;Shape *&gt;(DynObjectFactory::<span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;Square&quot;</span>));<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br>    ps = <span class="hljs-built_in">static_cast</span>&lt;Shape *&gt;(DynObjectFactory::<span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;Rectangle&quot;</span>));<br>    v.<span class="hljs-built_in">push_back</span>(ps);<br><br>    <span class="hljs-built_in">DrawAllShapes</span>(v);<br>    <span class="hljs-built_in">DeleteAllShapes</span>(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>那么对于上述工厂模式，我们还可以通过模板的方式重写工厂模式，只需要对<code>DynBase.h</code>文件稍做修改，其余文件保持不变，我们来看一下<code>DynBase.h</code>的代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//DynBase.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _DYN_BASE_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _DYN_BASE_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DynObjectFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">CreateObject</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;name)</span> </span>&#123;<br>        map&lt;basic_string&lt;<span class="hljs-type">char</span>&gt;, <span class="hljs-type">void</span> *(*)()&gt;::const_iterator it;<br>        it = mapCls_.<span class="hljs-built_in">find</span>(name);<br>        <span class="hljs-keyword">if</span>(it == mapCls_.<span class="hljs-built_in">end</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> it-&gt;<span class="hljs-built_in">second</span>(); <span class="hljs-comment">//it-&gt;second() 相当于 调用NewInstance() 返回该函数的返回值</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Register</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;name, <span class="hljs-type">void</span> *(*func)())</span> </span>&#123;<br>        mapCls_[name] = func;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> map&lt;basic_string&lt;<span class="hljs-type">char</span>&gt;, <span class="hljs-type">void</span> *(*)()&gt; mapCls_;<br>&#125;;<br><br><span class="hljs-comment">//当运行DyTest时，Shape.cpp中包含DynBase.h DyTest.cpp也包含DynBase.h 因此此句被定义两次 需要使用__attribute__((weak))去重</span><br>__attribute__((weak)) map&lt;basic_string&lt;<span class="hljs-type">char</span>&gt;, <span class="hljs-type">void</span> *(*)()&gt; DynObjectFactory::mapCls_;<br><br><span class="hljs-comment">// class Register &#123;</span><br><span class="hljs-comment">// public:</span><br><span class="hljs-comment">//     Register(const string &amp;name, void *(*func)()) &#123;</span><br><span class="hljs-comment">//         DynObjectFactory::Register(name, func);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-comment">// #define REGISTER_CLASS(class_name) \</span><br><span class="hljs-comment">// class class_name##Register &#123; \</span><br><span class="hljs-comment">// public: \</span><br><span class="hljs-comment">//     static void *NewInstance() &#123; \</span><br><span class="hljs-comment">//         return new class_name; \</span><br><span class="hljs-comment">//     &#125; \</span><br><span class="hljs-comment">// private: \</span><br><span class="hljs-comment">//     static Register reg_; \</span><br><span class="hljs-comment">// &#125;; \</span><br><span class="hljs-comment">// Register class_name##Register::reg_(#class_name, class_name##Register::NewInstance)</span><br><br><span class="hljs-comment">// 类为 ShapeRigister等</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatingClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DelegatingClass</span>(<span class="hljs-type">const</span> string &amp;name) &#123;<br>        DynObjectFactory::<span class="hljs-built_in">Register</span>(name, NewInstance);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">NewInstance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T; &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_CLASS(class_name) DelegatingClass<span class="hljs-string">&lt;class_name&gt;</span> class##class_name(#class_name)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><hr /><p><code>typeid</code>运算符用于知晓多态对象的动态类型，其可接收一个<strong>指针或类型</strong>，返回的是一个<code>typeinfo</code>类对象，该类对象如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">type_info</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">type_info</span>();<br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> type_info&amp; rhs) <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span>;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">before</span><span class="hljs-params">(<span class="hljs-type">const</span> type_info&amp; rhs)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">hash_code</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br> <br>        <span class="hljs-built_in">type_info</span>(<span class="hljs-type">const</span> type_info&amp;) = <span class="hljs-keyword">delete</span>;                   <span class="hljs-comment">// 不能复制</span><br>        type_info&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> type_info&amp;) = <span class="hljs-keyword">delete</span>;        <span class="hljs-comment">// 不能复制</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>上述代码中拷贝构造函数后有<code>=delete</code>，这意味着我们不能定义一个<code>type_info</code>对象。其中，成员函数<code>name</code>用于获取多态类型，用法如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">B Obj; <span class="hljs-comment">//派生类对象</span><br>A *p = &amp;Obj; <span class="hljs-comment">//基类指针指向派生类对象</span><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*p).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//打印 B</span><br><br><span class="hljs-type">int</span> *p1;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span>).<span class="hljs-built_in">name</span>() == <span class="hljs-built_in">typeid</span>(*p).<span class="hljs-built_in">name</span>()) &#123; <span class="hljs-comment">//判断p指向的是int类型</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>问题</strong>：<code>typeid(T).name()</code>方法在<code>Linux CentOS 7.3</code>下通过<code>g++</code>编译得不到变量正确的类型。在写如下代码时遇到了这个问题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">模板的实参推演</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T a)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a + b;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br>    <span class="hljs-built_in">func</span>(sum);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>上述代码功能主要想打印出模板类型参数<code>T</code>通过模板参数推演推导出来的参数类型是什么。根据代码逻辑，推演得出的结果分别是<code>int</code>、<code>char const *</code>、<code>int (*)(int, int)</code>这三种类型，可是在<code>linux</code>下通过<code>g++</code>编译并执行可执行文件，得到的结果如下：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span><br>PKc<br>PFiiiE<br></code></pre></td></tr></table></figure></p><p>这到底是个啥玩意儿？这并不是我们想要的结果，最终在<code>stackoverflow</code>找到了答案：<ahref="https://stackoverflow.com/questions/789402/typeid-returns-extra-characters-in-g">[Link]</a>，大意就是说，这是<code>GCC</code>编译器的问题，编译出来的结果是乱序的，需要我们使用<code>linux</code>命令<code>c++filt</code>将乱序的结果复原回去。使用下述方法即可复原：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">./a.out | c++filt -<span class="hljs-function">t</span><br><span class="hljs-function"><span class="hljs-type">int</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-type">const</span>*</span><br><span class="hljs-function"><span class="hljs-title">int</span> <span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span><br></code></pre></td></tr></table></figure></p><p>通过<code>man</code>手册<code>man c++filt</code>可以看到该命令的具体说明：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">C++FILT(<span class="hljs-number">1</span>)                      GNU Development Tools                     C++FILT(<span class="hljs-number">1</span>)<br><span class="hljs-type">NAME</span><br>       c++filt - Demangle C++ <span class="hljs-keyword">and</span> Java symbols.<br><br>SYNOPSIS<br>       c++filt [-_|<span class="hljs-comment">--strip-underscore]</span><br>               [-n|<span class="hljs-comment">--no-strip-underscore]</span><br>               [-p|<span class="hljs-comment">--no-params]</span><br>               [-t|<span class="hljs-comment">--types]</span><br>               [-i|<span class="hljs-comment">--no-verbose]</span><br>               [-s <span class="hljs-keyword">format</span>|<span class="hljs-comment">--format=format]</span><br>               [<span class="hljs-comment">--help]  [--version]  [symbol...]</span><br><br>DESCRIPTION<br>       The C++ <span class="hljs-keyword">and</span> Java languages provide <span class="hljs-keyword">function</span> overloading, which means that you<br>       can <span class="hljs-keyword">write</span> many <span class="hljs-keyword">functions</span> <span class="hljs-keyword">with</span> the same <span class="hljs-type">name</span>, providing that <span class="hljs-keyword">each</span> <span class="hljs-keyword">function</span><br>       takes parameters <span class="hljs-keyword">of</span> different <span class="hljs-keyword">types</span>.  <span class="hljs-keyword">In</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">to</span> be able <span class="hljs-keyword">to</span> distinguish<br>       these similarly named <span class="hljs-keyword">functions</span> C++ <span class="hljs-keyword">and</span> Java encode them <span class="hljs-keyword">into</span> a low-<span class="hljs-keyword">level</span><br>       assembler <span class="hljs-type">name</span> which uniquely identifies <span class="hljs-keyword">each</span> different <span class="hljs-keyword">version</span>.  This<br>       process <span class="hljs-keyword">is</span> known <span class="hljs-keyword">as</span> mangling. The c++filt [<span class="hljs-number">1</span>] program does the inverse<br>       <span class="hljs-keyword">mapping</span>: it decodes (demangles) low-<span class="hljs-keyword">level</span> names <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>-<span class="hljs-keyword">level</span> names so that<br>       they can be <span class="hljs-keyword">read</span>.<br><br>       Every alphanumeric word (consisting <span class="hljs-keyword">of</span> letters, digits, underscores, dollars,<br>       <span class="hljs-keyword">or</span> periods) seen <span class="hljs-keyword">in</span> the <span class="hljs-keyword">input</span> <span class="hljs-keyword">is</span> a potential mangled <span class="hljs-type">name</span>.  <span class="hljs-keyword">If</span> the <span class="hljs-type">name</span><br>       decodes <span class="hljs-keyword">into</span> a C++ <span class="hljs-type">name</span>, the C++ <span class="hljs-type">name</span> replaces the low-<span class="hljs-keyword">level</span> <span class="hljs-type">name</span> <span class="hljs-keyword">in</span> the<br>       output, otherwise the original word <span class="hljs-keyword">is</span> output.  <span class="hljs-keyword">In</span> this way you can pass an<br>       entire assembler source file, containing mangled names, through c++filt <span class="hljs-keyword">and</span><br>       see the same source file containing demangled names.<br></code></pre></td></tr></table></figure></p><p>我们从描述中可以看到，这个程序主要用于解码低等级的名称，解码为用户可阅读的名称，之所以要这么做，是因为<code>C++</code>中的重载特性所决定的。</p><hr /><p>什么是值语义，什么是对象语义？值语义对象生命周期容控制、对象语义声明周期不容易控制</p><h2 id="智能指针需补充">智能指针（需补充）</h2><p><strong>智能指针的本质思想是</strong>：将堆对象的生存期用栈对象（智能指针）来管理，当<code>new</code>一个堆对象的时候，立刻用智能指针来接管，具体做法是在构造函数中进行初始化（用一个指针指向所创建的堆对象），在析构函数中调用<code>delete</code>来释放堆对象。由于智能指针本身是一个栈对象，它的作用域结束的时候，会自动调用析构函数，从而调用了<code>delete</code>释放了堆对象</p><h4 id="c11以前的智能指针">C++11以前的智能指针</h4><p><strong>auto_ptr</strong>指向一个动态分配的对象指针，它的析构函数用于删除所指对象的空间，一次达到对对象生存期的控制。（所有权独占，不能共享，但是可以转移），已经被弃用，原因：* 避免潜在的内存崩溃：auto_ptr进行赋值操作时候，被赋值的取得其所有权，去赋值的丢失其所有权（变成空指针，无法再使用）* 不够方便：没有移动语义</p><p><strong>boost智能指针</strong> * 智能指针是利用RAII(ResourceAcquisition Is Initialization：资源获取即初始化)来管理资源。 <imgsrc="media/16224350022491/16378615118652.jpg" alt="-w1339" /></p><h4 id="c11标准的智能指针">C++11标准的智能指针</h4><p>加入了<code>unique_ptr</code>、<code>shared_ptr</code>和<code>weak_ptr</code></p><p><strong>unique_ptr</strong><code>unique_ptr</code>，等同于<code>boost</code>库中的<code>scoped_ptr</code>，正如其名字所述，<code>scoped_ptr</code>所指向的对象在作用域之外会自动得到析构。<code>boost</code>库是<code>Boost</code>社区在<code>C++11</code>之前嫌弃标准更新太慢，而自发组织开发、维护的一个扩展库。通过包含头文件<code>"boost/scoped_ptr.hpp"</code>来引入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;<br>   <span class="hljs-keyword">class</span> unique_ptr<br>   &#123;<br>     <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Up&gt;<br>     <span class="hljs-keyword">using</span> _DeleterConstraint =<br><span class="hljs-keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint::type;<br><br>     __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t;<br><br>   <span class="hljs-keyword">public</span>:<br>     <span class="hljs-keyword">using</span> pointer  = <span class="hljs-keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;<br>     <span class="hljs-keyword">using</span> element_type  = _Tp;<br>     <span class="hljs-keyword">using</span> deleter_type  = _Dp;<br>     <br>     <span class="hljs-comment">//...省略</span><br><br>     <span class="hljs-comment">// Disable copy from lvalue.</span><br>     <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>     unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br> &#125;;<br></code></pre></td></tr></table></figure><p>可以看到，<code>unique_ptr</code>禁止左值拷贝构造和左值<code>=</code>运算符重载赋值操作，同样在<code>boost</code>库中<code>scoped_ptr</code>也同样禁止拷贝构造和<code>=</code>运算符重载赋值操作。因此作用域内通过<code>unique_ptr</code>指向的堆空间不能够被更改，也不能够被拷贝赋值等。</p><p><code>unique_ptr</code>是独享所有权的智能指针，资源只能被一个指针占有，但是<code>unique_ptr</code>中实现了右值移动构造和右值移动赋值构造（右值<code>=</code>运算符重载），也就是说对象空间可以转移给另一个<code>unique_ptr</code>智能指针（调用<code>move()</code>函数），即一个<code>unique_ptr</code>对象赋值给另一个<code>unique_ptr</code>对象，可以通过该方法进行赋值。具体代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A 作为一个类 </span><br><span class="hljs-function">std::unique_ptr&lt;A&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>std::unique_ptr&lt;A&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);<br></code></pre></td></tr></table></figure><p><strong>shared_ptr</strong><code>shared_ptr</code>，可共享指针对象，可以赋值给<code>shared_ptr</code>或<code>weak_ptr</code>。<code>shared_ptr</code>中所实现的本质是引用计数，拷贝一个<code>shared_ptr</code>将对这个智能指针的引用次数加<code>1</code>，而当这个智能指针的引用次数降低到<code>0</code>的时候，该对象自动被析构。</p><p>相比于<code>std::unique_ptr</code>和<code>boost::scoped_ptr</code>，<code>shared_ptr</code>指向的资源可被多个指针共享，可以通过<code>unique_ptr</code>、<code>weak_ptr</code>来构造，调用<code>release()</code>释放资源的所有权，计数减一。代码部分与<code>scoped_ptr</code>类似，只是支持拷贝、赋值和<code>==</code>、<code>!=</code>。释放某个<code>shared_ptr</code>对象，使用成员函数<code>reset()</code>；若要查看资源的所有者的个数或返回引用计数，使用成员函数<code>use_count()</code>；若要返回智能指针指向的对象地址，使用成员函数<code>get()</code>。需要注意的是，<code>shared_ptr</code>是<strong>线程安全</strong>的。</p><p>这里需要特别注意的是，若将<code>shared_ptr s</code>通过<code>push_back(s)</code>的方式存放至容器中，那么其引用计数也会<code>+1</code>（实际上是将<code>s</code>类通过<code>=</code>运算符重载拷贝至容器<code>vector</code>中），如果仅仅通过<code>reset</code>释放<code>s</code>智能指针，其引用计数减<code>1</code>，但不一定释放堆空间资源，<code>vector</code>中的每个元素也占用一个引用计数，需要对每个<code>vector</code>元素再进行<code>reset</code>操作，示例图如下：<img src="media/16224350022491/16379141400743.jpg" alt="-w747" /></p><p><strong>注意：避免使用匿名的临时<code>shared_ptr&lt;T&gt;</code>对象</strong>，以下是正确做法和错误做法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(shared_ptr&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-type">int</span> g;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OK</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">2</span>))</span></span>;<br>    <span class="hljs-built_in">f</span>(p, <span class="hljs-built_in">g</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BAD</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>)), <span class="hljs-built_in">g</span>());<br>    <span class="hljs-comment">//不同编译器计算顺序不同，可能存在风险如下：</span><br>    <span class="hljs-comment">//第一个参数先new申请空间，然后shared_ptr还未触发构造时</span><br>    <span class="hljs-comment">//可能开始调用第二个参数g()，如果触发调用异常 该BAD()函数退出</span><br>    <span class="hljs-comment">//调用BAD()函数后，创建了无人接管的堆空间 出现内存泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>智能指针的实现原理：计数原理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span> &#123;<br><span class="hljs-keyword">private</span> : <br>T *_ptr;           <span class="hljs-comment">// 指向模板类型T的指针</span><br><span class="hljs-type">size_t</span> *_count;    <span class="hljs-comment">// 引用计数</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SmartPtr</span>(T *ptr = <span class="hljs-literal">nullptr</span>) : _ptr(ptr) &#123;<br><span class="hljs-keyword">if</span> (_ptr) &#123;<br>_count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 若_ptr指向了某个有效内存 _count引用计数为1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br>~<span class="hljs-built_in">SmartPtr</span>() &#123;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)--;<br><span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 释放指针指向的内存 释放引用计数内存</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">SmartPtr</span>(<span class="hljs-type">const</span> SmartPtr &amp;ptr) &#123; <span class="hljs-comment">// 拷贝构造：计数 +1</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;ptr) &#123;<br><span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br><span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)++;<br>&#125;<br>&#125;<br><br>SmartPtr &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SmartPtr &amp;ptr) &#123; <span class="hljs-comment">// 赋值运算符重载 </span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr == ptr._ptr) &#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr) &#123; <span class="hljs-comment">// 将当前的 ptr 指向的原来的空间的计数 -1</span><br>(*<span class="hljs-keyword">this</span>-&gt;_count)--;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>&#125;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br><span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)++; <span class="hljs-comment">// 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>T &amp;<span class="hljs-keyword">operator</span>*() &#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">return</span> *(<span class="hljs-keyword">this</span>-&gt;_ptr);<br>&#125;<br><br>T *<span class="hljs-keyword">operator</span>-&gt;() &#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;count;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>weak_ptr</strong><code>weak_ptr</code>指向<code>share_ptr</code>指向的对象，用于解决<strong>循环引用问题</strong>，那么什么是循环引用？如下代码则是一个循环引用，它们相互引用，以至于最终无法释放内存，出现内存泄漏问题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>;<br><span class="hljs-keyword">typedef</span> shared_ptr&lt;Parent&gt; parent_ptr;<br><span class="hljs-keyword">typedef</span> shared_ptr&lt;Child&gt; child_ptr;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Child</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;Child ...&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~Child ...&quot;</span> &lt;&lt; endl;&#125;<br>    parent_ptr parent_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Parent</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;Parent ...&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Parent</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~Parent ...&quot;</span> &lt;&lt; endl;&#125;<br>    child_ptr child_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">parent_ptr <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent)</span></span>;<br>    <span class="hljs-function">child_ptr <span class="hljs-title">child</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child)</span></span>;<br>    parent-&gt;child_ = child;<br>    child-&gt;parent_ = parent;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>上述代码由于类内部智能指针又对对应的类进行指向，引用计数最后均为<code>2</code>，因此当程序结束时并不会调用析构函数：<img src="media/16224350022491/16407071461330.jpg" alt="-w987" /></p><p><strong>于是我脑海里在想，当程序即将退出时，智能指针会给当前对象引用计数减<code>1</code>，可是即使两者引用计数均为<code>1</code>，为什么程序退出前不会调用析构函数呢？</strong>其实这里我的理解出现了误区，智能指针是对堆空间进行操作的，而非对栈空间操作，有时程序结束前会调用类对象析构函数是因为类对象是存放在栈上的，而智能指针所申请的指向空间为堆，因此不存在程序结束前自动调用析构函数的说法。那么正如我们所想的那样，当引用计数减<code>1</code>后，两个类对象仍然引用计数不为<code>0</code>，那么智能指针会判断，因为引用计数不为<code>0</code>，因此对堆空间不进行释放操作，那么直到程序结束都不会对这两块堆进行释放了，就出现了内存泄漏。我们可以通过<code>weak_ptr</code>来解决循环引用的问题。</p><p>我们来看对上述循环引用的代码，通过<code>weak_ptr</code>是如何解决的吧：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>;<br><span class="hljs-keyword">typedef</span> shared_ptr&lt;Parent&gt; parent_ptr;<br><span class="hljs-keyword">typedef</span> shared_ptr&lt;Child&gt; child_ptr;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Child</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;Child ...&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~Child ...&quot;</span> &lt;&lt; endl;&#125;<br>    parent_ptr parent_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Parent</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;Parent ...&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Parent</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~Parent ...&quot;</span> &lt;&lt; endl;&#125;<br>    weak_ptr&lt;Child&gt; child_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">parent_ptr <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent)</span></span>;<br>    <span class="hljs-function">child_ptr <span class="hljs-title">child</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child)</span></span>;<br>    parent-&gt;child_ = child;<br>    child-&gt;parent_ = parent;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>弱引用，顾名思义就是其所指向的内容引用计数不受到影响，上述代码给<code>Parent</code>类定义了<code>weak_ptr</code>，那该智能指针所指向的<code>Child</code>类对象引用计数不会增加，所以引用关系如下：<img src="media/16224350022491/16407072283771.jpg" alt="-w995" /></p><p>后构造的先析构，因此程序结束时<code>Child</code>类调用<code>~Child</code>析构函数，引用计数会先减为<code>0</code>，智能指针会释放掉<code>Child</code>空间及其资源如<code>parent_</code>智能指针。因此<code>Parent</code>空间的引用计数由<code>2</code>降为了<code>1</code>；接着调用<code>Parent</code>的析构函数，会给<code>Parent</code>类对象引用计数减<code>1</code>变为<code>0</code>，然后发现引用计数为<code>0</code>，智能指针回收堆空间资源。可以对上述两个类均改成<code>weak_ptr</code>智能指针，<code>weak_ptr</code>智能指针的使用技巧一般是：定义对象的时候，使用强智能指针（<code>shared_ptr</code>）；引用对象的地方，使用弱智能指针（<code>weak_ptr</code>）。</p><ul><li>强引用：只要有一个引用存在，对象就不能释放，<code>shared_ptr</code>就是强引用智能指针</li><li>弱引用：并不增加对象的引用计数，但它能知道对象是否存在，<code>weak_ptr</code>就是若引用智能指针<ul><li>如果存在，提升为<code>shared_ptr</code>（强引用）成功</li><li>如果不存在，提升失败</li></ul></li><li>通过<code>weak_ptr</code>访问对象的成员时，要提升为<code>shared_ptr</code>，因为如果没有提升，我们不能保证<code>weak_ptr</code>所引用的对象是否已经销毁了，<code>weak_ptr</code>通过<code>lock</code>方法对弱引用进行提升。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;X ...&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">X</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~X ...&quot;</span> &lt;&lt; endl;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Fun ...&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;X&gt; p; &#123;<br>        <span class="hljs-function">shared_ptr&lt;X&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> X)</span></span>;<br>        cout &lt;&lt; p2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>        p = p2;<br>        cout &lt;&lt; p2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br>        shared_ptr&lt;X&gt; p3 = p.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">//将p提升为shared_ptr</span><br>        <span class="hljs-keyword">if</span>(!p3)<br>            cout &lt;&lt; <span class="hljs-string">&quot;object is destoryed&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            p3-&gt;<span class="hljs-built_in">Fun</span>();<br>    &#125;<br><br>    shared_ptr&lt;X&gt; p4 = p.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span>(!p4)<br>        cout &lt;&lt; <span class="hljs-string">&quot;object is destoryed&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        p4-&gt;<span class="hljs-built_in">Fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码输出的结果如下： <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">X</span></span> ...<br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">Fun</span></span> ...<br>~X ...<br>object is destoryed<br></code></pre></td></tr></table></figure>通过<code>lock</code>方法，对弱引用进行提升，提升后，<code>p3</code>引用了<code>p2</code>指向的堆空间，通过<code>p3</code>这样的<code>shared_ptr</code>强引用，即可访问指向类的成员函数。</p><p>对<code>weak_ptr</code>更深入的理解： 1.说的高大上就是weak_ptr只能拥有shared_ptr的观测权，没有使用权，想要使用的时候，就将weak_ptr转为shared_ptr，这个时候新产生的shared_ptr对象是不会引起循环引用的问题，因为它在它的作用域结束后肯定要释放的，和weak_ptr所在的类对象没有任何关系了。2.有这样的想法也很正常，既然都使用shared_ptr会出现循环引用的问题，所以只要将其中某一条引用链断了就可以了，自然而然可以想到使用一个中间产品（weak_ptr），并且提供weak_ptr像shared_ptr转换的方法即可。3.查看MSVC的memory文件，可以看到shared_ptr和weak_ptr都是继承于ptr_base的，在ptr_base中存放了资源指针_Ptr以及引用计数指针_Rep，而shared_ptr类中定义了一些对资源_Ptr操作的方法，但是在weak_ptr中，只有“资源观测权”的方法：</p><p><strong>expired（查看资源是否还存在）：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">expired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return true if resource no longer exists</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">use_count</span>() == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>lock(将weak_ptr构造为shared_ptr)：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">_NODISCARD shared_ptr&lt;_Ty&gt; <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// convert to shared_ptr</span><br>shared_ptr&lt;_Ty&gt; _Ret;<br>(<span class="hljs-type">void</span>) _Ret._Construct_from_weak(*<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">return</span> (_Ret);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><ahref="https://blog.csdn.net/QIANGWEIYUAN/article/details/88562935">深入掌握C++智能指针</a></li></ul><p>关于这三个<code>C++11</code>智能指针，更多内容可参考<ahref="https://www.bilibili.com/video/BV1fK411H7CA?from=search&amp;seid=1900088587111432399">视频</a>。</p><h3id="pimplprivate-implementation或pointer-to-implementation">PIMPL(privateimplementation或pointer to implementation)</h3><h4 id="不引入pimpl技巧">不引入PIMPL技巧</h4><ol type="1"><li><strong>引入更多的头文件</strong>，降低降低编译速度（<code>main.cpp</code>中引入<code>y.h</code>中带<code>x.h</code>，<code>y.h</code>中带<code>x.h</code>，两次引入<code>x.h</code>）</li><li><strong>提高模块的耦合度</strong>（编译期，运行期），如果<code>X</code>类大小改变，<code>Y</code>依赖于<code>X</code>实现，<code>Y</code>类需要重新编译，同时没有办法用到多态</li><li><strong>降低了接口的稳定程度</strong>，对于库的使用，方法不能改变；对于库的编译，动态库的变更，客户程序不用重新编译。（<code>Y</code>依赖于<code>X</code>实现，<code>X</code>改变，<code>Y</code>类需要重新编译）</li></ol><p>示例代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//file y.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;x.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    X x_;<br>&#125;;<br> <br><span class="hljs-comment">//file y.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;y.h&quot;</span></span><br><span class="hljs-type">void</span> Y::Fun&#123; <span class="hljs-keyword">return</span> x_.<span class="hljs-built_in">Fun</span>(); &#125;<br> <br><span class="hljs-comment">//file main.cpp </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;y.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Y y;<br>    y.<span class="hljs-built_in">Fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="引入pimpl技巧">引入PIMPL技巧</h4><ol type="1"><li><code>PIMPL</code>背后的思想是<strong>把客户与所有关于类的私有部分的知识隔离开，避免其它类知道其内部结构</strong></li><li>降低编译依赖，提高重新编译速度</li><li>接口和实现隔离</li><li>降低模块的耦合度（编译期，运行期）</li><li>提高了接口的稳定程度，对于库的使用，方法不能改变；对于库的编译，动态库的变更，客户程序不用重新编译</li></ol><p>示例代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//file y.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    X x_;<br>&#125;;<br> <br><span class="hljs-comment">//file y.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;y.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;x.h&quot;</span></span><br><span class="hljs-type">void</span> Y::Fun&#123; <span class="hljs-keyword">return</span> x_-&gt;<span class="hljs-built_in">Fun</span>(); &#125;<br> <br><span class="hljs-comment">//file main.cpp </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;y.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Y y;<br>    y.<span class="hljs-built_in">Fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="流类库">流类库</h2><p>继承关系图： <img src="media/16224350022491/16355884130519.jpg"alt="-w1033" /></p><ul><li>流库具有两个平行的基类：<code>streambuf</code>和<code>ios</code>类，所有类均以两者之一作为基类</li><li><code>streambuf</code>类：提供对缓冲区的低级操作，如<strong>设置缓冲区、对缓冲区指针操作、向缓冲区存/取字符</strong></li><li><code>ios_base</code>、<code>ios</code>类：记录流状态，<strong>支持对<code>streambuf</code>的缓冲区输入/输出的格式化或非格式化转换</strong></li><li><code>stringbuf</code>类：使用串保存字符序列。扩展<code>streambuf</code>在缓冲区提取和插入的管理</li><li><code>filebuf</code>类：使用文件保存字符序列。包括打开文件；读/写、查找字符</li></ul><p>其实流类如<code>istream</code>、<code>ostream</code>等都是模版的特化，两者均继承自<code>basic_ios&lt;char&gt;</code>模版，上图<code>ios</code>类是<code>basic_ios&lt;char&gt;</code>模版的特化，<code>STL</code>库中流类部分定义如下供参考：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// Base class for @c char streams.</span><br><span class="hljs-keyword">typedef</span> basic_ios&lt;<span class="hljs-type">char</span>&gt; ios;<br><br><span class="hljs-comment">/// Base class for @c char input streams.</span><br><span class="hljs-keyword">typedef</span> basic_istream&lt;<span class="hljs-type">char</span>&gt; istream;<br><br><span class="hljs-comment">/// Base class for @c char output streams.</span><br><span class="hljs-keyword">typedef</span> basic_ostream&lt;<span class="hljs-type">char</span>&gt; ostream;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _CharT, <span class="hljs-keyword">typename</span> _Traits&gt;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">basic_istream</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> basic_ios&lt;_CharT, _Traits&gt;<br>  &#123;...&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _CharT, <span class="hljs-keyword">typename</span> _Traits&gt;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">basic_istream</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> basic_ios&lt;_CharT, _Traits&gt;<br>  &#123;...&#125;;<br></code></pre></td></tr></table></figure></p><p><strong>打开文件</strong>（看很多资料有第三个参数，但是在<code>Linux C++ STL</code>中看到无第三个参数保护模式，保护模式应该是应用在<code>windows</code>系统下的；总之如果在<code>linux</code>平台，还是使用<code>Linux</code>系统调用最好）<del><code>void open(const char *filename, int mode = ios::out, int prot = _SH_DENYNO );</code></del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> mode = ios::out)</span></span>;<br></code></pre></td></tr></table></figure><p>参数: * <code>filename</code>：文件名，可包含绝对/相对路径 *<code>mode</code>：文件打开模式 *<del><code>prot</code>：保护模式</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ofstream fout;<br>fout.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br></code></pre></td></tr></table></figure><p>这里的打开文件可不指定<code>openmode</code>，默认以<code>ios::out</code>方式打开，即打开一个供写入的文件，若不存在则自动创建一个，我们看源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* __s, ios_base::openmode __mode = ios_base::out)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_M_filebuf.<span class="hljs-built_in">open</span>(__s, __mode | ios_base::out))<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setstate</span>(ios_base::failbit);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span><br>        <span class="hljs-comment">// 409. Closing an fstream should clear error state</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; __s, ios_base::openmode __mode = ios_base::out)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_M_filebuf.<span class="hljs-built_in">open</span>(__s, __mode | ios_base::out))<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setstate</span>(ios_base::failbit);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span><br>        <span class="hljs-comment">// 409. Closing an fstream should clear error state</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>看源码发现<code>ios_base::openmode __mode = ios_base::out</code>，即默认打开一个供写入的文件，其实，<code>ios::out</code>和<code>ios_base::out</code>是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ifstream fin;<br>fin.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;text.txt&quot;</span>);<br></code></pre></td></tr></table></figure><p>对于一个<code>ifstream</code>类对象，若要打开文件，默认的<code>mode</code>为<code>ios_base::in</code>，如果不存在该文件，则通过<code>is_open</code>判断打开失败，<code>ifstream</code>类对象的<code>open</code>源码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* __s, ios_base::openmode __mode = ios_base::in)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_M_filebuf.<span class="hljs-built_in">open</span>(__s, __mode | ios_base::in))<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setstate</span>(ios_base::failbit);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span><br>        <span class="hljs-comment">// 409. Closing an fstream should clear error state</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; __s, ios_base::openmode __mode = ios_base::in)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_M_filebuf.<span class="hljs-built_in">open</span>(__s, __mode | ios_base::in))<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setstate</span>(ios_base::failbit);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span><br>        <span class="hljs-comment">// 409. Closing an fstream should clear error state</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>判断文件打开，有以下几种方式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(fout.<span class="hljs-built_in">is_open</span>()) <span class="hljs-comment">// 判断文件流是否打开 打开则返回true</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;success&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;failed&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span>(fout.<span class="hljs-built_in">good</span>()) <span class="hljs-comment">// 判断文件是否打开</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;success&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;failed&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span>(fout)<br>    cout &lt;&lt; <span class="hljs-string">&quot;success&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;failed&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span>(!fout)<br>    cout &lt;&lt; <span class="hljs-string">&quot;failed&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;success&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-built_in">assert</span>(fout);<br></code></pre></td></tr></table></figure></p><p>这里比较不太好理解的是，<code>fout</code>这样一个<code>ofstream</code>类对象为何可以作为<code>if</code>语句中的判断条件？<code>ofstream</code>这个模版的特化继承自<code>ios</code>类，而<code>ios</code>类又是<code>basic_ios</code>模版类的特化，在<code>basic_ios</code>模版类中有以下实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L <span class="hljs-comment">// C++11以后</span></span><br>      <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">fail</span>(); &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">// C++11以前</span></span><br>      <span class="hljs-keyword">operator</span> <span class="hljs-type">void</span>*() <span class="hljs-type">const</span><br>      &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">fail</span>() ? <span class="hljs-number">0</span> : <span class="hljs-built_in">const_cast</span>&lt;basic_ios*&gt;(<span class="hljs-keyword">this</span>); &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><p>可以看到<code>basic_ios</code>模版类在<code>C++11</code>以前重载了<code>void *</code>类型（失败返回<code>0</code>，成功返回对象<code>this</code>指针），在<code>C++11</code>以后重载了<code>bool()</code>类型。因此可以作为判断条件。</p><p>文件打开模式： <imgsrc="media/16224350022491/16356851677146.jpg" /></p><p>关于文件打开的几点说明： *文件打开也可以通过构造函数打开，例如：<code>ofstream fout("out.txt", ios::out);</code>*文件的打开方式可以为上述的一个枚举常量，也可为多个枚举常量按位或表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">_Ios_Openmode</span>  <span class="hljs-comment">//文件打开方式是一个枚举类型 多个枚举常量可进行按位或运算</span><br>&#123; <br>  _S_app = <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">0</span>,<br>  _S_ate = <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">1</span>,<br>  _S_bin = <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">2</span>,<br>  _S_in = <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">3</span>,<br>  _S_out = <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">4</span>,<br>  _S_trunc = <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">5</span>,<br>  _S_ios_openmode_end = <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">16</span>,<br>  _S_ios_openmode_max = __INT_MAX__,<br>  _S_ios_openmode_min = ~__INT_MAX__<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>使用<code>open</code>成员函数打开一个文件时，若是<code>ofstream</code>类型，由字符指针参数所指定的文件不存在，则创建一个文件，若是<code>ifstream</code>类型，打开一个文件，文件不存在则不会创建文件，并且打开文件失败。</li><li>当打开方式中不含有<code>ios::ate</code>或<code>ios::app</code>选项时，则文件指针被自动移动到文件的开始位置，即字节地址为<code>0</code>的位置。</li><li>从效果上看<code>ofstream</code>制定<code>out</code>模式等同于指定了<code>out</code>和<code>trunc</code>模式。</li><li>默认情况下，<code>fstream</code>对象以<code>in</code>和<code>out</code>模式同时打开。</li><li>当文件同时以<code>in</code>和<code>out</code>打开时不会清空。</li><li>如果只使用<code>out</code>模式，而不指定<code>in</code>模式，则文件会清空现有数据。</li><li>如果同时指定了<code>out</code>与<code>app</code>，不会清空。</li><li>如果打开文件时指定了<code>trunc</code>模式，则无论是否同时指定了<code>in</code>模式，文件同样会被清空。</li></ul><p><code>ofstream</code>默认打开文件是<strong>以文本的方式</strong>进行的，写入字符时若遇到<code>\n</code>，会作相应转换，写入<code>\r</code>不作转换；<code>ofstream</code>若以二进制形式打开文件，写入字符<code>\n</code>则不会做转换。以下为<code>ofstream</code>以文本方式打开文件时，不同平台的转换方式：* <code>Windows</code>：<code>\n</code>转换为<code>\r\n</code> *<code>Linux</code>：<code>\n</code>不做转换 *<code>MacOS</code>：<code>\n</code>转为<code>\r</code></p><p>以文本方式打开文件也可写入二进制数据，以二进制方式打开文件也可写入文本；写入的数据是二进制还是文本，这与打开方式无关，与写入使用的函数有关，要写入二进制数据，应该用<code>write</code>，读二进制数据，应该用<code>read</code>。打开方式只会影响写入<code>\n</code>后是否作转换。</p><p>字符串流<code>stringstream</code>，这个类型着重说明一下，可用于处理字符串，比如我要提取一串字符，将空格晒出掉，我可以这么做：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stringstream ss;<br>string line;<br>string word;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(cin, line)) &#123;<br>    ss.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//若不清理 ss始终存放的是第一次写入的值</span><br>    ss &lt;&lt; line;<br>    <span class="hljs-keyword">while</span>(ss &gt;&gt; word)<br>        cout &lt;&lt; word;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>我们的输入为： <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> a b c<br></code></pre></td></tr></table></figure> 通过上述方法，得到的输出为：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">123456</span><span class="hljs-keyword">abc</span><br></code></pre></td></tr></table></figure></p><p>所以，<code>stringstream</code>在刷题时还是非常有用的，特此记录。然后就是进制的输出，直接看下面的例子即可，在输出的字面值前加上<code>hex</code>、<code>dec</code>、<code>oct</code>等（需要注意<code>C++</code>无直接输出二进制的方式，需要手动实现）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = <span class="hljs-number">14</span>;<br><span class="hljs-comment">//oct 8进制</span><br><span class="hljs-comment">//dec 10进制</span><br><span class="hljs-comment">//hex 16进制</span><br>cout &lt;&lt; hex &lt;&lt; n &lt;&lt; endl; <span class="hljs-comment">//e</span><br>cout &lt;&lt; dec &lt;&lt; n &lt;&lt; endl; <span class="hljs-comment">//14</span><br>cout &lt;&lt; oct &lt;&lt; n &lt;&lt; endl; <span class="hljs-comment">//16</span><br>cout &lt;&lt; n &lt;&lt; endl; <span class="hljs-comment">//16</span><br></code></pre></td></tr></table></figure> 以下为常用流操纵算子： <imgsrc="media/16224350022491/16357676063345.jpg" /></p><p>其余的<code>C++</code>文件操作方法使用时参考手册即可。</p><hr /><h2 id="模板">模板</h2><h4 id="函数模板">函数模板</h4><p>函数模板形式如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;模板形参表&gt;<br>返回值类型 函数名(模板函数形参表) &#123;<br>    ... <span class="hljs-comment">//函数定义体</span><br>&#125;<br></code></pre></td></tr></table></figure>模板形参类型为<code>class</code>或<code>typename</code>。关键字<code>typename</code>在<code>C++98</code>标准发展过程中引入的较晚，在那之前，关键字<code>class</code>是唯一可以用来定义类型参数的方法，而且目前这一方法依然有效，推荐使用<code>typename</code>。</p><p>函数模板不是函数，不能被执行，函数模板需要被实例化为模板函数，才可被执行，其实例化的过程在编译期进行。模板被编译两次，第一次在实例化之前，先检查模板代码本身，查看语法是否正确；在这里会发现语法错误，如遗漏分号等。第二次在实例化期间，检查模板代码，查看是否所有的调用都有效。在这里会发现无效的调用，如该实例化类型不支持某些函数调用等。相比于函数模板，普通函数只需要声明，即可顺利编译，而模板的编译需要查看模板的定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b ? b : a;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述例子，可以传入任意<code>T</code>类型参数，但是需要注意：<strong>类型<code>T</code>必须支持小于运算符</strong>，因为<code>a</code>和<code>b</code>在做比较的时候用到了它，<strong>例子中还有一个不太容易看出的点是，为了支持返回值，<code>T</code>应该是可拷贝的</strong>。</p><p><strong>在学习使用模板的时候，有时需要提供模版特化</strong>，比如现在定义了一个<code>max</code>模版如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">const</span> T &amp;<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a, <span class="hljs-type">const</span> T &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b ? b : a;<br>&#125;<br></code></pre></td></tr></table></figure>那么首先，这个时候如果要对字符、整数、浮点类型等常规类型进行比较，直接传入即可，但如果是对一个自定义类类型呢？我们需要在该类中支持<code>&lt;</code>号比较，因此需要在该类中进行<code>&lt;</code>重载，比如下面的代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Test &amp;t1, <span class="hljs-type">const</span> Test &amp;t2) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br></code></pre></td></tr></table></figure></p><p>这里使用成员函数方式重载会报错，具体原因我也不清楚，我又去复习了下重载的内容，里面这样说道：</p><blockquote><p>一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。这些双目运算符不能重载为类的友元函数：=、()、[]、-&gt;，类型转换运算符只能以成员函数方式重载，流运算符&lt;&lt;、&gt;&gt;等只能以友元的方式重载</p></blockquote><p>勉强认为，对于<code>&lt;</code>这样的双目运算符，我们采用友元的方式对其进行重载，那么接下来则是重点，来看下面的代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// cout &lt;&lt; ::max(&quot;aaa&quot;, &quot;zzz&quot;) &lt;&lt; endl; //我们发现&quot;aaa&quot;居然比&quot;zzz&quot;大，是因为这里没有比较字符串，而是比较指针地址的大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str1 = <span class="hljs-string">&quot;aaa&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str2 = <span class="hljs-string">&quot;zzz&quot;</span>;<br>cout &lt;&lt; ::<span class="hljs-built_in">max</span>(str1, str2) &lt;&lt; endl;<br>cout &lt;&lt; ::<span class="hljs-built_in">max</span>(str2, str2) &lt;&lt; endl;<br></code></pre></td></tr></table></figure>此时，<strong>上述代码想要实现对字符串的比较，于是我进行如上操作，但实际上上述操作是错误的，其比较的是两个字符串对应指针地址的大小</strong>，那么若要真正意义上实现对字符串的比较，我们就要用到前面提到的<strong>模板特化</strong>，在我们的<code>max</code>模板下面进行函数模板特化：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">const</span> T &amp;<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a, <span class="hljs-type">const</span> T &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b ? b : a;<br>&#125;<br><br><span class="hljs-comment">//函数模板特化</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> &amp;<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> &amp;a, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(a, b) &lt; <span class="hljs-number">0</span> ? b : a;<br>&#125;<br></code></pre></td></tr></table></figure>如上模板特化，用于比较两个指针所指字符串，解决了指针地址大小之间相互比较的问题。</p><p>接下来，若要对模板进行扩展，我们可以对<strong>函数模板重载</strong>，具体重载对比代码如下，需要注意在调用原先代码时，需要加上作用域（命名空间）<code>::</code>，因为此处的模板<code>max</code>与<code>std</code>中的<code>max</code>重名了：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">const</span> T &amp;<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a, <span class="hljs-type">const</span> T &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b ? b : a;<br>&#125;<br><br><span class="hljs-comment">//函数模板重载</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">const</span> T &amp;<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a, <span class="hljs-type">const</span> T &amp;b, <span class="hljs-type">const</span> T &amp;c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">max</span>(a, b) &lt; c ? c : ::<span class="hljs-built_in">max</span>(a, b);<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="类模板">类模板</h4><p>我们直接通过类模板实现一个简单的<code>Stack</code>，代码分为两部分，一部分为<code>Stack.h</code>，其内部则是对<code>Stack</code>模板的实现；另一部分是<code>main.cpp</code>，其内部主要是测试代码。那我们来看一下代码实现吧：<strong>Stack.h：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _STACK_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _STACK_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Stack</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span></span>;<br>    ~<span class="hljs-built_in">Stack</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;elem)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">T &amp;<span class="hljs-title">Top</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> T &amp;<span class="hljs-title">Top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    T *elems_;<br>    <span class="hljs-type">int</span> maxSize_;<br>    <span class="hljs-type">int</span> top_;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>Stack&lt;T&gt;::<span class="hljs-built_in">Stack</span>(<span class="hljs-type">int</span> maxSize) : <span class="hljs-built_in">maxSize_</span>(maxSize), <span class="hljs-built_in">top_</span>(<span class="hljs-number">-1</span>) &#123;<br>    elems_ = <span class="hljs-keyword">new</span> T[maxSize_];<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>Stack&lt;T&gt;::~<span class="hljs-built_in">Stack</span>() &#123;<br>    <span class="hljs-keyword">delete</span> []elems_;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Stack&lt;T&gt;::<span class="hljs-built_in">Push</span>(<span class="hljs-type">const</span> T &amp;elem) &#123;<br>    <span class="hljs-keyword">if</span>(top_ + <span class="hljs-number">1</span> &gt;= maxSize_)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::Push() stack full&quot;</span>);<br>    elems_[++top_] = elem;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Stack&lt;T&gt;::<span class="hljs-built_in">Pop</span>() &#123;<br>    <span class="hljs-keyword">if</span>(top_ + <span class="hljs-number">1</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::Pop() stack empty&quot;</span>);<br>    --top_;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T &amp;Stack&lt;T&gt;::<span class="hljs-built_in">Top</span>() &#123;<br>    <span class="hljs-keyword">if</span>(top_ + <span class="hljs-number">1</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::Top() stack empty&quot;</span>);<br>    <span class="hljs-keyword">return</span> elems_[top_];<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">const</span> T &amp;Stack&lt;T&gt;::<span class="hljs-built_in">Top</span>() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(top_ + <span class="hljs-number">1</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::Top() stack empty&quot;</span>);<br>    <span class="hljs-keyword">return</span> elems_[top_];<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">bool</span> Stack&lt;T&gt;::<span class="hljs-built_in">Empty</span>() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> top_ + <span class="hljs-number">1</span> == <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><p><strong>main.cpp：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Stack.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Stack&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    s.<span class="hljs-built_in">Push</span>(<span class="hljs-number">1</span>);<br>    s.<span class="hljs-built_in">Push</span>(<span class="hljs-number">2</span>);<br>    s.<span class="hljs-built_in">Push</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">Empty</span>()) &#123;<br>        cout &lt;&lt; s.<span class="hljs-built_in">Top</span>() &lt;&lt; endl;<br>        s.<span class="hljs-built_in">Pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>我们发现，其实创建类对象时调用构造函数，还要对<code>maxSize_</code>进行创建，但是这样写很丑，我们完全可以将长度这种非类型参数传递给模板，因此诞生了以下实现，我们分别命名为<code>Stack2.h</code>和<code>main2.cpp</code>：<strong>Stack2.h：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _STACK2_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _STACK2_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAX_SIZE&gt; <span class="hljs-comment">//此处第二个参数为非类型参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack2</span>();<br>    ~<span class="hljs-built_in">Stack2</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;elem)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">T &amp;<span class="hljs-title">Top</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> T &amp;<span class="hljs-title">Top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    T *elems_;<br>    <span class="hljs-type">int</span> top_;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAX_SIZE&gt;<br>Stack2&lt;T, MAX_SIZE&gt;::<span class="hljs-built_in">Stack2</span>() : <span class="hljs-built_in">top_</span>(<span class="hljs-number">-1</span>) &#123;<br>    elems_ = <span class="hljs-keyword">new</span> T[MAX_SIZE];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAX_SIZE&gt;<br>Stack2&lt;T, MAX_SIZE&gt;::~<span class="hljs-built_in">Stack2</span>() &#123;<br>    <span class="hljs-keyword">delete</span> []elems_;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAX_SIZE&gt;<br><span class="hljs-type">void</span> Stack2&lt;T, MAX_SIZE&gt;::<span class="hljs-built_in">Push</span>(<span class="hljs-type">const</span> T &amp;elem) &#123;<br>    <span class="hljs-keyword">if</span>(top_ + <span class="hljs-number">1</span> &gt;= MAX_SIZE)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack2&lt;&gt;::Push() stack full&quot;</span>);<br>    elems_[++top_] = elem;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAX_SIZE&gt;<br><span class="hljs-type">void</span> Stack2&lt;T, MAX_SIZE&gt;::<span class="hljs-built_in">Pop</span>() &#123;<br>    <span class="hljs-keyword">if</span>(top_ + <span class="hljs-number">1</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack2&lt;&gt;::Pop() stack empty&quot;</span>);<br>    --top_;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAX_SIZE&gt;<br>T &amp;Stack2&lt;T, MAX_SIZE&gt;::<span class="hljs-built_in">Top</span>() &#123;<br>    <span class="hljs-keyword">if</span>(top_ + <span class="hljs-number">1</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack2&lt;&gt;::Top() stack empty&quot;</span>);<br>    <span class="hljs-keyword">return</span> elems_[top_];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAX_SIZE&gt;<br><span class="hljs-type">const</span> T &amp;Stack2&lt;T, MAX_SIZE&gt;::<span class="hljs-built_in">Top</span>() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(top_ + <span class="hljs-number">1</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack2&lt;&gt;::Top() stack empty&quot;</span>);<br>    <span class="hljs-keyword">return</span> elems_[top_];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAX_SIZE&gt;<br><span class="hljs-type">bool</span> Stack2&lt;T, MAX_SIZE&gt;::<span class="hljs-built_in">Empty</span>() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> top_ + <span class="hljs-number">1</span> == <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><p><strong>main2.cpp：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Stack2.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Stack2&lt;<span class="hljs-type">int</span>, <span class="hljs-number">10</span>&gt; s;<br>    s.<span class="hljs-built_in">Push</span>(<span class="hljs-number">1</span>);<br>    s.<span class="hljs-built_in">Push</span>(<span class="hljs-number">2</span>);<br>    s.<span class="hljs-built_in">Push</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">Empty</span>()) &#123;<br>        cout &lt;&lt; s.<span class="hljs-built_in">Top</span>() &lt;&lt; endl;<br>        s.<span class="hljs-built_in">Pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过以上代码，我们得出结论：<strong>对于函数模板与类模板，模板参数并不局限于类型，普通值也可以作为模板参数</strong>。</p><h4 id="默认缺省参数模板">默认缺省参数模板</h4><p>其实模板也可以传递默认缺省参数，如果要实现一个<code>Stack</code>，我们也可在其内部使用默认的模板如<code>deque</code>、<code>vector</code>等，现在我们通过缺省参数为<code>deque</code>的模板来实现一个<code>Stack</code>模板，代码如下：<strong>Stack.h：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _STACK_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _STACK_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> CONT = deque&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> Stack &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Stack</span>() &#123;&#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-built_in">Push</span>(<span class="hljs-type">const</span> T &amp;elem) &#123;c_.<span class="hljs-built_in">push_back</span>(elem);&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> </span>&#123;c_.<span class="hljs-built_in">pop_back</span>();&#125;<br>    <span class="hljs-function">T &amp;<span class="hljs-title">Top</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> c_.<span class="hljs-built_in">back</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> T &amp;<span class="hljs-title">Top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> c_.<span class="hljs-built_in">back</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> c_.<span class="hljs-built_in">empty</span>();&#125;<br><span class="hljs-keyword">private</span>:<br>    CONT c_; <span class="hljs-comment">//container</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><p><strong>main.cpp：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Stack.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//Stack&lt;int&gt; s;</span><br>    Stack&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; s;<br>    s.<span class="hljs-built_in">Push</span>(<span class="hljs-number">1</span>);<br>    s.<span class="hljs-built_in">Push</span>(<span class="hljs-number">2</span>);<br>    s.<span class="hljs-built_in">Push</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">Empty</span>()) &#123;<br>        cout &lt;&lt; s.<span class="hljs-built_in">Top</span>() &lt;&lt; endl;<br>        s.<span class="hljs-built_in">Pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>我们的测试代码<code>main.cpp</code>中创建的<code>Stack</code>模板实例化对象内也可传递<code>vector&lt;int&gt;</code>这样的具有<code>push_back</code>、<code>pop_back</code>、<code>back</code>、<code>empty</code>等的模板，因为在<code>Stack.h</code>中，对各个接口的实现用到了缺省参数<code>deque</code>的以上几种函数，若传递新的模板，则必须支持这些函数才可以，通过对以上代码的编写，我们称<code>Stack</code>这个类为适配器，这是<code>STL</code>的六大组件之一，代码复用，不是通过继承，而是通过适配。其实我们查看<code>STL</code>中的<code>stack</code>实现，会发现其内部也是以适配器的形式来实现的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Sequence = deque&lt;_Tp&gt; &gt;<br>    <span class="hljs-keyword">class</span> stack<br>    &#123;...&#125;;<br></code></pre></td></tr></table></figure></p><h4 id="成员模板">成员模板</h4><p>现在我们写了一个类模板<code>MyClass</code>，想要调用实例化对象成员函数进行赋值操作，但对不同类型的代码，赋值操作是无法执行的，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Assign</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&lt;T&gt; &amp;x)</span> </span>&#123;<br>        value = x.value;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    T value;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;<span class="hljs-type">double</span>&gt; d1;<br>    MyClass&lt;<span class="hljs-type">double</span>&gt; d2;<br>    MyClass&lt;<span class="hljs-type">int</span>&gt; i;<br><br>    d1.<span class="hljs-built_in">Assign</span>(d2);  <span class="hljs-comment">//OK</span><br>    d1.<span class="hljs-built_in">Assign</span>(i);   <span class="hljs-comment">//ERROR i为int d1为double</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>我们发现上述代码中，<code>d1</code>和<code>d2</code>是两个同<code>double</code>类型的模板类对象，<code>i</code>则是<code>int</code>类型的模板类对象，在传递参数调用<code>Assign</code>类方法时，同类之间则可以进行调用，但不同类型间则无法进行该操作。这是我们就需要在模板类中定义成员模板，即模板成员函数，该模板类型可与类模板类型不同，我们看下面代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Assign</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&lt;X&gt; &amp;x)</span> </span>&#123;<br>        value = x.<span class="hljs-built_in">GetValue</span>();<br>    &#125;<br>    <span class="hljs-function">T <span class="hljs-title">GetValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> value;&#125;<br><span class="hljs-keyword">private</span>:<br>    T value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;<span class="hljs-type">double</span>&gt; d1;<br>    MyClass&lt;<span class="hljs-type">double</span>&gt; d2;<br>    MyClass&lt;<span class="hljs-type">int</span>&gt; i;<br><br>    d1.<span class="hljs-built_in">Assign</span>(d2); <span class="hljs-comment">//OK</span><br>    d1.<span class="hljs-built_in">Assign</span>(i); <span class="hljs-comment">//OK</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="模板的完全特化和部分特化">模板的完全特化和部分特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Vector</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;call Vector template init&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 下面这个是对char *类型提供的完全特例化版本</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-type">char</span> *&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Vector</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;char *&gt; init&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 对所有指针类型提供的部分特例化版本</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;T *&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Vector</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;T *&gt; init&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 函数指针（有返回值，有两个形参变量）提供的部分特例化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> A1, <span class="hljs-keyword">typename</span> A2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-built_in">R</span>(*)(A1, A2)&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Vector</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;R(*)(A1, A2)&gt; init&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-comment">//函数类型（有返回值，有两个形参变量）提供的部分特例化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> A1, <span class="hljs-keyword">typename</span> A2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-built_in">R</span>(A1, A2)&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Vector</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;R(A1, A2)&gt; init&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a + b;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Vector&lt;<span class="hljs-type">int</span>&gt; vec1;               <span class="hljs-comment">// call Vector template init</span><br>    Vector&lt;<span class="hljs-type">char</span> *&gt; vec2;            <span class="hljs-comment">// call Vector&lt;char *&gt; init</span><br>    Vector&lt;<span class="hljs-type">int</span> *&gt; vec3;             <span class="hljs-comment">// call Vector&lt;T *&gt; init</span><br>    Vector&lt;<span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; vec4;  <span class="hljs-comment">// call Vector&lt;R(*)(A1, A2)&gt; init</span><br>    Vector&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; vec5;     <span class="hljs-comment">// call Vector&lt;R(A1, A2)&gt; init</span><br><br><br>    <span class="hljs-comment">//注意区分函数类型和函数指针类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span><span class="hljs-params">(*PFUNC1)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br>    PFUNC1 pfunc = sum;<br>    cout &lt;&lt; <span class="hljs-built_in">pfunc</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title">PFUNC2</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br>    PFUNC2 *pfunc2 = sum;<br>    cout &lt;&lt; (*pfunc2)(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果未能匹配到完全特例化版本，则开始匹配部分特例化版本，若两者均为匹配到则开始匹配普通模板。</p><h4 id="关键字typename">关键字typename</h4><p>如果一条语句，我们想定义某个模板类型的指针，比如这样<code>T::SubType *ptr</code>，但是编译器会认为<code>T::SubType</code>可能是<code>T</code>作用域下的静态数据成员<code>SubType</code>乘以变量<code>ptr</code>，这显然不符合我们想要的预期，因此我们通过<code>typename</code>关键字，告知<code>T::SubType</code>是一个类型，我们来看一下如下代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typename</span> T::SubType *ptr_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SubType;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;Test&gt; mc;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>当主函数中要实例化一个模板对象时，传递的是<code>Test</code>类，我们发现在模板类<code>MyClass</code>中声明指针<code>ptr</code>的类型为<code>T::SubType</code>类型，那么在<code>MyClass</code>中传递自定义类时，该类下需要有对应的<code>SubType</code>类型定义，于是我们需要在<code>Test</code>类中进行<code>typedef</code>。</p><p>还有如下例子，也是我在编程实践中发现的，定义<code>Container::iterator</code>时，不加<code>typename</code>关键字，有可能被编译器理解为<code>Container</code>命名空间下的<code>iterator</code>变量，所以<code>typename</code>关键字告知编译器<code>Container::iterator</code>为一个类型而非变量，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showContainer</span><span class="hljs-params">(Container &amp;con)</span> </span>&#123;<br>    <span class="hljs-keyword">typename</span> Container::iterator it = con.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//如果不加typename 编译器不知是类型还是变量</span><br>    <span class="hljs-keyword">for</span>(; it != con.<span class="hljs-built_in">end</span>(); ++it)<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)<br>        vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">showContainer</span>(vec);<br>    <span class="hljs-comment">// sort(vec.begin(), vec.end(), greater&lt;int&gt;());</span><br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)-&gt;<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> left &gt; right;&#125;);<br>    <span class="hljs-built_in">showContainer</span>(vec);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>派生类和模板</strong>：为了运行的效率，类模板是相互独立的，即独立设计，没有使用继承的思想，对类模板的扩展是采用适配器（<code>Adapter</code>）来完成的。通用性是模板库的设计出发点之一，这是由泛型算法和函数对象等手段达到的。派生类的目标之一也是代码的复用和程序的通用性，最典型的就是<code>MFC</code>，派生类的优点是可以由简到繁，逐步深入，程序编制过程中可以充分利用前面的工作，一步步完成一个复杂的任务。<strong>模板追求的是运行效率，而派生追求的是编程的效率</strong>。</p><p><strong>面向对象和泛型编程</strong>：面向对象与泛型编程依赖于某种形式的多态，其中<strong>面向对象是一种动态多态</strong>，通过虚函数实现多态，函数的入口地址是在运行时刻才决定的，其效率相对模板来说较低；<strong>泛型编程采用的是一种静态多态</strong>，通过模板实现多态，在编译时刻实例化出模板函数或模板类，函数的入口也是在编译期就决定了，而非运行时刻才决定。面向对象中的多态在运行时应用存在继承关系。我们编写使用这些类的代码，忽略基类与派生类之间的类型差异。只要使用基类指针或者引用，基类类型对象、派生类类型对象就可以共享相同代码。在泛型编程中，我们所编写的类和函数能够多态地用于编译时不相关的类型。一个类或一个函数可以用来操纵多种类型的对象。</p><table style="width:4%;"><thead><tr class="header"><th>## STL ## C++标准模板库 - 标准容器 - 顺序容器 vector/deque/list -容器适配器 stack/queue/priority_queue - 关联容器 - 无序关联容器unordered_set/unordered_multiset/unordered_map/unordered_multimap -有序关联容器 set/multiset/map/multimap - 近容器 数组/string/bitset -迭代器 iterator/const_iteratorreverse_iterator/const_reverse_iterator</th></tr></thead><tbody><tr class="odd"><td>STL组件： * <code>Container（容器）</code>：各种基本数据结构 *<code>Adapter（适配器）</code>：可改变<code>Containers</code>、<code>Iterators</code>或<code>Function object</code>接口的一种组件*<code>Algorithm（算法）</code>：各种基本算法如<code>sort</code>、<code>search</code>...等*<code>Iterator（迭代器）</code>：连接<code>Containers</code>和<code>Algorithms</code>* <code>Function object（函数对象）</code> *<code>Allocator（分配器）</code></td></tr><tr class="even"><td><code>STL</code>容器中，提供了七种最基本的容器：向量<code>vector</code>、双端队列<code>deque</code>、列表<code>list</code>、集合<code>set</code>、多重集合<code>multiset</code>、映射<code>map</code>和多重映射<code>multimap</code>。其中<strong>前三个是序列式容器<code>Sequence containers</code></strong>：其中每个元素均有固定位置，取决于插入时机和地点，和元素值无关。<strong>后四个为关联式容器<code>Associative containers</code></strong>：元素位置取决于特定的排序准则以及元素值，和插入次序无关。</td></tr><tr class="odd"><td><strong>如何选择序列式容器？</strong> *需要频繁在序列中间位置上进行插入或删除操作且不需要过多地在序列内部进行长距离跳转，应该选择<code>list</code>* <code>vector</code>头部与中间插入删除效率较低，在尾部插入与删除效率高* <code>deque</code>是在头部与尾部插入与删除效率较高</td></tr><tr class="even"><td><strong>迭代器</strong> *迭代器<code>Iterators</code>用来在一个对象群集（<code>collection of objects</code>）的元素上进行遍历。这个对象群集或许是个容器，或许是容器的一部分。迭代器的主要好处是为所欲容器提供了一组很小的公共接口。迭代器以<code>++</code>进行累进，以<code>*</code>进行提领，因而它类似于指针，我们可以把它视为一种智能指针*比如<code>++</code>操作可以遍历至群集内的下一个元素。至于如何做到，取决于容器内部的数据组织形式。*每种容器都提供了自己的迭代器，而这些迭代器能够了解容器内部的数据结构。</td></tr><tr class="odd"><td><strong>算法</strong> *算法<code>Algorithms</code>用来处理群集内的元素。它们可以出于不同的目的而搜寻、排序、修改、使用那些元素。通过迭代器的协助，我们可以只需编写一次算法，就可以将它应用于任意容器，这是因为所有的容器迭代器都提供一致的接口。</td></tr><tr class="even"><td><strong>适配器</strong> * 适配器是一种接口类 -为已有的类提供新的接口 -目的是简化、约束、使之安全、隐藏或者改变被修改类提供的服务集合 *三种类型的适配器 -<strong>容器适配器</strong>：用来扩展7种基本容器，他们和顺序容器相结合构成栈、队列和优先队列容器-<strong>迭代器适配器</strong>（反向迭代器、插入迭代器、<code>IO</code>流迭代器）-<strong>函数适配器</strong>（函数对象适配器、成员函数适配器、普通函数适配器）</td></tr><tr class="odd"><td>## 顺序容器-vector源码分析 ### vector基类介绍当在函数中调用<code>vector&lt;int&gt; v;</code>这样的语句去创建对象<code>v</code>时，会调用其无参构造函数，进入类模板的定义，我们可以看到下面代码类模板的定义有两个类型，一个是要传入的类型参数<code>_Tp</code>，另一个是<code>_Alloc</code>，后者是一个类模板，即<code>std::allocator&lt;_Tp&gt;</code>，我们称之为内存分配子。下面代码即为<code>vector</code>类模板。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//两个模板参数，第一个是数据类型，第二个std::allocator是标准库中动态内存分配器，最终其实是调用了new运算符</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;<br>  <span class="hljs-keyword">class</span> vector : <span class="hljs-keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;<br>  &#123;...&#125;<br></code></pre></td></tr></table></figure>从源码的实现来看，其实<code>vector</code>是一个模板派生类，也就是说，它首先是一个模板类，这一点我们应该都猜得到，毕竟我们使用的时候都是使用形如<code>vector&lt;int&gt;</code>这样的形式来进行声明一个vector对象的，其次它是一个派生类，它的基类是<code>_Vector_base</code>，所以我们首先来看一下这个基类的实现。</td></tr><tr class="even"><td>&gt;可以看到这里vector继承基类时是protected，这个过程我们称为保护继承，保护继承的特点是：基类的公有成员在派生类中也成为了保护成员，基类的保护成员和私有成员在派生类中使用权限与基类一致，保持不变。</td></tr><tr class="odd"><td>当创建对象<code>v</code>并调用其无参构造函数时，<code>gdb</code>调试过程如下，可大致看一下调用的过程：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Temporary breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at <span class="hljs-number">01.</span>cpp:<span class="hljs-number">6</span><br><span class="hljs-number">6</span>           vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br>std::vector&lt;<span class="hljs-type">int</span>, std::allocator&lt;<span class="hljs-type">int</span>&gt; &gt;::<span class="hljs-built_in">vector</span> (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdf20</span>)<br>    at /usr/include/c++/<span class="hljs-number">8</span>/bits/stl_vector.h:<span class="hljs-number">395</span><br><span class="hljs-number">395</span>           : _Base() &#123; &#125;<br><br>std::_Vector_base&lt;<span class="hljs-type">int</span>, std::allocator&lt;<span class="hljs-type">int</span>&gt; &gt;::_Vector_base (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdf20</span>)<br>    at /usr/include/c++/<span class="hljs-number">8</span>/bits/stl_vector.h:<span class="hljs-number">249</span><br><span class="hljs-number">249</span>           : _M_impl() &#123; &#125;<br><br>std::_Vector_base&lt;<span class="hljs-type">int</span>, std::allocator&lt;<span class="hljs-type">int</span>&gt; &gt;::_Vector_impl::_Vector_impl (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdf20</span>)<br>    at /usr/include/c++/<span class="hljs-number">8</span>/bits/stl_vector.h:<span class="hljs-number">96</span><br><span class="hljs-number">96</span>              : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()<br><br>std::allocator&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">allocator</span> (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdf20</span>) at /usr/include/c++/<span class="hljs-number">8</span>/bits/allocator.h:<span class="hljs-number">131</span><br><span class="hljs-number">131</span>           <span class="hljs-built_in">allocator</span>() <span class="hljs-keyword">throw</span>() &#123; &#125;<br><br>__gnu_cxx::new_allocator&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">new_allocator</span> (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdf20</span>)<br>    at /usr/include/c++/<span class="hljs-number">8</span>/ext/new_allocator.h:<span class="hljs-number">79</span><br><span class="hljs-number">79</span>            <span class="hljs-built_in">new_allocator</span>() _GLIBCXX_USE_NOEXCEPT &#123; &#125;<br><br>std::allocator&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">allocator</span> (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdf20</span>) at /usr/include/c++/<span class="hljs-number">8</span>/bits/allocator.h:<span class="hljs-number">131</span><br><span class="hljs-number">131</span>           <span class="hljs-built_in">allocator</span>() <span class="hljs-built_in">throw</span>() &#123; &#125;<br><br>std::_Vector_base&lt;<span class="hljs-type">int</span>, std::allocator&lt;<span class="hljs-type">int</span>&gt; &gt;::_Vector_impl::_Vector_impl (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdf20</span>)<br>    at /usr/include/c++/<span class="hljs-number">8</span>/bits/stl_vector.h:<span class="hljs-number">97</span><br><span class="hljs-number">97</span>              &#123; &#125;<br><br>std::_Vector_base&lt;<span class="hljs-type">int</span>, std::allocator&lt;<span class="hljs-type">int</span>&gt; &gt;::_Vector_base (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdf20</span>)<br>    at /usr/include/c++/<span class="hljs-number">8</span>/bits/stl_vector.h:<span class="hljs-number">249</span><br><span class="hljs-number">249</span>           : _M_impl() &#123; &#125;<br><br>std::vector&lt;<span class="hljs-type">int</span>, std::allocator&lt;<span class="hljs-type">int</span>&gt; &gt;::<span class="hljs-built_in">vector</span> (<span class="hljs-keyword">this</span>=<span class="hljs-number">0x7fffffffdf20</span>)<br>    at /usr/include/c++/<span class="hljs-number">8</span>/bits/stl_vector.h:<span class="hljs-number">395</span><br><span class="hljs-number">395</span>           : _Base() &#123; &#125;<br><br><span class="hljs-built_in">main</span> () at <span class="hljs-number">01.</span>cpp:<span class="hljs-number">8</span><br><span class="hljs-number">8</span>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>那么接下来，我们对头文件<code>stl_vector.h</code>截取一下<code>_Vector_base</code>基类的部分代码实现，如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Vector_base</span><br>  &#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::<span class="hljs-keyword">template</span><br>    rebind&lt;_Tp&gt;::other _Tp_alloc_type;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;::pointer<br>          pointer;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Vector_impl</span><br>    : <span class="hljs-keyword">public</span> _Tp_alloc_type<br>    &#123;<br>    pointer _M_start;           <span class="hljs-comment">//容器开始位置</span><br>    pointer _M_finish;          <span class="hljs-comment">//容器结束位置</span><br>    pointer _M_end_of_storage;  <span class="hljs-comment">//容器所申请的动态内存最后一个位置的下一个位置</span><br><br>    <span class="hljs-built_in">Vector_impl</span>()<br>    : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()<br>    &#123; &#125;<br>    ... <span class="hljs-comment">//此处省略部分源码</span><br>    &#125;;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> _Alloc allocator_type;<br><br>    ... <span class="hljs-comment">//此处省略部分源码</span><br>    _Vector_base()<br>    : _M_impl() &#123; &#125;<br>    ... <span class="hljs-comment">//此处省略部分源码</span><br>    _Vector_base(<span class="hljs-type">size_t</span> __n)<br>    : _M_impl()<br>    &#123; _M_create_storage(__n); &#125;<br>    ... <span class="hljs-comment">//此处省略部分源码</span><br><br>  <span class="hljs-keyword">public</span>:<br>    _Vector_impl _M_impl;<br><br>    pointer<br>    _M_allocate(<span class="hljs-type">size_t</span> __n)<br>    &#123;<br>    <span class="hljs-keyword">typedef</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Tr;<br>    <span class="hljs-keyword">return</span> __n != <span class="hljs-number">0</span> ? _Tr::<span class="hljs-built_in">allocate</span>(_M_impl, __n) : <span class="hljs-built_in">pointer</span>();<br>    &#125;<br><br>    <span class="hljs-type">void</span><br>    _M_deallocate(pointer __p, <span class="hljs-type">size_t</span> __n)<br>    &#123;<br>    <span class="hljs-keyword">typedef</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Tr;<br>    <span class="hljs-keyword">if</span> (__p)<br>    _Tr::<span class="hljs-built_in">deallocate</span>(_M_impl, __p, __n);<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">void</span><br>    _M_create_storage(<span class="hljs-type">size_t</span> __n)<br>    &#123;<br>    <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start = <span class="hljs-keyword">this</span>-&gt;_M_allocate(__n);<br>    <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish = <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start;<br>    <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage = <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start + __n;<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td>这样看，这个基类<code>_Vector_base</code>的功能就很明晰了，它声明了一个结构体<code>struct _Vector_impl</code>，同时以这个结构体声明了一个公有成员变量<code>_M_impl</code>，对于基类的无参构造函数，它也只是调用了<code>struct _Vector_impl</code>的构造函数，进而调用了<code>struct _Vector_impl</code>的各个成员变量的构造函数。</td></tr><tr class="even"><td>这里需注意，结构体<code>_Vector_impl</code>的三个成员变量<code>_M_start</code>、<code>_M_finish</code>、<code>_M_end_of_storage</code>是比较重要的，在<code>vector</code>的实现中它们会多次出现，关于它们的作用注释中也已经写明了，这三个成员变量保存了<code>vector</code>容器的开始位置、结束位置以及所申请内存空间的的下一个位置。</td></tr><tr class="odd"><td>到这里为止，其实我们还是很疑惑，这个基类啥也没干啊，它有什么作用呢，事实上正如前面所说，对于形如<code>vector&lt;int&gt; v;</code>这样创建一个模版类对象<code>v</code>，<code>vector</code>调用这个基类的无参构造，它就是什么也没干，此时也并没有申请动态内存，具体它的作用我们后面再说明。</td></tr><tr class="even"><td><strong>无参构造为什么没有申请动态内存呢，这里涉及到节约资源的原则，假设这里申请了一块动态内存，但是你后面却没有使用这个<code>vector</code>，那这个申请和释放这块动态内存的动作无形中就产生了时间和空间的浪费，这个不符合<code>STL</code>性能优先的原则。</strong></td></tr><tr class="odd"><td>&gt;STL性能优先是指什么呢，就是C++标准中规定，STL要优先考虑性能，为此，其他的容错性以及更多的功能都可以被舍弃掉。</td></tr><tr class="even"><td>但同时我们也可以看出来，如果<code>vector</code>在构造的时候给基类传入元素大小<code>n</code>，这个时候就会调用成员函数<code>_M_create_storage</code>，申请动态内存和给成员变量赋值。</td></tr><tr class="odd"><td>到这里我们至少了解到了基类的两个作用： *保存容器<strong>开始位置</strong>、<strong>结束位置</strong>以及<strong>所申请内存空间的的下一个位置</strong>；* 申请动态内存空间。</td></tr><tr class="even"><td>### vector从后面插入元素时发生了什么 #### 对空vector插入一个元素上面说到，如果<code>vector</code>在构造的时候指定容器大小，那么声明时就会<strong>申请动态内存</strong>，但如果构造是默认构造，并不会申请动态内存，那么此时对一个无空间的<code>vector</code>插入一个元素会发生什么事呢？</td></tr><tr class="odd"><td>依然在文件<code>stl.vector.h</code>中，我们找到<code>vector</code>的<code>push_back</code>函数实现，如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; __x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish != <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage)<br>  &#123;<br>    _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish,<br>                       __x);<br>    ++<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>  &#125;<br><span class="hljs-keyword">else</span><br>  _M_realloc_insert(<span class="hljs-built_in">end</span>(), __x);<br>&#125;<br></code></pre></td></tr></table></figure>这个函数在内存还没有写满时，把元素直接插入成员变量<code>_M_finish</code>所指向的位置，如果已经写满了，会调用<code>vector</code>的成员函数<code>_M_realloc_insert</code>，很显然对一个无空间的<code>vector</code>插入一个元素会调用<code>_M_realloc_insert</code>函数，该函数实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Args&gt;<br>      <span class="hljs-type">void</span><br>      vector&lt;_Tp, _Alloc&gt;::<br>      _M_realloc_insert(iterator __position, _Args&amp;&amp;... __args)<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<br>    <span class="hljs-type">void</span><br>    vector&lt;_Tp, _Alloc&gt;::<br>    _M_realloc_insert(iterator __position, <span class="hljs-type">const</span> _Tp&amp; __x)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#123;<br>      <span class="hljs-comment">//这里调用了_M_check_len</span><br>      <span class="hljs-comment">//_M_check_len在传入参数为1的情况下，只要没有超出STL规定的最大内存大小，每次返回当前容器大小的双倍，初次返回1</span><br>      <span class="hljs-type">const</span> size_type __len =<br>_M_check_len(<span class="hljs-built_in">size_type</span>(<span class="hljs-number">1</span>), <span class="hljs-string">&quot;vector::_M_realloc_insert&quot;</span>);<br>      pointer __old_start = <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start;<br>      pointer __old_finish = <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>      <span class="hljs-type">const</span> size_type __elems_before = __position - <span class="hljs-built_in">begin</span>();<br>      <span class="hljs-comment">//根据前面vector基类介绍中说的，_M_allocate根据传入长度申请内存空间</span><br>      pointer __new_start(<span class="hljs-keyword">this</span>-&gt;_M_allocate(__len));<br>      pointer __new_finish(__new_start);<br>      __try<br>&#123;<br>  <span class="hljs-comment">//把x写入相应的位置</span><br>  _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl,<br>   __new_start + __elems_before,<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>   std::forward&lt;_Args&gt;(__args)...);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>   __x);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  __new_finish = <span class="hljs-built_in">pointer</span>();<br>    <br>  <span class="hljs-comment">//这里其实就是把原来数据拷贝到新的内存中来</span><br>  __new_finish<br>    = std::__uninitialized_move_if_noexcept_a<br>    (__old_start, __position.<span class="hljs-built_in">base</span>(),<br>     __new_start, _M_get_Tp_allocator());<br><br>  ++__new_finish;<br><br>  <span class="hljs-comment">//这里为什么要再调用一次呢？是针对往vector中间插入元素的情况来的</span><br>  __new_finish<br>    = std::__uninitialized_move_if_noexcept_a<br>    (__position.<span class="hljs-built_in">base</span>(), __old_finish,<br>     __new_finish, _M_get_Tp_allocator());<br>&#125;<br>      __catch(...)<br>&#123;<br>  <span class="hljs-keyword">if</span> (!__new_finish)<br>    _Alloc_traits::<span class="hljs-built_in">destroy</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl,<br>   __new_start + __elems_before);<br>  <span class="hljs-keyword">else</span><br>    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());<br>  _M_deallocate(__new_start, __len);<br>  __throw_exception_again;<br>&#125;<br>      <span class="hljs-comment">//这里销毁原来的内存并给成员变量赋新值</span><br>      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());<br>      _M_deallocate(__old_start,<br>    <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage - __old_start);<br>      <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start = __new_start;<br>      <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish = __new_finish;<br>      <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage = __new_start + __len;<br>    &#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>根据上述代码可知，对一个无空间的<code>vector</code>插入一个元素的流程如下：*得到一个长度，这个长度第一次插入时为<code>1</code>，后续如果超出容器所申请的空间，则在之前基础上乘以<code>2</code>，然后申请新的内存空间；* 把待插入的元素插入到相应的位置； *把原来旧内存中元素全部拷贝到新的内存中来； *调用旧内存中所有元素的析构，并销毁旧的内存；</td></tr><tr class="odd"><td>根据以上逻辑，也就是说，对一个无空间的<code>vector</code>插入一个元素实际上是会先申请<code>1</code>个元素的空间，并把这个元素插入到<code>vector</code>。</td></tr><tr class="even"><td><strong>根据以上，其实如果我们能确定<code>vector</code>必定会被使用且有数据时，我们应该在声明的时候指定元素个数，避免最开始的时候多次申请动态内存消耗资源，进而影响性能。</strong></td></tr><tr class="odd"><td>#### vector当前内存用完时插入那么如果内存用完时是怎样的呢，实际上，现有内存空间用完的情况其实跟最开始插入第一个元素的调用路线一致，也就是说，如果现有空间用完了，会在当前空间基础上乘以<code>2</code>，然后把原来内存空间中所有数据拷贝到新的内存中，最后把当前要插入的数据插入到最后一个元素的下一个位置。VC2008: <img src="media/16224350022491/16363945751374.jpg"alt="-w860" /> VC6.0 <img src="media/16224350022491/16363957480005.jpg"alt="-w850" /></td></tr><tr class="even"><td>#### vector在中间插入一个元素会发生什么中间插入元素就要使用<code>vector</code>的成员函数<code>insert</code>，该函数实现的文件在<code>vector.tcc</code>，<code>insert</code>的一个最基本的实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<br>    <span class="hljs-keyword">typename</span> vector&lt;_Tp, _Alloc&gt;::iterator<br>    vector&lt;_Tp, _Alloc&gt;::<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>    <span class="hljs-built_in">insert</span>(const_iterator __position, <span class="hljs-type">const</span> value_type&amp; __x)<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">insert</span>(iterator __position, <span class="hljs-type">const</span> value_type&amp; __x)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#123;<br>      <span class="hljs-type">const</span> size_type __n = __position - <span class="hljs-built_in">begin</span>();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish != <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage)<br><span class="hljs-keyword">if</span> (__position == <span class="hljs-built_in">end</span>())<br>  &#123;<br>    _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish,<br>     __x);<br>    ++<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>  &#125;<br><span class="hljs-keyword">else</span><br>  &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> __pos = <span class="hljs-built_in">begin</span>() + (__position - <span class="hljs-built_in">cbegin</span>());<br>    <span class="hljs-comment">// __x could be an existing element of this vector, so make a</span><br>    <span class="hljs-comment">// copy of it before _M_insert_aux moves elements around.</span><br>    _Temporary_value __x_copy(<span class="hljs-keyword">this</span>, __x);<br>    _M_insert_aux(__pos, std::<span class="hljs-built_in">move</span>(__x_copy._M_val()));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    _M_insert_aux(__position, __x);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  &#125;<br>      <span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>_M_realloc_insert(<span class="hljs-built_in">begin</span>() + (__position - <span class="hljs-built_in">cbegin</span>()), __x);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>_M_realloc_insert(__position, __x);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start + __n);<br>    &#125;<br></code></pre></td></tr></table></figure><code>insert</code>函数在空间不够时，其实与<code>push_back</code>调用流程一样，大家可以在翻到上面对空<code>vector</code>插入一个元素的情况那部分看一下函数<code>_M_realloc_insert</code>的注释，在函数<code>_M_realloc_insert</code>中，第二次调用<code>std::__uninitialized_move_if_noexcept_a</code>函数其实就是针对于往中间插入元素的情况，如果是<code>push_back</code>函数，这个第二次调用其实是没有作用的。</td></tr><tr class="odd"><td>那如果空间足够时往中间插入会发生什么呢？我们看代码，在<code>C++11</code>以前是直接调用<code>_M_insert_aux</code>函数，我们看一下这个函数的实现，如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Arg&gt;<br>      <span class="hljs-type">void</span><br>      vector&lt;_Tp, _Alloc&gt;::<br>      _M_insert_aux(iterator __position, _Arg&amp;&amp; __arg)<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<br>    <span class="hljs-type">void</span><br>    vector&lt;_Tp, _Alloc&gt;::<br>    _M_insert_aux(iterator __position, <span class="hljs-type">const</span> _Tp&amp; __x)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#123;<br>      _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish,<br>       _GLIBCXX_MOVE(*(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish - <span class="hljs-number">1</span>)));<br>      ++<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &lt; 201103L</span><br>      _Tp __x_copy = __x;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      _GLIBCXX_MOVE_BACKWARD3(__position.<span class="hljs-built_in">base</span>(),<br>      <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish - <span class="hljs-number">2</span>,<br>      <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &lt; 201103L</span><br>      *__position = __x_copy;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      *__position = std::forward&lt;_Arg&gt;(__arg);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td><strong>看代码可知，其实就是把当前要插入元素的位置后面的元素向后移动，然后把待插入元素插入到相应的位置。</strong></td></tr><tr class="odd"><td>### vector删除元素内存会被释放吗？ #### 从容器最后删除从容器中间删除，其实就是删除一个指定位置的元素，这个动作是由<code>erase</code>函数完成的，<code>erase</code>的一个最简单的重载实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">      iterator<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>      <span class="hljs-built_in">erase</span>(const_iterator __position)<br>      &#123; <span class="hljs-keyword">return</span> _M_erase(<span class="hljs-built_in">begin</span>() + (__position - <span class="hljs-built_in">cbegin</span>())); &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      <span class="hljs-built_in">erase</span>(iterator __position)<br>      &#123; <span class="hljs-keyword">return</span> _M_erase(__position); &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>我们看到其调用了<code>_M_erase</code>函数，进入该函数看看其实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Alloc&gt;<br>   <span class="hljs-keyword">typename</span> vector&lt;<span class="hljs-type">bool</span>, _Alloc&gt;::iterator<br>   vector&lt;<span class="hljs-type">bool</span>, _Alloc&gt;::<br>   _M_erase(iterator __position)<br>   &#123;<br>     <span class="hljs-keyword">if</span> (__position + <span class="hljs-number">1</span> != <span class="hljs-built_in">end</span>())<br>       std::<span class="hljs-built_in">copy</span>(__position + <span class="hljs-number">1</span>, <span class="hljs-built_in">end</span>(), __position);<br>     --<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>     <span class="hljs-keyword">return</span> __position;<br>   &#125;<br><br> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Alloc&gt;<br>   <span class="hljs-keyword">typename</span> vector&lt;<span class="hljs-type">bool</span>, _Alloc&gt;::iterator<br>   vector&lt;<span class="hljs-type">bool</span>, _Alloc&gt;::<br>   _M_erase(iterator __first, iterator __last)<br>   &#123;<br>     <span class="hljs-keyword">if</span> (__first != __last)<br>_M_erase_at_end(std::<span class="hljs-built_in">copy</span>(__last, <span class="hljs-built_in">end</span>(), __first));<br>     <span class="hljs-keyword">return</span> __first;<br>   &#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td>这个函数在不是删除最后一个元素的情况下，把这个元素后面的所有元素向前移动一位，且这是一个拷贝的动作，然后把容器结束位置向前移动一位，并返回指向当前位置的迭代器。综上，删除元素不会释放现有已经申请的动态内存。</td></tr><tr class="even"><td>### vector如何修改某个位置的元素值vector是否可以直接修改某个位置的元素？不可以。只能先删除，然后再插入，不过这样干，效率就很低了，所以vector坚决不支持修改元素。</td></tr><tr class="odd"><td>### vector读取一个元素的值效率怎么样直接访问元素的话，<code>vector</code>提供了不少函数，如果是访问指定位置的元素，那就可以使用<code>operator[]</code>和<code>at</code>函数，我们分别看下这两个函数的实现，如下：</td></tr><tr class="even"><td><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">const_reference<br><span class="hljs-keyword">operator</span>[](size_type __n) <span class="hljs-type">const</span> _GLIBCXX_NOEXCEPT<br>&#123;<br>__glibcxx_requires_subscript(__n);<br><span class="hljs-keyword">return</span> *(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start + __n);<br>&#125;<br><br><span class="hljs-function">const_reference</span><br><span class="hljs-function"><span class="hljs-title">at</span><span class="hljs-params">(size_type __n)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>_M_range_check(__n);<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>)[__n];<br>&#125;<br></code></pre></td></tr></table></figure>可以看到<code>at</code>函数就是调用的<code>operator[]</code>函数，只是多了一个检查是否越界的操作，而<code>operator[]</code>函数是直接跳转位置访问元素，所以速度是很快的，从时间复杂度看，是<code>O(1)</code>。</td></tr><tr class="odd"><td>### C++11给vector增加了什么内容从上面的代码我们可以看出，充斥了诸多形如<code>#if __cplusplus &gt;= 201103L</code>这样的预编译选项，它其实代表了<code>C++</code>的版本，比如<code>C++11</code>标准是在<code>2011</code>年<code>3</code>月份发布的，那么这行代码意思就是说如果我们在编译时指定了<code>__cplusplus</code>这个为<code>201103</code>，那么就展开它下面的代码，否则展开<code>#else</code>后面的代码。</td></tr><tr class="even"><td>那么<code>C++11</code>以后<code>vector</code>中增加了一些什么内容呢，我们来看看：*对于迭代器，增加<code>cbegin</code>系列函数，返回常量迭代器，就是只读迭代器；*增加了移动构造函数和移动赋值函数，这一点基本上标准库里面所有类型都增加了；* 增加公共成员函数<code>shrink_to_fit</code>，允许释放未使用的内存； *增加公共成员函数<code>emplace</code>和<code>emplace_back</code>，它支持在指定位置原位构造元素，因为它们是以右值引用的方式传递参数，所以它们相比于<code>push_back</code>这一类的函数，少了一个拷贝的动作；</td></tr><tr class="odd"><td>### vector底层实现总结总的来说，vector是一个动态数组，它维护了一段连续的动态内存空间，然后有三个成员变量分别保存开始位置、当前已使用位置、申请的动态内存的最后一个位置的下一个位置，每当当前所申请的动态内存已经使用完时，它按照原有空间大小双倍重新申请，并把原来的元素都拷贝过去。</td></tr><tr class="even"><td>根据前面几小节的内容，对于vector操作的时间复杂度分别如下所示： *访问元素，时间复杂度为<code>O(1)</code>; *在末尾插入或者删除元素，时间复杂度也为<code>O(1)</code>; *在中间插入或者删除元素，时间复杂度为<code>O(n)</code>。</td></tr><tr class="odd"><td>### vector使用注意事项 -<strong>在不确定的情况下使用<code>at</code>而不是<code>operator[]</code></strong>在前面访问元素小节那里我们说了，<code>at</code>会检查是否越界，假设不确定当前访问动作是否会越界，那么我们应该使用<code>at</code>函数。</td></tr><tr class="even"><td>- <strong>什么类型不可以作为vector的模板类型？</strong>对于<code>vector</code>模板特化类型，因为在<code>vector</code>的实现过程中，变量会经常被拷贝或者赋值，所以<code>vector</code>的模板类型应该具有公有的拷贝构造函数和重载的赋值操作符函数。</td></tr><tr class="odd"><td>- <strong>什么情况下vector的迭代器会失效？</strong> 1.第一是在<code>vector</code>容器中间根据指定迭代器删除元素，也就是调用<code>erase</code>函数，此时因为当前位置会被后面的元素覆盖，所以该指定迭代器会失效，不过此时可以通过<code>erase</code>的返回值重新得到当前位置的正确迭代器；2.第二是在<code>vector</code>需重新申请内存的时候，比如扩容，比如释放未使用的内存等等这些过程中都会发生迭代器失效的问题，因为内存有了变动，此时就需要重新获得迭代器；</td></tr><tr class="even"><td>有人说往<code>vector</code>中间插入数据也会使迭代器失效，实际上根据源码是不会的，看上面的<code>insert</code>实现可以得知，再插入完成以后给当前迭代器重新赋值了的。</td></tr><tr class="odd"><td>- <strong>vector怎么迅速的释放内存？</strong>有人说是不是可以调用<code>reserve(0)</code>来进行释放，毕竟<code>reserve</code>函数会根据我们指定的大小重新申请的内存，那是行不通的哈，这个函数只有在传入大小比原有内存大时才会有动作，否则不进行任何动作。至于通过<code>resize</code>或者<code>clear</code>等都是行不通的，这些函数都只会对当前已保存在容器中的所有元素进行析构，但对容器本身所在的内存空间是不会进行释放的。</td></tr><tr class="even"><td>1.想迅速释放<code>vector</code>的内存，可通过<code>swap</code>函数，这时我们可以想想，什么情况下<code>vector</code>大小为<code>0</code>呢，就是作为一个空容器的时候，所以要想快速的释放内存，我们可以参考<code>swap</code>函数机制，用一个空的<code>vector</code>与当前<code>vector</code>进行交换，使用形如<code>vector&lt;int&gt;().swap(v)</code>这样的代码，将<code>v</code>这个<code>vector</code>变量所代表的内存空间与一个空<code>vector</code>进行交换，这样<code>v</code>的内存空间等于被释放掉了，而这个空<code>vector</code>因为是一个临时变量，它在这行代码结束以后，会自动调用<code>vector</code>的析构函数释放动态内存空间，这样，一个<code>vector</code>的动态内存就被迅速的释放掉了。</td></tr><tr class="odd"><td>2.也可使用<code>shrink_to_fit</code>函数，在<code>C++11</code>以后增加了这个函数，它的作用是释放掉未使用的内存，假设我们先调用<code>clear</code>函数把所有元素清掉，这样是不是整块容器都变成未使用了，然后再调用<code>shrink_to_fit</code>函数把未使用的部分内存释放掉，这不就把这个<code>vector</code>内存释放掉了嘛。</td></tr><tr class="even"><td>## 顺序容器-deque * <ahref="https://codeantenna.com/a/Em2T27MjHE">C++ deque底层实现</a> * <ahref="https://www.cnblogs.com/zhuyf87/archive/2012/12/09/2809896.html">deque与vector的主要区别</a>* <a href="https://www.cnblogs.com/fortunely/p/16265683.html"></a></td></tr><tr class="odd"><td>因为我对插入删除的使用不够熟练，这里记录下，顺便说下vector的插入、删除也是第一个参数是迭代器，对于插入，第二个参数是val或者迭代器解引用，代表一个value，删除的话不需要val或迭代器解引用，直接删除第一个参数迭代器所在位置元素即可，注意给返回的结果重新复制给迭代器，避免迭代器失效。<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">deque.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">20</span>); <span class="hljs-comment">//it指向的位置插入元素20</span><br>deque.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">//it指向的位置删除元素</span><br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>deque又一个中控器map，存放连续空间的首地址，中控器初始为2，不断扩容，连续首地址空间长度为1024字节，有三个指针指向连续空间，分别为first,last, cur，其中first, last指向连续空间的首位，且first,last起初在连续空间的最中间位置，随着头部插入和尾部插入，分别向两边扩容。</td></tr><tr class="odd"><td>### 顺序容器-list底层是双向链表。链表的插入采用的是头插法，插入、删除效率O(1)，查询效率比较慢，O(n)。</td></tr><tr class="even"><td>### 顺序容器vector/deque/list的区别？</td></tr><tr class="odd"><td>vector特点：动态数组，内存连续，2倍方式扩容，vector<int> vec;0-1-2-4-8-... reserve(20)deque特点：动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容的时候（第一维数组进行2倍扩容）面经问题：deque底层内存是否是连续的？并不是，每一个第二维是连续的，第一维不连续。</td></tr><tr class="even"><td>vector和deque的区别？ 1.<strong>从底层数据结构回答</strong>：vector底层是动态数组，而deque底层是动态开辟的二维数组2.<strong>前中后插入、删除元素的时间复杂度是否一致？</strong>：中间和尾部O(1)，deque在前面插入为O(1)，vector前面插入为O(n)3.<strong>对内存使用效率而言</strong>：vector随着扩容，需要更大的连续内存空间，很可能随着内存越大，连续的内存空间更难分配到，因此内存的利用率可能更低，而deque则不需要，deque的内存块分布更散列，内存的使用效率会更高，因此相比vector，deque能够申请到更多的内存。4.<strong>在insert、erase上，vector和deque他们的效率谁更好一些？谁效率差一些？</strong>：<strong>站在中间操作的角度的话</strong>，由于deque第二维内存之间不是连续的，所以在deque中间进行元素的insert、erase，造成元素移动的指令会比vector多，效率会比vector慢。</td></tr><tr class="odd"><td>vector和list的区别？ 1.从底层结构回答：vector是数组，list是双向链表，数组增加删除O(n)，查询O(n)，特点在于随机访问时间复杂度为O(1)。链表增加删除均为O(1)，但要考虑查询搜索的过程，查询搜索需要遍历链表，时间复杂度为O(n)。</td></tr><tr class="even"><td>### 标准容器-容器适配器 stack/queue/priority_queue</td></tr><tr class="odd"><td>stack/queue/priority_queue stack容器适配器，通过顺序容器deque实现。<img src="media/16224350022491/16630484685929.jpg" alt="-w795" /></td></tr><tr class="even"><td>标准容器-容器适配器 =&gt;有种设计模式，叫做适配器模式，不过这里相当于另一种设计模式：代理模式怎么理解这个适配器？适配器底层没有自己的数据结构，它是另外一个容器(vector/deque/list)的封装，它的方法全部由底层依赖的容器进行实现</td></tr><tr class="odd"><td>stack: push pop top empty size stack =&gt; deque为什么不依赖vector呢？</td></tr><tr class="even"><td>queue: push pop front empty size queue =&gt; deque为什么不依赖vector呢？</td></tr><tr class="odd"><td>以上两个问题可归结为一类问题一起讨论： 1.vector的初始内存使用效率太低了 没有deque好 vector一开始0-1-2-4-8..deque直接4096/int =&gt; 1024 一开始开辟1024个二维连续空间 2.对于queue，头部删除效率deque是O(1)，而vector则为O(n)，其出队效率很低 3.vector需要大片的连续内存，而deque只需要分段的内存，当存储大量数据时，显然deque对于内存的利用率更好</td></tr><tr class="even"><td>priority_queue: push pop top empty size priority_queue =&gt; vector为什么依赖vector呢？ 底层默认把数据组成一个大根堆结构在一个内存连续的数组上构建一个大根堆或者小根堆</td></tr><tr class="odd"><td>### 关联容器还记着顺序容器的insert的时候，第一个参数为迭代器位置，关联容器区别于顺序容器的点在，insert的时候不需要指定给哪个迭代器位置插入，直接insert具体的value即可。</td></tr><tr class="even"><td>集合常用增删查方法 增加：insert(val)遍历：iterator自己搜索，调用find成员方法 set.find(key) 存在则返回迭代器不存在则返回末尾迭代器 删除：erase(key) erase(it)</td></tr><tr class="odd"><td>映射表常用增删查方法 增加：insert({xx, xx}); / insert(make_pair(xx,xx)); #### 有序关联容器 有序关联容器，红黑树 增删查O(log2n)，2是底数 setmultiset map multimap</td></tr><tr class="even"><td>#### 无序关联容器无序关联容器，底层是哈希表，是没有顺序的，增删查效率O(1)，两大类：set:集合key map:映射表[key, value] unordered_set 单重集合unordered_multiset 多重集合 unordered_map 单重映射表 unordered_multimap多重映射表</td></tr><tr class="odd"><td>## 迭代器 迭代器类型： * 输入迭代器：可用来从序列中读取数据 *输出迭代器：允许向序列中写入数据 *前向迭代器：既是输入迭代器又是输出迭代器，并且可以对序列进行单向的遍历 *双向迭代器：与前向迭代器相似，但是在两个方向上都可以对数据遍历 *随机访问迭代器：也是双向迭代器，但能够在序列中的任意两个位置之间进行跳转</td></tr><tr class="even"><td><img src="media/16224350022491/16364622212787.jpg" /></td></tr><tr class="odd"><td><img src="media/16224350022491/16364622446305.jpg" /></td></tr><tr class="even"><td><img src="media/16224350022491/16365272920501.jpg"alt="-w1235" /></td></tr><tr class="odd"><td><img src="media/16224350022491/16365272593618.jpg"alt="-w1237" /></td></tr><tr class="even"><td><img src="media/16224350022491/16365273400194.jpg"alt="-w1232" /></td></tr><tr class="odd"><td><img src="media/16224350022491/16365273969640.jpg"alt="-w1228" /></td></tr><tr class="even"><td><img src="media/16224350022491/16365274488486.jpg"alt="-w1237" /></td></tr><tr class="odd"><td>## 算法 <img src="media/16224350022491/16365283005188.jpg"alt="-w1159" /></td></tr><tr class="even"><td><img src="media/16224350022491/16365283206144.jpg"alt="-w1200" /></td></tr><tr class="odd"><td><img src="media/16224350022491/16365283806991.jpg"alt="-w1206" /></td></tr><tr class="even"><td><img src="media/16224350022491/16365284248610.jpg"alt="-w1198" /></td></tr><tr class="odd"><td><img src="media/16224350022491/16365284404104.jpg"alt="-w1196" /></td></tr><tr class="even"><td><img src="media/16224350022491/16365284696037.jpg"alt="-w1202" /></td></tr><tr class="odd"><td><img src="media/16224350022491/16365285066735.jpg"alt="-w1195" /></td></tr><tr class="even"><td><img src="media/16224350022491/16365285419723.jpg"alt="-w1196" /></td></tr><tr class="odd"><td>接下来我会演示一些主要的算法，首先是<strong>非变动性算法</strong>：* <code>for_each</code> * <code>min_element</code> *<code>max_element</code> * <code>find</code> * <code>find_if</code> *<del><code>search</code>(待补充）</del></td></tr><tr class="even"><td><strong>for_each</strong><code>for_each</code>函数传递三个参数，前两个参数为迭代器（若对数组<code>arr</code>进行操作，传入参数为<code>begin(arr)</code>返回的指针和<code>end(arr)</code>返回的指针，而非迭代器），第三个参数是一个函数，我们看其源码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _InputIterator, <span class="hljs-keyword">typename</span> _Function&gt;</span><br><span class="hljs-function">   _Function</span><br><span class="hljs-function">   <span class="hljs-title">for_each</span><span class="hljs-params">(_InputIterator __first, _InputIterator __last, _Function __f)</span></span><br><span class="hljs-function">   </span>&#123;<br>     __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator&gt;)<br>     __glibcxx_requires_valid_range(__first, __last);<br>     <span class="hljs-keyword">for</span> (; __first != __last; ++__first)<br>__f(*__first);<br>     <span class="hljs-keyword">return</span> __f; <span class="hljs-comment">// N.B. [alg.foreach] says std::move(f) but it&#x27;s redundant.</span><br>   &#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td>可以看到会对<code>__first</code>到<code>__last</code>之间进行遍历操作，并且将<code>__first</code>指针指向的内容传递给函数<code>__f</code>，这里的传递需要特别注意为<strong>值传递</strong>，也就是说<code>__f</code>函数对其传入的值进行的各种修改都不会改变原始连续内存中的值，如果要修改，传入的就必须是引用，即<code>int &amp;n</code>，与此同时<code>for_each</code>就由非变动性算法变为变动性算法。一个简单的应用如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_element</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;++n;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> s[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(begin(s), end(s))</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v)<br>      cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;   <span class="hljs-comment">//1 2 3 4 5</span><br>    cout &lt;&lt; endl;<br><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), print_element); cout &lt;&lt; endl;  <span class="hljs-comment">//1 2 3 4 5</span><br>    for_each(<span class="hljs-built_in">begin</span>(s), <span class="hljs-built_in">end</span>(s), print_element); cout &lt;&lt; endl;    <span class="hljs-comment">//1 2 3 4 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>需要注意一点的是，<code>for_each</code>所遍历的容器需要有空间才行，若只是创建了一个未初始化空间大小的容器，那么通过<code>for_each</code>去遍历修改该容器的操作就是一种没有意义的操作。</td></tr><tr class="odd"><td><strong>min_element/max_element</strong><code>min_element</code>函数传递两个参数，分别为迭代器的<code>begin</code>和迭代器的<code>end</code>（如果对数组操作，可传入起始和结束位置的指针，指针的传递可通过标准库函数<code>begin</code>和<code>end</code>返回），该函数返回最小值出现的位置，其代码实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ForwardIterator, <span class="hljs-keyword">typename</span> _Compare&gt;<br>   _GLIBCXX14_CONSTEXPR<br>   _ForwardIterator<br>   __min_element(_ForwardIterator __first, _ForwardIterator __last,<br>  _Compare __comp)<br>   &#123;<br>     <span class="hljs-keyword">if</span> (__first == __last)<br><span class="hljs-keyword">return</span> __first;<br>     _ForwardIterator __result = __first;<br>     <span class="hljs-keyword">while</span> (++__first != __last)<br><span class="hljs-keyword">if</span> (__comp(__first, __result)) <span class="hljs-comment">//此处__comp即为下方的__iter_less_iter()比较函数</span><br>  __result = __first;  <span class="hljs-comment">//遍历时发现较小的元素 更新给__result</span><br>     <span class="hljs-keyword">return</span> __result;  <span class="hljs-comment">//将最小元素返回</span><br>   &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ForwardIterator&gt;</span><br><span class="hljs-function">   _GLIBCXX14_CONSTEXPR</span><br><span class="hljs-function">   _ForwardIterator</span><br><span class="hljs-function">   <span class="hljs-keyword">inline</span> <span class="hljs-title">min_element</span><span class="hljs-params">(_ForwardIterator __first, _ForwardIterator __last)</span></span><br><span class="hljs-function">   </span>&#123;<br>     __glibcxx_function_requires(_ForwardIteratorConcept&lt;_ForwardIterator&gt;)<br>     __glibcxx_function_requires(_LessThanComparableConcept&lt;<br>    <span class="hljs-keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type&gt;)<br>     __glibcxx_requires_valid_range(__first, __last);<br>     __glibcxx_requires_irreflexive(__first, __last);<br><br>     <span class="hljs-keyword">return</span> _GLIBCXX_STD_A::__min_element(__first, __last,<br>__gnu_cxx::__ops::__iter_less_iter());  <span class="hljs-comment">//min_element第三个参数为比较函数</span><br>   &#125;<br></code></pre></td></tr></table></figure>可以看到<code>min_element</code>函数会调用<code>__min_element</code>函数，该函数传入了比较函数<code>__iter_less_iter()</code>，比较函数对传入的两个迭代器指向元素进行比较，如果<code>__first</code>相比于<code>__result</code>更小，那就会更新<code>__result</code>，跟进去看这个比较函数，发现其内部是运算符重载函数模板，具体代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Iter_less_iter</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Iterator1, <span class="hljs-keyword">typename</span> _Iterator2&gt;</span><br><span class="hljs-function">    _GLIBCXX14_CONSTEXPR</span><br><span class="hljs-function">    <span class="hljs-type">bool</span></span><br><span class="hljs-function">    <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(_Iterator1 __it1, _Iterator2 __it2)</span> <span class="hljs-type">const</span>  <span class="hljs-comment">//运算符重载函数模板</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> *__it1 &lt; *__it2; &#125;   <span class="hljs-comment">//返回迭代器指向的较小值的布尔类型</span><br>&#125;;<br><br>_GLIBCXX14_CONSTEXPR<br><span class="hljs-keyword">inline</span> _Iter_less_iter<br>__iter_less_iter()    <span class="hljs-comment">//比较函数</span><br>&#123; <span class="hljs-keyword">return</span> _Iter_less_iter(); &#125; <span class="hljs-comment">//返回一个类</span><br></code></pre></td></tr></table></figure>那么对于通过传入迭代器指向，最终<code>min_element</code>会返回一个指向最小元素的迭代器，我们可以通过<code>*</code>解引用的方式访问其指向的最小值元素，对于<code>max_element</code>函数，其原理类似，此处不再说明。</td></tr><tr class="even"><td><strong>find/find_if</strong><code>find</code>函数用来查找某个特定的值第一次出现的位置，传递三个参数，前两个参数分别为迭代器的<code>begin</code>和迭代器的<code>end</code>（如果对数组操作，可传入起始和结束位置的指针，指针的传递可通过标准库函数<code>begin</code>和<code>end</code>返回），第三个参数为要查找的值，其代码实现中可以看到调用了<code>__find_if</code>函数，而这个函数默认传入第三个比较函数<code>__iter_equals_val</code>，作为<code>find</code>的条件，即找的条件是要等于传入的<code>__val</code>值，如果为真，则找到并返回。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _InputIterator, <span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">inline</span> _InputIterator</span><br><span class="hljs-function">  <span class="hljs-title">find</span><span class="hljs-params">(_InputIterator __first, _InputIterator __last,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> _Tp&amp; __val)</span></span><br><span class="hljs-function">  </span>&#123;<br>    __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator&gt;)<br>    __glibcxx_function_requires(_EqualOpConcept&lt;<br><span class="hljs-keyword">typename</span> iterator_traits&lt;_InputIterator&gt;::value_type, _Tp&gt;)<br>    __glibcxx_requires_valid_range(__first, __last);<br>    <span class="hljs-keyword">return</span> std::__find_if(__first, __last,<br>    __gnu_cxx::__ops::__iter_equals_val(__val));<br>  &#125;<br></code></pre></td></tr></table></figure>我们跟进第三个参数，查看其内部实现，发现其主要功能是比较迭代器指向的值<code>*__it</code>是否与要查找的值<code>__val</code>相等，若相等返回<code>bool</code>类型的<code>true</code>，表示找到了，若不等则返回<code>false</code>，所以<code>find</code>函数根据第三个参数的函数返回值的布尔类型决定其是否能够找到。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Value&gt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Iter_equals_val</span><br>   &#123;<br>     _Value&amp; _M_value; <span class="hljs-comment">//模板类型值 根据我们传入的类型而变化</span><br><br>     <span class="hljs-keyword">explicit</span><br>     _Iter_equals_val(_Value&amp; __value) <span class="hljs-comment">//Iter_equals_val模板类构造函数</span><br>: _M_value(__value)    <span class="hljs-comment">//初始化模板类型值_M_value = __value</span><br>     &#123; &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Iterator&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(_Iterator __it)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> *__it == _M_value; &#125;  <span class="hljs-comment">//判断当前指向值是否与传入__val相等 找到了则返回True</span><br>   &#125;;<br><br> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Value&gt;<br>   <span class="hljs-keyword">inline</span> _Iter_equals_val&lt;_Value&gt;<br>   __iter_equals_val(_Value&amp; __val)<br>   &#123; <span class="hljs-keyword">return</span> _Iter_equals_val&lt;_Value&gt;(__val); &#125; <span class="hljs-comment">//迭代器指向与__val相等 则返回True</span><br></code></pre></td></tr></table></figure>那么已经剖析了<code>find</code>函数的实现，对于<code>find_if</code>函数，第三个参数不再是一个值，而是用户自定义的函数，其返回类型为<code>bool</code>，传入的形参为遍历查找的区间中的单个元素（比如便利<code>vector&lt;int&gt;</code>，那传入的就是<code>int</code>），通过自定义函数实现及返回的布尔值来确定查找条件。应用如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">greater_than_3</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">3</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> s[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(begin(s), end(s))</span></span>;<br>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), greater_than_3);<br>    <span class="hljs-keyword">if</span>(it != v.<span class="hljs-built_in">end</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;find the first element bigger than 3&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td>接下来我们演示一些变动性算法： * <code>for_each</code> *<code>copy</code> * <code>copy_backward</code> * <code>transform</code>* <code>replace</code> * <code>replace_copy</code> *<code>replace_copy_if</code></td></tr><tr class="even"><td><code>for_each</code>算法中，函数参数的形参列表变为引用后，即为变动性算法，这里不具体说明了，上面非变动算法处已经介绍。</td></tr><tr class="odd"><td><strong>copy</strong><code>copy</code>函数用于将某个容器中<code>first</code>迭代器到<code>last</code>迭代器之间的内容拷贝到另一个起始迭代器为<code>result</code>的内存中，因此其传递三个参数，前两个参数分别为要拷贝的值对应迭代器的首尾，第三个参数代表要拷贝进去的内存的起始迭代器位置。其源码大致如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _II, <span class="hljs-keyword">typename</span> _OI&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">inline</span> _OI</span><br><span class="hljs-function">  <span class="hljs-title">copy</span><span class="hljs-params">(_II __first, _II __last, _OI __result)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// concept requirements</span><br>    __glibcxx_function_requires(_InputIteratorConcept&lt;_II&gt;)<br>    __glibcxx_function_requires(_OutputIteratorConcept&lt;_OI,<br>   <span class="hljs-keyword">typename</span> iterator_traits&lt;_II&gt;::value_type&gt;)<br>    __glibcxx_requires_valid_range(__first, __last);<br><br>    <span class="hljs-keyword">return</span> (std::__copy_move_a2&lt;__is_move_iterator&lt;_II&gt;::__value&gt;<br>     (std::__miter_base(__first), std::__miter_base(__last),<br>      __result));<br>  &#125;<br></code></pre></td></tr></table></figure>我们可以看到该<code>copy</code>函数返回<code>__copy_move_a2</code>，我们跳转进去查看该代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> _IsMove, <span class="hljs-keyword">typename</span> _II, <span class="hljs-keyword">typename</span> _OI&gt;<br>  <span class="hljs-keyword">inline</span> _OI<br>  __copy_move_a2(_II __first, _II __last, _OI __result)<br>  &#123;<br>    <span class="hljs-keyword">return</span> _OI(std::__copy_move_a&lt;_IsMove&gt;(std::__niter_base(__first),<br>     std::__niter_base(__last),<br>     std::__niter_base(__result)));<br>  &#125;<br></code></pre></td></tr></table></figure>发现该代码又调用并返回<code>__copy_move_a</code>函数的结果，因此继续跳入进去查看代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> _IsMove, <span class="hljs-keyword">typename</span> _II, <span class="hljs-keyword">typename</span> _OI&gt;<br>  <span class="hljs-keyword">inline</span> _OI<br>  __copy_move_a(_II __first, _II __last, _OI __result)<br>  &#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;_II&gt;::value_type _ValueTypeI;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;_OI&gt;::value_type _ValueTypeO;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;_II&gt;::iterator_category _Category;<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> __simple = (__is_trivial(_ValueTypeI)<br>     &amp;&amp; __is_pointer&lt;_II&gt;::__value<br>     &amp;&amp; __is_pointer&lt;_OI&gt;::__value<br>     &amp;&amp; __are_same&lt;_ValueTypeI, _ValueTypeO&gt;::__value);<br><br>    <span class="hljs-keyword">return</span> std::__copy_move&lt;_IsMove, __simple,<br>      _Category&gt;::__copy_m(__first, __last, __result);<br>  &#125;<br></code></pre></td></tr></table></figure>可以看到<code>__copy_move_a</code>模板类调用并返回<code>__copy_move</code>，我们仍然继续进入该代码中：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>, <span class="hljs-keyword">typename</span>&gt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__copy_move</span><br>   &#123;<br>     <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _II, <span class="hljs-keyword">typename</span> _OI&gt;<br><span class="hljs-type">static</span> _OI<br>__copy_m(_II __first, _II __last, _OI __result)<br>&#123;<br>  <span class="hljs-keyword">for</span> (; __first != __last; ++__result, (<span class="hljs-type">void</span>)++__first)<br>    *__result = *__first;<br>  <span class="hljs-keyword">return</span> __result;<br>&#125;<br>   &#125;;<br></code></pre></td></tr></table></figure>我们这里抛开对各种类型的剖析和类型判断等问题，仅仅看上述代码，发现其具体的实现思路就是：遍历<code>__fisrt</code>到<code>__last</code>之间的空间，将其所对应的内容拷贝给<code>__result</code>所对应的空间，这就是<code>copy</code>函数最本质的思路，其实也不难理解，上面代码中的类型<code>_II</code>其实就是输入迭代器<code>InputInterator</code>的缩写，同样<code>_OI</code>就是输出迭代器<code>OutputInterator</code>的缩写。那么接下来我们通过简单的示例来说明该函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">//给list初始开辟5个空间大小</span><br><span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), l.<span class="hljs-built_in">begin</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:l)<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl; <span class="hljs-comment">//此时list的元素为：1 2 3 4 5</span><br></code></pre></td></tr></table></figure>我们给<code>vector</code>初始化五个元素，然后将<code>vector</code>容器的五个元素通过<code>copy</code>函数拷贝给<code>list</code>容器。需要注意的是，进行<code>copy</code>操作，那么目标内存中要有初始化空间才行，如上述代码创建<code>list</code>容器时，已经开辟了五个元素空间，若未进行初始化开辟，那么<code>copy</code>操作将是非法操作。</td></tr><tr class="even"><td><strong>copy_backward</strong><code>copy</code>函数从输出迭代器起始位置开始向后迭代，而本函数从输出迭代器的前一位开始向前迭代；输入三个参数，前两个参数与<code>copy</code>一致，第三个参数也为一个迭代器指向的内存，只不过相比于<code>copy</code>函数，<code>copy_backward</code>遍历的方向与<code>copy</code>相反。我们还是首先剖析其底层代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _BI1, <span class="hljs-keyword">typename</span> _BI2&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">inline</span> _BI2</span><br><span class="hljs-function">  <span class="hljs-title">copy_backward</span><span class="hljs-params">(_BI1 __first, _BI1 __last, _BI2 __result)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// concept requirements</span><br>    __glibcxx_function_requires(_BidirectionalIteratorConcept&lt;_BI1&gt;)<br>    __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept&lt;_BI2&gt;)<br>    __glibcxx_function_requires(_ConvertibleConcept&lt;<br>   <span class="hljs-keyword">typename</span> iterator_traits&lt;_BI1&gt;::value_type,<br>   <span class="hljs-keyword">typename</span> iterator_traits&lt;_BI2&gt;::value_type&gt;)<br>    __glibcxx_requires_valid_range(__first, __last);<br><br>    <span class="hljs-keyword">return</span> (std::__copy_move_backward_a2&lt;__is_move_iterator&lt;_BI1&gt;::__value&gt;<br>     (std::__miter_base(__first), std::__miter_base(__last),<br>      __result));<br>  &#125;<br></code></pre></td></tr></table></figure>上述代码和<code>copy</code>的代码很相似，返回<code>__copy_move_backward_a2</code>，我们跟进该函数，查看其内部代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> _IsMove, <span class="hljs-keyword">typename</span> _BI1, <span class="hljs-keyword">typename</span> _BI2&gt;<br>  <span class="hljs-keyword">inline</span> _BI2<br>  __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)<br>  &#123;<br>    <span class="hljs-keyword">return</span> _BI2(std::__copy_move_backward_a&lt;_IsMove&gt;<br>  (std::__niter_base(__first), std::__niter_base(__last),<br>   std::__niter_base(__result)));<br>  &#125;<br></code></pre></td></tr></table></figure><code>__copy_move_backward_a2</code>返回一个新的模板函数<code>copy_move_backward_a</code>，继续跟进该函数实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> _IsMove, <span class="hljs-keyword">typename</span> _BI1, <span class="hljs-keyword">typename</span> _BI2&gt;<br>  <span class="hljs-keyword">inline</span> _BI2<br>  __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)<br>  &#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;_BI1&gt;::value_type _ValueType1;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;_BI2&gt;::value_type _ValueType2;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;_BI1&gt;::iterator_category _Category;<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> __simple = (__is_trivial(_ValueType1)<br>     &amp;&amp; __is_pointer&lt;_BI1&gt;::__value<br>     &amp;&amp; __is_pointer&lt;_BI2&gt;::__value<br>     &amp;&amp; __are_same&lt;_ValueType1, _ValueType2&gt;::__value);<br><br>    <span class="hljs-keyword">return</span> std::__copy_move_backward&lt;_IsMove, __simple,<br>       _Category&gt;::__copy_move_b(__first,<br> __last,<br> __result);<br>  &#125;<br></code></pre></td></tr></table></figure>然后我们可以看到返回一个新的模板函数<code>__copy_move_backward</code>，我们继续跟进查看其实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>, <span class="hljs-keyword">typename</span>&gt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__copy_move_backward</span><br>   &#123;<br>     <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _BI1, <span class="hljs-keyword">typename</span> _BI2&gt;<br><span class="hljs-type">static</span> _BI2<br>__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)<br>&#123;<br>  <span class="hljs-keyword">while</span> (__first != __last)<br>    *--__result = *--__last;<br>  <span class="hljs-keyword">return</span> __result;<br>&#125;<br>   &#125;;<br></code></pre></td></tr></table></figure>终于在这一次，我们看到了<code>copy_backward</code>的具体实现，我们会以<code>__result</code>迭代器指向的内存为遍历起点的下一位，然后对其先进行<code>--</code>操作，再进行拷贝，并且改变<code>__last</code>迭代器，对其也进行<code>--</code>操作，直到<code>__first == __last</code>，拷贝结束。了解了<code>copy_backward</code>函数的具体思想后，我们在通过实践来演示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">15</span>)</span></span>;<br><span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), l.<span class="hljs-built_in">begin</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:l) <span class="hljs-comment">//输出 1 2 3 4 5 0 0 0 0 0 0 0 0 0 0</span><br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><span class="hljs-built_in">copy_backward</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), l.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:l) <span class="hljs-comment">//输出 1 2 3 4 5 0 0 0 0 0 1 2 3 4 5</span><br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td><strong>transform</strong><code>transform</code>函数有两种形式：第一种形式是在<code>copy</code>的基础上再执行进一步变换，因此其有四个参数，前三个参数和<code>copy</code>一致，即输入迭代器的首尾，输出迭代器的起始位置。<code>transform</code>还有第四个参数，即传入一个回调函数，用于对输出迭代器所指元素再进一步进行转换，<code>transform</code>源码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  *  @brief Perform an operation on a sequence.</span><br><span class="hljs-comment">  *  @ingroup mutating_algorithms</span><br><span class="hljs-comment">  *  @param  __first     An input iterator.</span><br><span class="hljs-comment">  *  @param  __last      An input iterator.</span><br><span class="hljs-comment">  *  @param  __result    An output iterator.</span><br><span class="hljs-comment">  *  @param  __unary_op  A unary operator.</span><br><span class="hljs-comment">  *  @return   An output iterator equal to @p __result+(__last-__first).</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  *  Applies the operator to each element in the input range and assigns</span><br><span class="hljs-comment">  *  the results to successive elements of the output sequence.</span><br><span class="hljs-comment">  *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the</span><br><span class="hljs-comment">  *  range @p [0,__last-__first).</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  *  @p unary_op must not alter its argument.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _InputIterator, <span class="hljs-keyword">typename</span> _OutputIterator,</span><br><span class="hljs-function">   <span class="hljs-keyword">typename</span> _UnaryOperation&gt;</span><br><span class="hljs-function">   _OutputIterator</span><br><span class="hljs-function">   <span class="hljs-title">transform</span><span class="hljs-params">(_InputIterator __first, _InputIterator __last,</span></span><br><span class="hljs-params"><span class="hljs-function">      _OutputIterator __result, _UnaryOperation __unary_op)</span></span><br><span class="hljs-function">   </span>&#123;<br>     <span class="hljs-comment">// concept requirements</span><br>     __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator&gt;)<br>     __glibcxx_function_requires(_OutputIteratorConcept&lt;_OutputIterator,<br>    <span class="hljs-comment">// &quot;the type returned by a _UnaryOperation&quot;</span><br>    __typeof__(__unary_op(*__first))&gt;)<br>     __glibcxx_requires_valid_range(__first, __last);<br><br>     <span class="hljs-keyword">for</span> (; __first != __last; ++__first, (<span class="hljs-type">void</span>)++__result)<br>*__result = __unary_op(*__first);<br>     <span class="hljs-keyword">return</span> __result;<br>   &#125;<br></code></pre></td></tr></table></figure>我们可以看到，<code>__unary_op</code>则是我们传入的回调函数，用于对<code>__first</code>迭代器指向的元素进行操作，操作的结果赋值给<code>*__result</code>。具体应用如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n*<span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><br>    <span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), l.<span class="hljs-built_in">begin</span>(), func);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:l)<br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//经过transform的func函数处理后 list中存放的元素为2 4 6 8 10</span><br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>那么<code>transform</code>的第二种形式相对来说较为繁琐，其本质是将两个区间对应元素进行某种操作，比如说目前有一个区间值为<code>0, 1, 2</code>，另一个区间值为<code>4, 5, 6</code>，目前要对两个区间进行加法操作，并将计算后的结果存放到指定容器中，那么得到的结果就是<code>4, 6, 8</code>。那么实际上第二种形式的<code>transform</code>就可以完成这样的任务，它总共有五个参数，前两个参数为输入迭代器首尾指定的某个区间，第三个参数为输入迭代器指向的另一个区间的起始位置，第四个参数则为输出迭代器的起始位置，第五个参数就是要执行的操作，通过回调函数的方式实现，具体源码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  *  @brief Perform an operation on corresponding elements of two sequences.</span><br><span class="hljs-comment">  *  @ingroup mutating_algorithms</span><br><span class="hljs-comment">  *  @param  __first1     An input iterator.</span><br><span class="hljs-comment">  *  @param  __last1      An input iterator.</span><br><span class="hljs-comment">  *  @param  __first2     An input iterator.</span><br><span class="hljs-comment">  *  @param  __result     An output iterator.</span><br><span class="hljs-comment">  *  @param  __binary_op  A binary operator.</span><br><span class="hljs-comment">  *  @return   An output iterator equal to @p result+(last-first).</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  *  Applies the operator to the corresponding elements in the two</span><br><span class="hljs-comment">  *  input ranges and assigns the results to successive elements of the</span><br><span class="hljs-comment">  *  output sequence.</span><br><span class="hljs-comment">  *  Evaluates @p</span><br><span class="hljs-comment">  *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each</span><br><span class="hljs-comment">  *  @c N in the range @p [0,__last1-__first1).</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  *  @p binary_op must not alter either of its arguments.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _InputIterator1, <span class="hljs-keyword">typename</span> _InputIterator2,</span><br><span class="hljs-function">   <span class="hljs-keyword">typename</span> _OutputIterator, <span class="hljs-keyword">typename</span> _BinaryOperation&gt;</span><br><span class="hljs-function">   _OutputIterator</span><br><span class="hljs-function">   <span class="hljs-title">transform</span><span class="hljs-params">(_InputIterator1 __first1, _InputIterator1 __last1,</span></span><br><span class="hljs-params"><span class="hljs-function">      _InputIterator2 __first2, _OutputIterator __result,</span></span><br><span class="hljs-params"><span class="hljs-function">      _BinaryOperation __binary_op)</span></span><br><span class="hljs-function">   </span>&#123;<br>     <span class="hljs-comment">// concept requirements</span><br>     __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator1&gt;)<br>     __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator2&gt;)<br>     __glibcxx_function_requires(_OutputIteratorConcept&lt;_OutputIterator,<br>    <span class="hljs-comment">// &quot;the type returned by a _BinaryOperation&quot;</span><br>    __typeof__(__binary_op(*__first1,*__first2))&gt;)<br>     __glibcxx_requires_valid_range(__first1, __last1);<br><br>     <span class="hljs-keyword">for</span> (; __first1 != __last1; ++__first1, (<span class="hljs-type">void</span>)++__first2, ++__result)<br>*__result = __binary_op(*__first1, *__first2);<br>     <span class="hljs-keyword">return</span> __result;<br>   &#125;<br></code></pre></td></tr></table></figure>我们可以看到，回调函数<code>__binary_op</code>传入的两个参数分别为两个区间的起始位置，我们通过对两个区间元素进行<code>__binary_op</code>中所实现的操作，并将操作后的结果给<code>__result</code>输出迭代器指向的内容，每次均遍历<code>__first1</code>和<code>__first2</code>输入迭代器，直到<code>__first1</code>指向<code>__last1</code>为止。那么我们也给第二种<code>transform</code>用法举一个简单的例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>, v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">3</span>, l.<span class="hljs-built_in">begin</span>(), func);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:l)<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//l中存放两个元素 分别为5 7  这两个值为1+4 2+5的结果</span><br></code></pre></td></tr></table></figure>我们也需要注意一点，在进行上述遍历两个区间并执行回调函数操作的时候，一定要注意各自的边界以及所存放的容器大小是否足够等问题。</td></tr><tr class="odd"><td><strong>replace</strong>该函数是对容器某区间中元素的值进行替换，有四个参数，前两个参数为某容器的迭代器首尾，第三个参数为元素原值，第四个参数为要替换的值，源码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ForwardIterator, <span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function">   <span class="hljs-type">void</span></span><br><span class="hljs-function">   <span class="hljs-title">replace</span><span class="hljs-params">(_ForwardIterator __first, _ForwardIterator __last,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> _Tp&amp; __old_value, <span class="hljs-type">const</span> _Tp&amp; __new_value)</span></span><br><span class="hljs-function">   </span>&#123;<br>     <span class="hljs-comment">// concept requirements</span><br>     __glibcxx_function_requires(_Mutable_ForwardIteratorConcept&lt;<br>  _ForwardIterator&gt;)<br>     __glibcxx_function_requires(_EqualOpConcept&lt;<br>    <span class="hljs-keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type, _Tp&gt;)<br>     __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp,<br>    <span class="hljs-keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type&gt;)<br>     __glibcxx_requires_valid_range(__first, __last);<br><br>     <span class="hljs-keyword">for</span> (; __first != __last; ++__first)<br><span class="hljs-keyword">if</span> (*__first == __old_value)<br>  *__first = __new_value;<br>   &#125;<br></code></pre></td></tr></table></figure>可以看到<code>__first</code>迭代器在遍历容器时，如果找到了元素原值<code>__old_value</code>，就将其替换为新值<code>__new_value</code>。演示代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-built_in">replace</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, <span class="hljs-number">13</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v) &#123;<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出1 2 13 4 13 将所有3替换成13</span><br>&#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td><strong>replace_copy</strong>该函数相比<code>replace</code>函数，增加了一个输出迭代器参数，<code>replace</code>是对原始容器中的值进行替换操作，而<code>replace_copy</code>是拷贝替换，具体细节看下面源码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _InputIterator, <span class="hljs-keyword">typename</span> _OutputIterator, <span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">inline</span> _OutputIterator</span><br><span class="hljs-function">  <span class="hljs-title">replace_copy</span><span class="hljs-params">(_InputIterator __first, _InputIterator __last,</span></span><br><span class="hljs-params"><span class="hljs-function"> _OutputIterator __result,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">const</span> _Tp&amp; __old_value, <span class="hljs-type">const</span> _Tp&amp; __new_value)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// concept requirements</span><br>    __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator&gt;)<br>    __glibcxx_function_requires(_OutputIteratorConcept&lt;_OutputIterator,<br>   <span class="hljs-keyword">typename</span> iterator_traits&lt;_InputIterator&gt;::value_type&gt;)<br>    __glibcxx_function_requires(_EqualOpConcept&lt;<br>   <span class="hljs-keyword">typename</span> iterator_traits&lt;_InputIterator&gt;::value_type, _Tp&gt;)<br>    __glibcxx_requires_valid_range(__first, __last);<br><br>    <span class="hljs-keyword">return</span> std::__replace_copy_if(__first, __last, __result,<br>__gnu_cxx::__ops::__iter_equals_val(__old_value),<br>      __new_value);<br>  &#125;<br></code></pre></td></tr></table></figure>我们发现，<code>replace_copy</code>实际返回了一个函数<code>__replace_copy_if</code>的调用结果，该函数传递了一个条件判断函数<code>__iter_equals_val</code>，用于查找要替换的值是否存在，跟进到返回函数<code>__replace_copy_if</code>，我们看其具体实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _InputIterator, <span class="hljs-keyword">typename</span> _OutputIterator,<br>   <span class="hljs-keyword">typename</span> _Predicate, <span class="hljs-keyword">typename</span> _Tp&gt;<br>   _OutputIterator<br>   __replace_copy_if(_InputIterator __first, _InputIterator __last,<br>      _OutputIterator __result,<br>      _Predicate __pred, <span class="hljs-type">const</span> _Tp&amp; __new_value)<br>   &#123;<br>     <span class="hljs-keyword">for</span> (; __first != __last; ++__first, (<span class="hljs-type">void</span>)++__result)<br><span class="hljs-keyword">if</span> (__pred(__first))<br>  *__result = __new_value;<br><span class="hljs-keyword">else</span><br>  *__result = *__first;<br>     <span class="hljs-keyword">return</span> __result;<br>   &#125;<br></code></pre></td></tr></table></figure>那么这个<code>__pred</code>就是我们的判断条件，判断迭代器<code>__first</code>指向的值是否为<code>__old_value</code>，如果是的话，就将<code>__old_value</code>替换成<code>__new_value</code>写入到新容器当中，若不是，则将迭代器<code>__first</code>指向的旧容器中的值拷贝至新容器中。示例如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><br><span class="hljs-built_in">replace_copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), l.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">3</span>, <span class="hljs-number">13</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:l)<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//list输出 1 2 13 4 13</span><br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v)<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//vector输出 1 2 3 4 3 源容器内容不发生改变</span><br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure></td></tr><tr class="odd"><td><strong>replace_copy_if</strong>可以看到在<code>replace_copy</code>函数内部源码中有<code>__replace_copy_if</code>这样的函数，该函数传入的参数中有一个判断函数，用于比较<code>__old_value</code>是否等于输入迭代器<code>__first</code>所指向的位置元素。那么<code>replace_copy_if</code>函数，其实就是用户自定义比较条件，然后进行拷贝替换操作，具体源码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _InputIterator, <span class="hljs-keyword">typename</span> _OutputIterator,</span><br><span class="hljs-function">  <span class="hljs-keyword">typename</span> _Predicate, <span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">inline</span> _OutputIterator</span><br><span class="hljs-function">  <span class="hljs-title">replace_copy_if</span><span class="hljs-params">(_InputIterator __first, _InputIterator __last,</span></span><br><span class="hljs-params"><span class="hljs-function">    _OutputIterator __result,</span></span><br><span class="hljs-params"><span class="hljs-function">    _Predicate __pred, <span class="hljs-type">const</span> _Tp&amp; __new_value)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// concept requirements</span><br>    __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator&gt;)<br>    __glibcxx_function_requires(_OutputIteratorConcept&lt;_OutputIterator,<br>   <span class="hljs-keyword">typename</span> iterator_traits&lt;_InputIterator&gt;::value_type&gt;)<br>    __glibcxx_function_requires(_UnaryPredicateConcept&lt;_Predicate,<br>   <span class="hljs-keyword">typename</span> iterator_traits&lt;_InputIterator&gt;::value_type&gt;)<br>    __glibcxx_requires_valid_range(__first, __last);<br><br>    <span class="hljs-keyword">return</span> std::__replace_copy_if(__first, __last, __result,<br>__gnu_cxx::__ops::__pred_iter(__pred),<br>      __new_value);<br>  &#125;<br></code></pre></td></tr></table></figure>我们发现，该实现和<code>replace_copy</code>基本一致，区别在于<code>__replace_copy_if</code>中传递的是用户自定义的回调<code>__pred</code>。具体案例如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">13</span>, <span class="hljs-number">4</span>, <span class="hljs-number">14</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><br>    <span class="hljs-built_in">replace_copy_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), l.<span class="hljs-built_in">begin</span>(), func, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:l)<br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>通过<code>replace_copy_if</code>函数，将<code>vector</code>中元素拷贝至<code>list</code>中，并且判断若元素小于<code>10</code>，则替换为<code>0</code>拷贝至<code>list</code>，因此输出到<code>list</code>中的值为<code>0, 0, 13, 0, 14</code>。</td></tr><tr class="even"><td>以上是对一些非变动性算法和变动性算法的说明，接下来会主要说明： *移动性算法：<code>remove</code> * 变序性算法：<code>rotate</code> *排序算法：<code>sort</code> * 已序区间算法： - <code>lower_bound</code>- <code>upper_bound</code> * 数值算法：<code>acumulate</code></td></tr><tr class="odd"><td><strong>remove</strong><code>remove</code>顾名思义移除元素，但是这不是真正的移除，而是将指定要移除的元素覆盖掉，内存空间仍然不变，通常想要做到真正意义上的移除，需要配合使用<code>erase</code>函数。<code>remove</code>函数有三个参数，前两个参数为某容器的迭代器首尾区间，第三个参数为要移除的容器元素。源码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ForwardIterator, <span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">inline</span> _ForwardIterator</span><br><span class="hljs-function">  <span class="hljs-title">remove</span><span class="hljs-params">(_ForwardIterator __first, _ForwardIterator __last,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-type">const</span> _Tp&amp; __value)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// concept requirements</span><br>    __glibcxx_function_requires(_Mutable_ForwardIteratorConcept&lt;<br>  _ForwardIterator&gt;)<br>    __glibcxx_function_requires(_EqualOpConcept&lt;<br>   <span class="hljs-keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type, _Tp&gt;)<br>    __glibcxx_requires_valid_range(__first, __last);<br><br>    <span class="hljs-keyword">return</span> std::__remove_if(__first, __last,<br>__gnu_cxx::__ops::__iter_equals_val(__value));<br>  &#125;<br></code></pre></td></tr></table></figure>该源码返回的是<code>__remove_if</code>模板函数返回的结果，可以看到<code>__remove_if</code>中传入了与<code>replace_copy</code>一样的<code>__iter_equals_val</code>，这其实是一个模板类对象，用于查找等于<code>__value</code>与否这样的一个操作，这里先不深究具体细节。我们继续进入<code>__remove_if</code>中，查看<code>remove</code>模板函数的具体实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ForwardIterator, <span class="hljs-keyword">typename</span> _Predicate&gt;<br>   _ForwardIterator<br>   __remove_if(_ForwardIterator __first, _ForwardIterator __last,<br>_Predicate __pred)<br>   &#123;<br>     __first = std::__find_if(__first, __last, __pred);<br>     <span class="hljs-keyword">if</span> (__first == __last)<br><span class="hljs-keyword">return</span> __first;<br>     _ForwardIterator __result = __first;<br>     ++__first;<br>     <span class="hljs-keyword">for</span> (; __first != __last; ++__first)<br><span class="hljs-keyword">if</span> (!__pred(__first))<br>  &#123;<br>    *__result = _GLIBCXX_MOVE(*__first);<br>    ++__result;<br>  &#125;<br>     <span class="hljs-keyword">return</span> __result;<br>   &#125;<br></code></pre></td></tr></table></figure>可以看到，<code>remove</code>所完成的操作是：找到第一个我们要移除的值的位置，用<code>__first</code>迭代器指向它，并让<code>__result</code>也初始指向要移除值的位置，然后遍历<code>__first</code>指针，当<code>__first</code>指向的不是要移除的元素时，把<code>__first</code>指向的元素拷贝给<code>__result</code>指向的元素（覆盖操作），然后给这两个迭代器<code>++</code>，若<code>__first</code>只向的是要移除的元素，那就不进行覆盖操作，继续将<code>__first</code>进行<code>++</code>操作即可。<code>remove</code>模板函数返回最后一个有效位置的下一位，举例来说明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">6</span>)</span></span>;<br><span class="hljs-built_in">remove</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>); <span class="hljs-comment">//移动完毕后前四个位置确定 v元素为 1 2 4 5 4 5</span><br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>我们看到结果，发现虽然进行了覆盖操作，但没有真正意义上的删除掉后面的空间，于是可以配合<code>erase</code>函数进行删除操作，<code>erase</code>函数只能接受迭代器，传入两个参数，分别为要删除的迭代器的首尾，恰好<code>remove</code>函数返回的是有效位置的下一位，也就是<code>erase</code>要删除的起点位置，如果进行下面的操作，即可删除多余空间：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">6</span>)</span></span>;<br><span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//v的元素为 1 2 4 5</span><br></code></pre></td></tr></table></figure> 以上就是<code>remove</code>函数的基本用法。</td></tr><tr class="odd"><td><strong>rotate</strong><code>rotate</code>函数总共有三个迭代器参数，其中前两个为某个左闭右开区间的首尾，第三个参数为一个新位置，我们会将这个区间置换到第三个参数指向的位置起点处，直接看示例便于理解：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">6</span>)</span></span>;<br><br><span class="hljs-built_in">rotate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>, v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">3</span>); <span class="hljs-comment">//v内容为 3 1 2 4 5 6</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v)<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>可以看到，<code>rotate</code>函数将前两个元素<code>1</code>和<code>2</code>置换到了<code>v.begin()+3</code>，即第四个位置处，因此最后的顺序就是<code>3, [1, 2], 4, 5, 6</code>。</td></tr><tr class="even"><td><strong>sort</strong>sort使用较为频繁，有两种形式，第一种形式即两个迭代器参数，默认排序从小到大。第二种形式就是加了一个条件函数，可以按照用户自定义方式排序，同时也可以传入模板参数，如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(..., ..., <span class="hljs-built_in">less</span>&lt;T&gt;()); <span class="hljs-comment">//默认按照从小到大排序</span><br><span class="hljs-built_in">sort</span>(..., ..., <span class="hljs-built_in">greater</span>&lt;T&gt;()); <span class="hljs-comment">//默认按照从大到小排序</span><br></code></pre></td></tr></table></figure>也可自定义<code>lambda</code>表达式，对上述方法改写如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(..., ..., [](<span class="hljs-type">int</span> &amp;left, <span class="hljs-type">int</span> &amp;right)-&gt;<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> left &lt; right;&#125;); <span class="hljs-comment">//从小到大排序</span><br><span class="hljs-built_in">sort</span>(..., ..., [](<span class="hljs-type">int</span> &amp;left, <span class="hljs-type">int</span> &amp;right)-&gt;<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> right &gt; left;&#125;); <span class="hljs-comment">//从大到小排序</span><br></code></pre></td></tr></table></figure> <code>sort</code>排序算法就不过多说明了。</td></tr><tr class="odd"><td><strong>lower_bound/upper_bound</strong><code>lower_bound()</code>搜索第一个<strong>大于等于给定值</strong>的元素，如果要插入给定值，保持区间有序性，返回第一个插入的位置（<strong>其实就是找大于等于给定值的第一个位置</strong>）。<img src="media/16224350022491/16376739050826.jpg" alt="-w969" /></td></tr><tr class="even"><td><code>upper_bound()</code>搜索第一个<strong>大于给定值</strong>的元素，如果要插入给定值，保持区间有序性，返回最后可插入的位置（<strong>其实就是找大于最后一个给定值的第一个位置</strong>）。<img src="media/16224350022491/16376741008780.jpg" alt="-w982" /></td></tr><tr class="odd"><td>一定需要注意：<code>lower_bound()</code>和<code>upper_bound()</code>都是利用二分查找的方法在一个已经排好序的数组中进行查找，所以在使用这两个函数时，一定要保持迭代器是有序的，可以从大到小排好序，也可以从小到大排好序，但必须有序。示例用法如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a+<span class="hljs-number">6</span>)</span></span>;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br>it = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span>(it != v.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; it-v.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出的位置是2 即第一个10对应的位置</span><br>&#125;<br><br>it = <span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span>(it != v.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; it-v.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出的位置是4 即15对应的位置</span><br>&#125;<br></code></pre></td></tr></table></figure></td></tr><tr class="even"><td>在使用<code>lower_bound/upper_bound</code>函数容易出错的点是，比如对<code>&#123;10, 11, 12, 13, 13, 15&#125;</code>这样一组整数，存放在<code>vector&lt;int&gt; v</code>当中，若使用如下语句：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br>it = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">22</span>);<br></code></pre></td></tr></table></figure>该语句返回的位置是第一个大于等于<code>22</code>的数的位置，因为有效内存中未找到，所以迭代器最终返回的位置是有效位置的下一位，即<code>v.end()</code>，那么此时用户若访问迭代器所指向的内容，则会出现非法访问的问题，因此每次在使用该函数时要记得判断<code>it</code>是否等于<code>v.end()</code>，对于<code>upper_bound</code>也是如此，要记得避免越界访问。</td></tr><tr class="odd"><td><strong>accumulate</strong>累加函数，传递三个参数，前两个参数为迭代器首尾，第三个参数为额外增加的值。需要注意的是，这个函数需要头文件<code>#include &lt;numeric&gt;</code>，我们看一下源码实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _InputIterator, <span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function">   <span class="hljs-keyword">inline</span> _Tp</span><br><span class="hljs-function">   <span class="hljs-title">accumulate</span><span class="hljs-params">(_InputIterator __first, _InputIterator __last, _Tp __init)</span></span><br><span class="hljs-function">   </span>&#123;<br>     <span class="hljs-comment">// concept requirements</span><br>     __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator&gt;)<br>     __glibcxx_requires_valid_range(__first, __last);<br><br>     <span class="hljs-keyword">for</span> (; __first != __last; ++__first)<br>__init = __init + *__first;<br>     <span class="hljs-keyword">return</span> __init;<br>   &#125;<br></code></pre></td></tr></table></figure>可以看到它会进行遍历操作，并且累加结果存放值<code>__init</code>当中，并返回，接下来我们来看下具体实例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(begin(a), end(a))</span></span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>) &lt;&lt; endl; <span class="hljs-comment">//1+2+3+4+5+0 打印15</span><br>cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">10</span>) &lt;&lt; endl; <span class="hljs-comment">//1+2+3+4+5+10 打印25</span><br></code></pre></td></tr></table></figure>除了以上用法，<code>accumulate</code>可以自定义算子，我们可以实现一个累乘，即第四个参数为一个回调函数，接下来我们实现一个累乘方法，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mult</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(begin(a), end(a))</span></span>;<br>    cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>, mult) &lt;&lt; endl; <span class="hljs-comment">//结果为1x2x3x4x5x1 = 120</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="函数对象">函数对象</h3><ul><li>函数对象（<code>function object</code>）也称为仿函数（<code>functor</code>）</li><li>一个行为类似函数的对象，它可以没有参数，也可以带有若干参数</li><li><strong>任何重载了调用运算符<code>operator()</code>的类的对象都满足函数对象的特征</strong></li><li>函数对象可以把它称之为<code>smart function</code></li><li><code>STL</code>中也定义了一些标准的函数对象，如果以功能划分，可以分为算术运算、关系运算、逻辑运算三大类。为了调用这些标准函数对象，需要包含头文件<code>&lt;functional&gt;</code></li></ul><h4 id="函数对象在容器的应用">函数对象在容器的应用</h4><p>其实在<code>map</code>容器中，就是用到了仿函数，我们可以查看<code>map</code>类部分源码，如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Key, <span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Compare = std::less&lt;_Key&gt;,<br>   <span class="hljs-keyword">typename</span> _Alloc = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> _Key, _Tp&gt; &gt; &gt;<br>  <span class="hljs-keyword">class</span> map<br>  &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> _Keykey_type;<br>    <span class="hljs-keyword">typedef</span> _Tpmapped_type;<br>    <span class="hljs-keyword">typedef</span> std::pair&lt;<span class="hljs-type">const</span> _Key, _Tp&gt;value_type;<br>    <span class="hljs-keyword">typedef</span> _Comparekey_compare;<br>    <span class="hljs-keyword">typedef</span> _Allocallocator_type;<br><br>  ... <span class="hljs-comment">//省略</span><br>  &#125;<br></code></pre></td></tr></table></figure>以上我们只需看到<code>_Compare</code>类型实际上是<code>std::less&lt;_Key&gt;</code>这样一个模板，我们跟进去会发现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">less</span> : <span class="hljs-keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="hljs-type">bool</span>&gt;<br>  &#123;<br>    <span class="hljs-function">_GLIBCXX14_CONSTEXPR</span><br><span class="hljs-function">    <span class="hljs-type">bool</span></span><br><span class="hljs-function">    <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> _Tp&amp; __x, <span class="hljs-type">const</span> _Tp&amp; __y)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __x &lt; __y; &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>其实<code>less是一个模板类</code>，并且该类由于重载了括号，可以作为仿函数去使用，那么<code>map</code>在进行插入<code>key-value</code>时，会根据<code>key</code>进行相应的排序，以上就是其排序所用到的比较，我们可以看到<code>map</code>的比较函数默认为<code>std::less&lt;_Key&gt;</code>，但是我们用户也可以传入比较的方法，如下为两种由大到小方式排序的写法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mygreater</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left &gt; right;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//map的比较排序less是通过模板仿函数实现的 我们也可自定义传入参数</span><br>    <span class="hljs-comment">// map&lt;int, string, greater&lt;int&gt; &gt; m;</span><br>    map&lt;<span class="hljs-type">int</span>, string, Mygreater&gt; m; <span class="hljs-comment">//按照int 由大到小排序</span><br><br>    m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;aaa&quot;</span>));<br>    m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;ccc&quot;</span>));<br>    m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;bbb&quot;</span>));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:m)<br>        cout &lt;&lt; x.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; x.second &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>我们可以传入系统写好的模板<code>greater&lt;type&gt;</code>，也可以自定义一个模板类或一般类传入到<code>map</code>容器当中去。</p><h4 id="函数对象在算法的应用">函数对象在算法的应用</h4><p>在我学到这里的时候我不得不说<code>C++</code>真的太屌了！我们前面讲到<code>for_each</code>可以对容器元素进行操作，那么第三个参数传递一个模板函数，实际上第三个参数是个<code>typename</code>类型，我们不仅仅可以传递模板函数，传递自定义函数，也可以传递仿函数，总之，牛逼就完事儿了，接下来我们使用模板去编写一个如下示例，用于打印和改变<code>vector</code>容器中元素的值：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TYPE;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T a)</span> </span>&#123;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add3</span><span class="hljs-params">(T &amp;a)</span> </span>&#123;<br>    a += <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintObj</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(T a)</span> </span>&#123; <span class="hljs-comment">//仿函数 用于打印</span><br>        cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    TYPE a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-function">vector&lt;TYPE&gt; <span class="hljs-title">v</span><span class="hljs-params">(begin(a), end(a))</span></span>;<br><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), print&lt;TYPE&gt;); <span class="hljs-comment">//通过一般的模板函数实现打印 也可用普通函数实现</span><br>    cout &lt;&lt; endl;<br><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), Add3&lt;TYPE&gt;); <span class="hljs-comment">//对vector元素进行加三操作 变为4 5 6 7 8</span><br><br>    <span class="hljs-comment">// for_each(v.begin(), v.end(), print&lt;TYPE&gt;);</span><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">PrintObj</span>&lt;TYPE&gt;()); <span class="hljs-comment">//传递仿函数打印vector</span><br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>其实以上实现均可不需要模板来实现，需要注意的是对于这类算法而言，我们既可以传递自定义函数，也可传递模板函数，甚至可以传递仿函数去实现我们想要的操作。</p><h4 id="函数对象在智能指针中的应用">函数对象在智能指针中的应用</h4><p>智能指针用于对堆内存的自动释放，一般在<code>unique_ptr</code>等一系列智能指针中，析构采用<code>delete ptr</code>的方式，若此时智能指针传入的堆空间为连续空间，那么<code>delete ptr</code>就只能进行单个空间的内存释放，会出现内存泄漏；同样，若我们需要智能指针去管理一个文件，那么释放资源就不能为<code>delete</code>，而是<code>close</code>关闭文件句柄。因此我们需要自定义智能指针的删除器，智能指针的删除器其实也是一个模板类，使用函数对象将该模版类编为一个模板仿函数，我们可以看下智能指针<code>unique_ptr</code>的源码，其内部自定义了一个删除器<code>default_delete&lt;_Tp&gt;</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;<br>  <span class="hljs-keyword">class</span> unique_ptr<br>  &#123; ... &#125;<br></code></pre></td></tr></table></figure></p><p>我们通过函数对象的方式，传入一个新的模板仿函数，具体代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDeletor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T *ptr)</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;call MyDeletor.operator()&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span> []ptr;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileDeletor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T *ptr)</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;call MyFileDeletor.operator()&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">fclose</span>(ptr);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    unique_ptr&lt;<span class="hljs-type">int</span>, MyDeletor&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ptr1</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>]); <span class="hljs-comment">//delete []ptr;</span><br>    unique_ptr&lt;FILE, MyFileDeletor&lt;FILE&gt;&gt; <span class="hljs-built_in">ptr2</span>(<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)); <span class="hljs-comment">//管理文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>此时当我们<code>new int[100]</code>，当资源要被释放时，会调用<code>MyDeletor</code>类的重载<code>operator(T *ptr) const</code>，执行<code>delete []ptr</code>释放连续堆空间；当我们打开一个文件后，当最终资源要被释放时，会调用<code>MyFileDeletor</code>类的重载<code>operator(T *ptr) const</code>，关闭文件句柄。当然这种方式需要定义额外的函数对象类型，不推荐，可以用<code>C++11</code>提供的函数对象<code>function</code>和<code>lambda</code>表达式更好的处理自定义删除器，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// template&lt;typename T&gt;</span><br><span class="hljs-comment">// class MyDeletor &#123;</span><br><span class="hljs-comment">// public:</span><br><span class="hljs-comment">//     void operator()(T *ptr) const &#123;</span><br><span class="hljs-comment">//         cout &lt;&lt; &quot;call MyDeletor.operator()&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//         delete []ptr;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-comment">// template&lt;typename T&gt;</span><br><span class="hljs-comment">// class MyFileDeletor &#123;</span><br><span class="hljs-comment">// public:</span><br><span class="hljs-comment">//     void operator()(T *ptr) const &#123;</span><br><span class="hljs-comment">//         cout &lt;&lt; &quot;call MyFileDeletor.operator()&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//         fclose(ptr);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// unique_ptr&lt;int, MyDeletor&lt;int&gt;&gt; ptr1(new int[100]); //delete []ptr;</span><br>    <span class="hljs-comment">// unique_ptr&lt;FILE, MyFileDeletor&lt;FILE&gt;&gt; ptr2(fopen(&quot;data.txt&quot;, &quot;w&quot;));</span><br>    <span class="hljs-comment">// 自定义智能指针删除器，释放数组资源</span><br>    unique_ptr&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span> *)&gt;&gt; <span class="hljs-built_in">ptr1</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>], <br>        [](<span class="hljs-type">int</span> *p)-&gt;<span class="hljs-type">void</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;call lambda release new int[100]&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">delete</span> []p;<br>        &#125;<br>    );<br>    <br>    <span class="hljs-comment">// 自定义智能指针删除器，关闭文件资源</span><br>    unique_ptr&lt;FILE, function&lt;<span class="hljs-type">void</span>(FILE *)&gt;&gt; <span class="hljs-built_in">ptr2</span>(<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>),<br>        [](FILE *p)-&gt;<span class="hljs-type">void</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;call lambda release file data.txt&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">fclose</span>(p);<br>        &#125;<br>    );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="c11-function">C++11 function</h4><p><code>function</code>函数对象接收的模板参数类型必须是一个函数（这个函数可以是普通函数，可以是模板函数，可以是<code>lambda</code>表达式，也可以是类成员方法如函数对象或模板函数对象（函数对象可以理解为对某个类的成员函数方法<code>operator()</code>进行函数调用）或者普通的成员函数，静态的成员函数），那么其实<code>function</code>模板的用法和<code>C</code>中回调函数用法很像，只不过它的本质是一个函数对象（底层是通过函数指针封装的，并通过<code>operator()</code>调用）。当一个参数传递需要传递一个普通函数、模板函数、函数对象或模板函数对象或者说是成员函数、静态成员函数等等，我们可以使用<code>function</code>去简化调用，<strong>那么<code>function</code>函数对象可以接收函数对象，也必然可以是类成员函数，静态函数等。只不过想要调用成员函数，必须创建一个类对象才可以，而不仅仅是使用临时对象，但是调用函数对象时只需要创建临时对象即可</strong>。<code>function</code>的用法示例如下，主要介绍<code>function</code>在普通函数、模板函数、<code>lambda</code>表达式、函数对象以及模板函数对象中的应用。</p><p><strong>普通函数：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;hello world!&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_str</span><span class="hljs-params">(string str)</span> </span>&#123;cout &lt;&lt; str &lt;&lt; endl;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    function&lt;<span class="hljs-type">void</span>()&gt; func1 = &amp;hello;<br>    <span class="hljs-comment">// function&lt;void()&gt; func1(&amp;hello); // 两种调用方法均可</span><br>    <span class="hljs-built_in">func1</span>(); <span class="hljs-comment">//调用func1.operator()() ==&gt; void hello()</span><br>    function&lt;<span class="hljs-type">void</span>(string)&gt; func2 = &amp;hello_str;<br>    <span class="hljs-built_in">func2</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">//调用func2.operator()(string) ==&gt; void hello_str(string)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>模板函数：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func1 = sum&lt;<span class="hljs-type">int</span>&gt;;<br>    <span class="hljs-comment">//调用func1.operator()(int, int) ==&gt; int sum(int, int);</span><br>    cout &lt;&lt; <span class="hljs-built_in">func1</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) &lt;&lt; endl; <span class="hljs-comment">//输出8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>lambda表达式：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func1 = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">func1</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) &lt;&lt; endl; <span class="hljs-comment">//打印8 调用func1.operator()(int, int) ==&gt; 调用lambda表达式返回求和结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>函数对象：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintAdd1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sum : &quot;</span> &lt;&lt; left + right &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func1 = <span class="hljs-built_in">PrintAdd1</span>(); <span class="hljs-comment">//调用默认无参构造函数创建匿名类对象给func1</span><br>    <span class="hljs-built_in">func1</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">//func1.operator()(int, int) ==&gt; 调用void PrintAdd1.operator(int, int)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>模板函数对象：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintAdd2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T left, T right)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sum : &quot;</span> &lt;&lt; left + right &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func1 = <span class="hljs-built_in">PrintAdd2</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">//调用默认无参构造函数创建匿名模板类对象给func1</span><br>    <span class="hljs-built_in">func1</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">//func1.operator()(int, int) ==&gt; 调用void PrintAdd2.operator()(int, int)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>类静态成员函数：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticClass1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">hello_static</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        cout &lt;&lt; s &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    function&lt;<span class="hljs-type">void</span>(string)&gt; func1 = &amp;StaticClass1::hello_static;<br>    <span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">//func1.operator()(string) ==&gt; 调用void hello_static(string)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>模板类静态成员函数：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticClass2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">hello_static</span><span class="hljs-params">(T out)</span> </span>&#123;<br>        cout &lt;&lt; out &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    function&lt;<span class="hljs-type">void</span>(string)&gt; func1 = &amp;StaticClass2&lt;string&gt;::hello_static;<br>    <span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;static.. hello world&quot;</span>); <span class="hljs-comment">//func1.operator()(string) ==&gt; 调用void StaticClass2&lt;string&gt;::hello_static(string)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>普通类成员函数：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        cout &lt;&lt; str &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// function&lt;void(Test *, string)&gt; func = &amp;Test::hello;</span><br>    <span class="hljs-comment">// func(&amp;Test(), &quot;call Test::hello&quot;); //这种第一个参数传递匿名对象的方法在GCC8.4下不可行 在vs2017下可行 不建议使用匿名对象</span><br>    Test test; <span class="hljs-comment">//定义对象</span><br>    function&lt;<span class="hljs-type">void</span>(Test *, string)&gt; func1 = &amp;Test::hello;<br>    <span class="hljs-built_in">func1</span>(&amp;test, <span class="hljs-string">&quot;call Test::hello&quot;</span>); <span class="hljs-comment">//func1.operator(Test *, string) ==&gt; 调用void Test::hello(string)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>模板类成员函数：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(T str)</span> </span>&#123;<br>        cout &lt;&lt; str &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test2&lt;string&gt; test2;<br>    function&lt;<span class="hljs-type">void</span>(Test2&lt;string&gt; *, string)&gt; func1 = &amp;Test2&lt;string&gt;::hello;<br>    <span class="hljs-built_in">func1</span>(&amp;test2, <span class="hljs-string">&quot;call template Test::hello&quot;</span>); <span class="hljs-comment">//func1.operator(Test2 *, string) ==&gt; 调用void Test2&lt;string&gt;::hello(string)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>以上则是<code>function</code>模板函数对象的简单应用，可以看到我们所调用的均为<code>function</code>对象的<code>operator()(Args arg1, ...)</code>重载函数。特别是对类成员方法调用时，需要首先有这个类对象，在对函数对象的调用时，<code>function</code>对象初始化也通过构造函数创建了匿名的类对象。</p><p><strong><code>function</code>的底层原理：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123;cout &lt;&lt; str &lt;&lt; endl;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    function&lt;<span class="hljs-type">void</span>(string)&gt; func1 = hello;<br>    <span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>以上为<code>function</code>的基本用法，但其实<code>function</code>的实现用到了部分模板特例化方法，我们首先实现一个简单的<code>myfunction</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function函数对象类型的实现原理</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123;cout &lt;&lt; str &lt;&lt; endl;&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fty&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span> &#123;&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> A1&gt; <span class="hljs-comment">//模板特例化 特例化接收一个函数 参数A1 返回值R</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">R</span>(A1)&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// typedef R(*PFUNC)(A1);</span><br>    <span class="hljs-keyword">using</span> PFUNC = <span class="hljs-built_in">R</span>(*)(A1); <span class="hljs-comment">//指定PFUNC为函数指针类型</span><br><br>    <span class="hljs-built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) &#123;&#125;<br>    <span class="hljs-function">R <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(A1 arg)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _pfunc(arg); <span class="hljs-comment">//这里其实就通过函数指针去调用参数类型为A1 返回值为R的函数</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    PFUNC _pfunc;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// myfunction&lt;void(string)&gt; func1 = hello;</span><br>    <span class="hljs-function">myfunction&lt;<span class="hljs-title">void</span><span class="hljs-params">(string)</span>&gt; <span class="hljs-title">func1</span><span class="hljs-params">(hello)</span></span>;<br>    <span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// R func1.operator()(A1)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>可以看到<code>function</code>使用模板部分特例化来接收传递进来的参数，分别作为函数指针的返回值和形参，并通过这些接收到的类型，调用函数指针指向的函数，实现对具体函数的调用。但是有个问题就是如果此时接收两个形参，就要重新改写为有两个形参传入的模板特例化中，如果形参有三个？四个？八九十个呢？就得重复很多代码，这样必定是不可行的，因此我们使用<code>C++</code>中的可变参数类型，具体用法如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123;cout &lt;&lt; str &lt;&lt; endl;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a + b;&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fty&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span> &#123;&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... A&gt; <span class="hljs-comment">// typename... 说明A表示的不是一个类型 是一组类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">R</span>(A...)&gt; &#123;         <span class="hljs-comment">// A... 为可变参数类型</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// typedef R(*PFUNC)(A1);</span><br>    <span class="hljs-keyword">using</span> PFUNC = <span class="hljs-built_in">R</span>(*)(A...);       <span class="hljs-comment">// PFUNC为一组可变参数函数指针</span><br><br>    <span class="hljs-built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) &#123;&#125;<br>    <span class="hljs-function">R <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(A... arg)</span> </span>&#123;        <span class="hljs-comment">// arg为可变参数类型的参数</span><br>        <span class="hljs-keyword">return</span> _pfunc(arg...);      <span class="hljs-comment">// 这里接收多个arg arg为可变参数类型 所以在arg后端加上...</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    PFUNC _pfunc;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">myfunction&lt;<span class="hljs-title">void</span><span class="hljs-params">(string)</span>&gt; <span class="hljs-title">func1</span><span class="hljs-params">(hello)</span></span>;<br>    <span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// R func1.operator()(A1)</span><br>    <br>    <span class="hljs-function">myfunction&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">func2</span><span class="hljs-params">(sum)</span></span>;<br>    cout &lt;&lt; <span class="hljs-built_in">func2</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过在模板中使用<code>typename... A</code>告知<code>A</code>表示的是一组类型而非单个类型，然后可变参数类型则为<code>A...</code>，创建可变参数<code>arg</code>并在其使用时改写为<code>arg...</code>表示传入过个参数。</p><h4 id="stl内置的函数对象">STL内置的函数对象</h4><p>以下为<code>STL</code>内置的函数对象，均为模板仿函数，其实现在<code>stl_function.h</code>当中。<img src="media/16224350022491/16377745722278.jpg" alt="-w1260" /></p><h4 id="lambda表达式">Lambda表达式</h4><p>以下代码为一个<code>Lambda</code>表达式的使用，调用<code>func1()</code>函数对象执行<code>Lambda</code>表达式的功能：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">C++11 函数对象的升级版 =&gt; lambda表达式</span><br><span class="hljs-comment">函数对象的缺点：</span><br><span class="hljs-comment">使用在泛型算法传递 比较性质/自定义操作 优先级队列 智能指针删除器 需要定义类</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">lambda表达式的语法：</span><br><span class="hljs-comment">[捕获外部变量](形参列表)-&gt;返回值&#123;操作代码&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func1 = []()-&gt;<span class="hljs-type">void</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;&#125;;<br>    <span class="hljs-built_in">func1</span>(); <span class="hljs-comment">//输出hello world</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>其实上述功能就等价于： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda01 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestLambda01</span>() &#123;&#125;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()() <span class="hljs-type">const</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    TestLambda01&lt;&gt; t1;<br>    <span class="hljs-built_in">t1</span>(); <span class="hljs-comment">//输出hello world</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>Lambda</code>表达式的中括号相当于上述代码的构造函数，其中并不需要接收任何参数。我们看到<code>func1</code>指向的<code>Lambda</code>表达式返回值为<code>void</code>，当返回值为<code>void</code>时是可以直接省略的，也就是说将语句改写为下面的形式是可行的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// auto func1 = []()-&gt;void &#123;cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;&#125;;</span><br><span class="hljs-keyword">auto</span> func1 = []() &#123;cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;&#125;;<br></code></pre></td></tr></table></figure></p><p><code>Lambda</code>表达式对不接收外部变量的调用，相当于调用函数对象的常方法，如果现在要交换两个值，可以采用成员方法的方式，也可采用<code>Lambda</code>表达式接收外部变量的方式。</p><p><code>[捕获外部变量]</code> <code>[]</code>：不捕获任何外部变量<code>[=]</code>：以传值的方式捕获外部的所有变量<code>[&amp;]</code>：以传引用的方式捕获外部的所有变量<code>[this]</code>：捕获外部的this指针<code>[=,&amp;a]</code>：以传引用的方式捕获外部的所有变量，但是a变量以传值的方式捕获<code>[a, b]</code>：以传值的方式捕获外部的变量a、b<code>[a, &amp;b]</code>：以传值的方式捕获外部的变量a、以传引用的方式捕获外部的变量b</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda02 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestLambda02</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">ma</span>(a), <span class="hljs-built_in">mb</span>(b) &#123;&#125;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-type">int</span> tmp = ma;<br>        ma = mb;<br>        mb = tmp;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> ma;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> mb;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <br>    <span class="hljs-comment">// auto func1 = [&amp;a, &amp;b]() &#123;</span><br>    <span class="hljs-comment">//     int tmp = a;</span><br>    <span class="hljs-comment">//     a = b;</span><br>    <span class="hljs-comment">//     b = tmp;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <br>    <span class="hljs-keyword">auto</span> func2 = [a, b]() <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-comment">//以传值接收的a b只读 需要加mutable关键字 这样就等价于上面的TestLambda02了</span><br>        <span class="hljs-type">int</span> tmp = a;<br>        a = b;<br>        b = tmp;<br>    &#125;;<br><br>    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">//10 20</span><br>    <span class="hljs-built_in">func2</span>(); <span class="hljs-comment">//交换操作 不发生交换</span><br>    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">//10 20</span><br>    <br>    TestLambda02&lt;&gt; <span class="hljs-built_in">t2</span>(a, b);<br>    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">//10 20</span><br>    <span class="hljs-built_in">t2</span>(); <span class="hljs-comment">//交换操作 不发生交换</span><br>    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">//10 20</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Lambda</code>表达式的设计中，捕获变量有几种方式；其中按值捕获（CaputrebyValue）的方式不允许程序员在<code>Lambda</code>函数的函数体中修改捕获的变量。而以<code>mutable</code>修饰<code>Lambda</code>函数，则可以打破这种限制。但是实际上即使让按值捕获的变量<code>a</code>、<code>b</code>发生修改，实际跳出函数<code>func2</code>后，原始的<code>a</code>、<code>b</code>并非发生真正意义上的修改，上图代码按引用接收的方式<code>func1</code>才能实现真正意义上的交换。上图中<code>func1</code>以引用的方式接收，实际上等同于如下代码中<code>TestLambda03</code>函数对象的实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda03 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestLambda03</span>(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b) : <span class="hljs-built_in">ma</span>(a), <span class="hljs-built_in">mb</span>(b) &#123;&#125;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-type">int</span> tmp = ma;<br>        ma = mb;<br>        mb = tmp;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> &amp;ma;<br>    <span class="hljs-type">int</span> &amp;mb;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    TestLambda03&lt;&gt; <span class="hljs-built_in">t3</span>(a, b);<br>    <span class="hljs-built_in">t3</span>(); <span class="hljs-comment">//发生了交换</span><br>    <br>    <span class="hljs-keyword">auto</span> func3 = [&amp;a, &amp;b]()-&gt;<span class="hljs-type">void</span> &#123; <span class="hljs-comment">// 或auto func3 = [&amp;]() &#123;&#125;</span><br>        <span class="hljs-type">int</span> tmp = a;<br>        a = b;<br>        b = tmp;<br>    &#125;<br>    <span class="hljs-built_in">func3</span>(); <span class="hljs-comment">//发生了交换 等价于TestLambda03中的函数对象</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>上面的例子剖析了一个<code>Lambda</code>表达式的实现原理，实际采用的就是函数对象的方式，只不过匿名化了而已，不需要我们自己去写模板类来实现各种各样的函数对象。</p><p><strong>问题</strong>：既然<code>Lambda</code>表达式只能使用在语句当中，如果想跨语句使用之前定义好的<code>Lambda</code>表达式，该怎么办？用什么类型表示<code>Lambda</code>表达式呢？<code>Lambda</code>表达式其实本质是函数对象，因此需要使用<code>function</code>类型去接收。</p><p>我们举个Lambda表达式的例子，应用于容器适配器<code>priority_queue</code>，如果定义一个有两个整形元素的类，那么如果要将这个类对象加入到优先队列中，我们需要定义一个比较函数，或者让这个类对象可进行比较，那么首先想到的思路是进行比较符号<code>&lt;</code>、<code>&gt;</code>的重载，但是若一个类对象中有多个成员变量，这次我们需要比较这一个成员变量，下次有需要比较下一个成员变量，那么我们的比较运算符重载函数需要多次修改才行，这是非常复杂的。这时候对于包含在头文件<code>#include &lt;queue&gt;</code>的容器适配器优先队列<code>priority_queue</code>来说，其给我们提供了一个比较函数的传递入口，我们可以看到优先队列的部分模板源代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Sequence = vector&lt;_Tp&gt;,<br>  <span class="hljs-keyword">typename</span> _Compare  = less&lt;<span class="hljs-keyword">typename</span> _Sequence::value_type&gt; &gt;<br>  <span class="hljs-keyword">class</span> priority_queue<br>  &#123;...&#125;<br></code></pre></td></tr></table></figure></p><p>其模板参数接收第三个参数为一个用于比较的函数对象，那么我们可以使用function去接收这个函数对象，用lambda表达式去实现这个函数对象，具体代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Data</span>(<span class="hljs-type">int</span> val1 = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> val2 = <span class="hljs-number">10</span>) : <span class="hljs-built_in">ma</span>(val1), <span class="hljs-built_in">mb</span>(val2) &#123;&#125;<br>    <span class="hljs-comment">// bool operator&gt;(const Data &amp;data) const &#123;return ma &gt; data.ma;&#125;</span><br>    <span class="hljs-comment">// bool operator&lt;(const Data &amp;data) const &#123;return ma &gt; data.ma;&#125;</span><br>    <span class="hljs-type">int</span> ma;<br>    <span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//优先队列</span><br>    <span class="hljs-comment">// priority_queue&lt;Data&gt; maxHeap;</span><br>    priority_queue&lt;Data, vector&lt;Data&gt;, function&lt;<span class="hljs-type">bool</span>(Data &amp;, Data &amp;)&gt;&gt;<br>        <span class="hljs-built_in">maxHeap</span>([](Data &amp;d1, Data &amp;d2)-&gt;<span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">return</span> d1.ma &gt; d2.ma;<br>        &#125;);<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Data</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Data</span>(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>));<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Data</span>(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>其实上面的类型太过于长，可以使用<code>using</code>语法简化<code>main</code>中的部分代码，这样一行代码就不会过长了：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> FUNC = function&lt;<span class="hljs-built_in">bool</span>(Data &amp;, Data &amp;)&gt;;<br>    priority_queue&lt;Data, vector&lt;Data&gt;, FUNC&gt;<br>        <span class="hljs-built_in">maxHeap</span>([](Data &amp;d1, Data &amp;d2)-&gt;<span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">return</span> d1.ma &gt; d2.ma;<br>        &#125;<br>    );<br>    <span class="hljs-comment">// ...省略 </span><br>&#125;<br></code></pre></td></tr></table></figure></p><hr /><h3 id="适配器">适配器</h3><p>三种类型的适配器： *<strong>容器适配器</strong>：用来扩展<code>7</code>种基本容器，利用基本容器扩展形成了栈、队列和优先队列*<strong>迭代器适配器</strong>（反向迭代器、插入迭代器、<code>IO</code>流迭代器）*<strong>函数适配器</strong>：能够将仿函数和另一个仿函数（或某个值、或某个一般函数）结合起来，C++11从Boost库中引入了<code>bind</code>绑定器和<code>function</code>函数对象机制。</p><h4 id="函数适配器">函数适配器</h4><p><code>bind2nd</code>、<code>bind1st</code>用于函数适配器，将双参数函数对象转为单参数函数对象。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(begin(a), end(a))</span></span>;<br><span class="hljs-comment">//计算奇数元素个数</span><br><span class="hljs-comment">//这里的bind2nd将二元函数对象modulus转换为一元函数对象</span><br><span class="hljs-comment">//modulus是STL内置的两个参数的函数对象，用于计算m%n，bind2nd绑定第二个参数，即传入n的值</span><br><span class="hljs-comment">//那么modulus&lt;int&gt;()的第一个参数m（即param_first）从哪里来呢？在count_if遍历的时候传递进来</span><br><span class="hljs-comment">//bind2nd(op, value) (param_first) 相当于op(param, value) value作为op二元操作的第二个参数</span><br>cout &lt;&lt; <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">modulus</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">2</span>)) &lt;&lt; endl;<br><br><span class="hljs-comment">//bind1st刚好与bind2nd相反，对于函数对象，绑定的是第一个参数</span><br><span class="hljs-comment">//bind1st(op, value) (param_second) 相当于op(value, param_second)</span><br>cout &lt;&lt; <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind1st</span>(<span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">2</span>)) &lt;&lt; endl;<br></code></pre></td></tr></table></figure>其实上面两个函数所做的事情就是，当算法中要传递某个二元函数对象时，我们通常会提前绑定其中一个参数，另一个则由算法迭代器遍历传递。我们再举个例子便于理解：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(begin(a), end(a))</span></span>;<br>cout &lt;&lt; <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">2</span>)) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind1st</span>(<span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">2</span>)) &lt;&lt; endl;<br></code></pre></td></tr></table></figure>那么第一个输出表示，<code>元素&lt;2</code>的个数；第二个输出表示<code>2&lt;元素</code>的个数，即元素大于<code>2</code>的个数，所以输出的结果分别为<code>1</code>和<code>5</code>。</p><p>(待补充) mem_fun_ref / mem_fun / mem_fn / bind2nd / bind1st / bind<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders; <span class="hljs-comment">// bind中 _1标志传入一个参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> string &amp;name) : <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;cout &lt;&lt; name_ &lt;&lt; endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintWithPrefix</span><span class="hljs-params">(string prefix)</span> <span class="hljs-type">const</span> </span>&#123;cout &lt;&lt; prefix &lt;&lt; name_ &lt;&lt; endl;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    string name_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Person&gt; &amp;v)</span> </span>&#123;<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun_ref</span>(&amp;Person::Print)); <span class="hljs-comment">//若mem_fun_ref接收无参数成员函数 会转换为一元函数对象</span><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">mem_fun_ref</span>(&amp;Person::PrintWithPrefix), <span class="hljs-string">&quot;person:&quot;</span>)); <span class="hljs-comment">//若mem_fun_ref接收一个参数成员函数，会转换为二元函数对象，并且第一个参数为函数对象本身 第二个参数为成员函数参数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo2</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Person *&gt; &amp;v)</span> </span>&#123;<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun</span>(&amp;Person::Print));<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">mem_fun</span>(&amp;Person::PrintWithPrefix), <span class="hljs-string">&quot;person:&quot;</span>));<br><br>&#125;<br><br><span class="hljs-comment">//C++11 mem_fn bind</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo3</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Person&gt; &amp;v)</span> </span>&#123;<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fn</span>(&amp;Person::Print));<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(<span class="hljs-built_in">mem_fn</span>(&amp;Person::PrintWithPrefix), _1, <span class="hljs-string">&quot;person:&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo4</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Person *&gt; &amp;v)</span> </span>&#123;<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fn</span>(&amp;Person::Print));<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(<span class="hljs-built_in">mem_fn</span>(&amp;Person::PrintWithPrefix), _1, <span class="hljs-string">&quot;person:&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;Person&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;tom&quot;</span>));<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;jerry&quot;</span>));<br>    <span class="hljs-built_in">foo</span>(v);<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------&quot;</span> &lt;&lt; endl;<br><br>    vector&lt;Person *&gt; v2;<br>    v2.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;tom&quot;</span>));<br>    v2.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;jerry&quot;</span>));<br>    <span class="hljs-built_in">foo2</span>(v2);<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-built_in">foo3</span>(v);<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">foo4</span>(v2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>可参考总结的链接：http://blog.leanote.com/post/gaunthan/C-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1</p><p>针对一般函数的函数适配器<code>ptr_fun</code></p><p>--</p><p><code>bind</code>和<code>function</code>可替代<code>STL</code>中的<code>mem_fun</code>、<code>ptr_fun</code>、<code>bind1st</code>以及<code>bind2nd</code>等函数。<code>bind1st</code>、<code>bind2nd</code>绑定器主要针对<strong>二元函数对象</strong>，通过绑定器和二元函数对象，使其变为一元函数对象，即<code>bind + 二元函数对象 = 一元函数对象</code>。比如说对一个已经从大到小排好序的<code>vector&lt;int&gt;</code>模板类对象<code>vec</code>，假设元素值在<code>[0, 100]</code>这个区间中，现在要将<code>70</code>按顺序插入到<code>vec</code>中，我们的思路是分为两步，第一步先使用<code>find_if</code>查找在由大到小顺序中小于<code>70</code>的第一个位置，然后在该位置处插入<code>70</code>这个值。</p><p>找<code>vec</code>中小于<code>70</code>的第一个值，那么此时就可以使用绑定器配合二元模板函数对象，作为<code>find_if</code>第三个参数；然后判断迭代器是否找到，若找到该位置则插入即可：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find_if</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind1st</span>(<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">70</span>)); <span class="hljs-comment">//给greater left &gt; right 变为70 &gt; right</span><br><span class="hljs-keyword">if</span>(it != vec.<span class="hljs-built_in">end</span>())<br>    vec.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">70</span>);<br></code></pre></td></tr></table></figure>或者第三个参数改为<code>bind2nd(less&lt;int&gt;(), 70)</code>，<code>less</code>的两个参数<code>left &lt; right</code>的第二个参数变为<code>70</code>，即表达的含义就是<code>left &lt; 70</code>。</p><p><strong><code>bind1st</code>和<code>bind2nd</code>底层实现原理：</strong>拿<code>bind1st</code>来说，作为上述例子<code>find_if</code>的第三个参数，传递的是一个函数，也可以是一个仿函数，那么实际<code>bind1st</code>的返回值应该是一个模板函数对象，模板接受的类型有两个，一个是二元比较函数（这个函数可以是普通函数、是模板函数，甚至可以是模板函数对象），另一个是二元中其中一元已知值，返回值<code>_mybind1st</code>最终是一个一元模板函数对象，我们自己实现一个二元模板函数对象<code>Greater&lt;int&gt;()</code>、<code>find_if</code>、<code>bind1st</code>和<code>bind2nd</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">绑定器和函数对象operator()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1. C++ STL中的绑定器</span><br><span class="hljs-comment">bind1st: operator()的第一个形参变量绑定成一个确定的值</span><br><span class="hljs-comment">bind2nd: operator()的第二个形参变量绑定成一个确定的值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2. C++11从Boost库中引入了bind绑定器和function函数对象机制</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showContainer</span><span class="hljs-params">(Container &amp;con)</span> </span>&#123;<br>    <span class="hljs-keyword">typename</span> Container::iterator it = con.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//如果不加typename 编译器不知是类型还是变量</span><br>    <span class="hljs-keyword">for</span>(; it != con.<span class="hljs-built_in">end</span>(); ++it)<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// my_find_if(vec.begin(), vec.end(), mybind1st(greater&lt;int&gt;(), 70))</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Compare&gt;</span><br><span class="hljs-function">Iterator <span class="hljs-title">my_find_if</span><span class="hljs-params">(Iterator first, Iterator last, Compare comp)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(; first != last; ++first) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">comp</span>(*first)) &#123;<br>            <span class="hljs-keyword">return</span> first;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Compare, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_mybind1st</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    _mybind1st(Compare comp, T val) : _comp(comp), _val(val) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;second)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _comp(_val, second);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    Compare _comp;<br>    T _val;<br>&#125;;<br><br><span class="hljs-comment">// mybind1st(greater&lt;int&gt;(), 70)</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Compare, <span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">_mybind1st&lt;Compare, T&gt; <span class="hljs-title">mybind1st</span><span class="hljs-params">(Compare comp, <span class="hljs-type">const</span> T &amp;val)</span> </span>&#123; <span class="hljs-comment">//返回一元函数对象</span><br>    <span class="hljs-comment">//直接使用函数模板 好处是可进行类型推演</span><br>    <span class="hljs-keyword">return</span> _mybind1st&lt;Compare, T&gt;(comp, val);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Comapre, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_mybind2nd</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    _mybind2nd(Comapre comp, T val) : _comp(comp), _val(val) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;first)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _comp(first, _val);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    Comapre _comp;<br>    T _val;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Compare, <span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">_mybind2nd&lt;Compare, T&gt; <span class="hljs-title">mybind2nd</span><span class="hljs-params">(Compare comp, <span class="hljs-type">const</span> T &amp;val)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _mybind2nd&lt;Compare, T&gt;(comp, val);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greater</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T left, T right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left &gt; right;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)<br>        vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">showContainer</span>(vec);<br><br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)-&gt;<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> left &gt; right;&#125;);<br>    <span class="hljs-built_in">showContainer</span>(vec);<br><br>    <span class="hljs-comment">// 把70按顺序插入到vector容器中</span><br>    <span class="hljs-comment">// operator()(const T &amp;val)</span><br>    <span class="hljs-comment">// greater  a &gt; b</span><br>    <span class="hljs-comment">// less     a &lt; b</span><br>    <span class="hljs-comment">// 绑定器 + 二元函数对象 -&gt; 一元函数对象 找小于70的</span><br>    <span class="hljs-comment">// bind1st: + greater   bool operator()(70, const _Ty &amp;_Right)  70 &gt; b</span><br>    <span class="hljs-comment">// bind2nd: + less      bool operator()(const Ty &amp;_Left, 70)    a &lt; 70</span><br><br>    <span class="hljs-comment">// auto it1 = my_find_if(vec.begin(), vec.end(), mybind1st(greater&lt;int&gt;(), 70));</span><br>    <span class="hljs-keyword">auto</span> it1 = <span class="hljs-built_in">my_find_if</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mybind1st</span>(<span class="hljs-built_in">Greater</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">70</span>));<br>    <span class="hljs-keyword">if</span>(it1 != vec.<span class="hljs-built_in">end</span>()) &#123;<br>        vec.<span class="hljs-built_in">insert</span>(it1, <span class="hljs-number">70</span>);<br>    &#125;<br>    <span class="hljs-built_in">showContainer</span>(vec);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>可以看到绑定器<code>mybind1st</code>、<code>mybind2nd</code>是<strong>模板函数类型</strong>，可直接进行类型推演，接收比较函数和一个值并传递给一个函数对象<code>_mybind1st</code>和<code>_mybind2nd</code>，那么这两个函数对象中<code>_mybind1st</code>使用确定值填充第一个参数，<code>_mybind2nd</code>使用确定值填充第二个参数。之所以这么做是因为<code>find_if</code>这个函数第三个参数只能接收一个一元函数对象，因此通过绑定器绑定二元函数对象中的一个值，使其变为一元函数对象。上述代码输出的一种结果如下：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">55</span> <span class="hljs-number">86</span> <span class="hljs-number">90</span> <span class="hljs-number">52</span> <span class="hljs-number">81</span> <span class="hljs-number">64</span> <span class="hljs-number">6</span> <span class="hljs-number">28</span> <span class="hljs-number">94</span> <span class="hljs-number">70</span> <span class="hljs-number">93</span> <span class="hljs-number">6</span> <span class="hljs-number">43</span> <span class="hljs-number">23</span> <span class="hljs-number">8</span> <span class="hljs-number">91</span> <span class="hljs-number">9</span> <span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">24</span> <br><span class="hljs-attribute">94</span> <span class="hljs-number">93</span> <span class="hljs-number">91</span> <span class="hljs-number">90</span> <span class="hljs-number">86</span> <span class="hljs-number">81</span> <span class="hljs-number">70</span> <span class="hljs-number">64</span> <span class="hljs-number">55</span> <span class="hljs-number">52</span> <span class="hljs-number">43</span> <span class="hljs-number">28</span> <span class="hljs-number">24</span> <span class="hljs-number">23</span> <span class="hljs-number">10</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <br><span class="hljs-attribute">94</span> <span class="hljs-number">93</span> <span class="hljs-number">91</span> <span class="hljs-number">90</span> <span class="hljs-number">86</span> <span class="hljs-number">81</span> <span class="hljs-number">70</span> <span class="hljs-number">70</span> <span class="hljs-number">64</span> <span class="hljs-number">55</span> <span class="hljs-number">52</span> <span class="hljs-number">43</span> <span class="hljs-number">28</span> <span class="hljs-number">24</span> <span class="hljs-number">23</span> <span class="hljs-number">10</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure>首先将一组随机值写入<code>vector</code>，再按照由大到小的顺序排序，接着通过<code>my_find_if</code>找到<code>70 &gt; x</code>为真的第一个位置，即小于<code>70</code>的第一个位置，然后对<code>my_find_if</code>返回的迭代器的位置进行插入操作。</p><p><code>C++11</code>从<code>Boost</code>库引入多参数占位符<code>bind</code>，而不仅仅只是局限于一元函数对象和二元函数对象。<code>bind</code>是模板函数，其参数可进行模板类型推演，返回的是一个函数对象，对于下面的代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123;cout &lt;&lt; str &lt;&lt; endl;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a + b;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a + b;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// bind是函数模板 可自动推演模板类型参数</span><br>    <span class="hljs-built_in">bind</span>(hello, <span class="hljs-string">&quot;hello bind!&quot;</span>)();<br>    cout &lt;&lt; <span class="hljs-built_in">bind</span>(sum, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>)() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">bind</span>(&amp;Test::sum, <span class="hljs-built_in">Test</span>(), <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>可以看到<code>bind</code>后有两个括号，第一个括号则是<code>bind</code>模板函数需要传递的参数，第一个参数就是函数对象，从第二个参数开始则为要绑定的函数的参数，第二个括号则是调用<code>bind</code>返回的函数对象对应的小括号运算符重载<code>operator()</code>执行所绑定的函数，上图中分别对一个形参、两个形参的函数还有成员函数进行绑定。如果不想要绑定，则需要对某个或某几个参数进行占位，通过<code>placeholders::_1</code>、<code>placeholders::_2</code>..等等进行占位，<code>placeholders</code>实际上是一个命名空间，内部存放了最多<code>20</code>个参数占位符。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> placeholders<br>&#123;<br><span class="hljs-comment">/* Define a large number of placeholders. There is no way to</span><br><span class="hljs-comment"> * simplify this with variadic templates, because we&#x27;re introducing</span><br><span class="hljs-comment"> * unique names for each.</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">1</span>&gt; _1;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">2</span>&gt; _2;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">3</span>&gt; _3;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">4</span>&gt; _4;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">5</span>&gt; _5;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">6</span>&gt; _6;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">7</span>&gt; _7;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">8</span>&gt; _8;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">9</span>&gt; _9;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">10</span>&gt; _10;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">11</span>&gt; _11;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">12</span>&gt; _12;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">13</span>&gt; _13;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">14</span>&gt; _14;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">15</span>&gt; _15;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">16</span>&gt; _16;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">17</span>&gt; _17;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">18</span>&gt; _18;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">19</span>&gt; _19;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">20</span>&gt; _20;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">21</span>&gt; _21;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">22</span>&gt; _22;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">23</span>&gt; _23;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">24</span>&gt; _24;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">25</span>&gt; _25;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">26</span>&gt; _26;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">27</span>&gt; _27;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">28</span>&gt; _28;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> _Placeholder&lt;<span class="hljs-number">29</span>&gt; _29;<br>&#125;<br></code></pre></td></tr></table></figure> 占位方式<code>bind</code>的使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> placeholders;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123;cout &lt;&lt; str &lt;&lt; endl;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a + b;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 参数占位 直接调用bind返回的函数对象的operator()(...)重载</span><br>    <span class="hljs-built_in">bind</span>(hello, _1)(<span class="hljs-string">&quot;hello bind 2!&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">bind</span>(sum, _1, _2)(<span class="hljs-number">200</span>, <span class="hljs-number">300</span>) &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 部分参数占位</span><br>    cout &lt;&lt; <span class="hljs-built_in">bind</span>(sum, _1, <span class="hljs-number">200</span>)(<span class="hljs-number">100</span>) &lt;&lt; endl; <span class="hljs-comment">//表示 100+200 调用bind返回的函数对象 传入两个参数(100, 200)</span><br>    <br>    <span class="hljs-comment">// bind+function</span><br>    <span class="hljs-keyword">auto</span> func3 = <span class="hljs-built_in">bind</span>(hello, <span class="hljs-string">&quot;hello without place&quot;</span>);<span class="hljs-comment">//直接绑定 func3的类型较为复杂</span><br>    <br>    function&lt;<span class="hljs-type">void</span>(string)&gt; func1 = <span class="hljs-built_in">bind</span>(hello, _1); <span class="hljs-comment">//全部参数占位</span><br>    <span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello function+bind&quot;</span>);                   <span class="hljs-comment">//调用func1指向的函数对象的operator()，实际调用的函数为hello</span><br>    <br>    <span class="hljs-comment">// function&lt;int(int, int)&gt; func2 = bind(sum, _1, 200); //方法错误 bind返回类型与func2不匹配 建议用auto func2</span><br>    <span class="hljs-comment">// func2(100);</span><br>    <span class="hljs-comment">// std::_Bind&lt;int (*(std::_Placeholder&lt;1&gt;, int))(int, int)&gt; func2 = bind(sum, _1, 200); //这才是真实的类型 通过typeid(func2).name() 获取到的</span><br>    <span class="hljs-keyword">auto</span> func2 = <span class="hljs-built_in">bind</span>(sum, _1, <span class="hljs-number">200</span>); <span class="hljs-comment">//直接使用auto即可</span><br>    cout &lt;&lt; <span class="hljs-built_in">func2</span>(<span class="hljs-number">10</span>) &lt;&lt; endl; <span class="hljs-comment">//结果为10+200 = 210</span><br>    <br>    <span class="hljs-keyword">auto</span> func3 = <span class="hljs-built_in">bind</span>(hello, <span class="hljs-string">&quot;hello without place&quot;</span>);<br>    <span class="hljs-built_in">func3</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">typeid</span>(func3).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//std::_Bind&lt;void (*(char const*))(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;)&gt;</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>C++11</code>线程池（绑定器<code>bind</code>+<code>function</code>），代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> placeholders;<br><br><span class="hljs-comment">//线程类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Thread</span>(function&lt;<span class="hljs-built_in">void</span>()&gt; func) : _func(func) &#123;&#125;<br>    <span class="hljs-comment">// Thread(function&lt;void(int)&gt; func, int no) : _func(func), _no(no) &#123;&#125;</span><br>    <span class="hljs-function">thread <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(_func)</span></span>;<br>        <span class="hljs-comment">// thread t(_func, _no); //线程调用_func的重载operator()</span><br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    function&lt;<span class="hljs-type">void</span>()&gt; _func;<br>    <span class="hljs-comment">// function&lt;void(int)&gt; _func;</span><br>    <span class="hljs-comment">// int _no;</span><br>&#125;;<br><br><br><span class="hljs-comment">//线程池类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadPool</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">ThreadPool</span>() &#123;<br>        <span class="hljs-comment">//释放Thread对象占用的堆资源</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _pool.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">delete</span> _pool[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//开启线程池</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">startPool</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            _pool.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(<span class="hljs-built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="hljs-keyword">this</span>, i)));<br>            <span class="hljs-comment">// _pool.push_back(new Thread(bind(&amp;ThreadPool::runInThread, this, _1), i));</span><br>            <br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            _handler.<span class="hljs-built_in">push_back</span>(_pool[i]-&gt;<span class="hljs-built_in">start</span>());<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(thread &amp;t : _handler) &#123;<br>            t.<span class="hljs-built_in">join</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;Thread*&gt; _pool; <span class="hljs-comment">//用于存放线程池类 在启动线程池绑定对应线程以及他们的回调函数</span><br>    vector&lt;thread&gt; _handler;<br>    <span class="hljs-comment">// 把runInThread这个成员方法充当线程函数 thread pthread_create</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runInThread</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;call runInThread! id:&quot;</span> &lt;&lt; id &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ThreadPool pool;<br>    pool.<span class="hljs-built_in">startPool</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="迭代器适配器">迭代器适配器</h4><ul><li>反向迭代器</li><li>插入迭代器</li><li><code>IO</code>流迭代器</li></ul><p>back_insert_iterator / back_inserter front_insert_iterator /front_inserter ostream_iterator / istream_iterator</p><h4 id="容器适配器">容器适配器</h4><ul><li>stack</li><li>queue</li><li>priority_queue</li></ul><hr /><h3 id="右值引用">右值引用</h3><p>左值引用可以将一个有内存有名字的左值绑定到一个引用上，如下<code>b</code>所示；但右值引用不能将左值绑定到右值引用上，如下<code>c</code>所示；同样不能将一个右值绑定到左值引用上，如下<code>d</code>所示，但是加上const后即可将右值绑定到左值引用上；具体代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = a;<br><span class="hljs-type">int</span> &amp;&amp;c = a; <span class="hljs-comment">//错误的</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int tmp = 20;</span><br><span class="hljs-comment">const int &amp;d = tmp;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> &amp;d = <span class="hljs-number">20</span>; <span class="hljs-comment">//错误的 const int &amp;d = 20; 加上后const可以</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int tmp = 20;</span><br><span class="hljs-comment">int &amp;&amp;d = tmp;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> &amp;&amp;d = <span class="hljs-number">20</span>; <span class="hljs-comment">//可以把右值绑定到右值引用上</span><br><br><span class="hljs-type">int</span> &amp;&amp;f = d; <span class="hljs-comment">//错误的 一个右值引用变量d，本身是一个左值，无法将左值绑定到右值引用上</span><br><span class="hljs-type">int</span> &amp;f = d; <span class="hljs-comment">//左值引用可引用d</span><br></code></pre></td></tr></table></figure></p><p>左值可理解为：<strong>有内存、有名字</strong>；右值可理解为：<strong>没名字（临时量）、没内存</strong></p><p>接下来来看一下右值引用对性能的提升，首先来看若没有右值引用，一个自己实现的<code>MyString</code>类的调用顺序，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyString</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CMyString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-literal">nullptr</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CMyString(const char *)&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span>(str != <span class="hljs-literal">nullptr</span>) &#123;<br>            mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(mptr, str);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            *mptr = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">CMyString</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~CMyString&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span> []mptr;<br>        mptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//带左值引用参数的拷贝构造</span><br>    <span class="hljs-built_in">CMyString</span>(<span class="hljs-type">const</span> CMyString &amp;str) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CMyString(const CMyString &amp;)&quot;</span> &lt;&lt; endl;<br>        mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.mptr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(mptr, str.mptr);<br>    &#125;<br><br>    <span class="hljs-comment">//带左值引用参数的赋值重载函数</span><br>    CMyString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> CMyString &amp;str) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;operator=(const CMyString &amp;)&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;str)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">delete</span> []mptr;<br>        mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.mptr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(mptr, str.mptr);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> mptr;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *mptr;<br>&#125;;<br><br><span class="hljs-function">CMyString <span class="hljs-title">GetString</span><span class="hljs-params">(CMyString &amp;str)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *pstr = str.<span class="hljs-built_in">c_str</span>();<br>    <span class="hljs-function">CMyString <span class="hljs-title">tmpStr</span><span class="hljs-params">(pstr)</span></span>;<br>    <span class="hljs-keyword">return</span> tmpStr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">CMyString <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaaaaaaaaaaaaaaaa&quot;</span>)</span></span>;<br>    CMyString str2;<br>    str2 = <span class="hljs-built_in">GetString</span>(str1);<br>    cout &lt;&lt; str2.<span class="hljs-built_in">c_str</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>以上<code>main</code>执行步骤（不进行编译器优化策略）： 1.<code>str1</code>调用构造函数<code>CMyString(const char *)</code> 2.<code>str2</code>调用构造函数<code>CMyString(const char *)</code> 3.<code>GetString</code>函数中<code>tmpStr</code>调用构造函数<code>CMyString(const char *)</code>4.将<code>tmpStr</code>传递给临时对象，调用拷贝构造函数<code>CyString(const CMyString &amp;)</code>5. 调用析构函数<code>~CMyString</code>，析构<code>tmpStr</code>对象 6.将临时对象赋值给<code>main</code>中的<code>str2</code>，调用<code>=</code>运算符重载<code>operator=(const CMyString &amp;)</code>7. 调用析构函数<code>~CMyString</code>，析构临时对象 8.调用析构函数<code>~CMyString</code>，析构<code>str2</code>对象 9.调用析构函数<code>~CMyString</code>，析构<code>str1</code>对象</p><p>我们可以发现，在调用<code>GetString</code>将<code>str1</code>的值传递给<code>str2</code>的过程中发生了多次拷贝调用过程。首先就是<code>tmpStr</code>构造函数拷贝<code>str1</code>内存中的串；然后<code>tmpStr</code>将其内部的串通过拷贝构造传递给临时对象；接着释放析构<code>tmpStr</code>对象，再将临时对象的值通过调用<code>=</code>运算符重载拷贝给<code>main</code>中的<code>str2</code>：<img src="media/16224350022491/16400783309935.jpg" alt="-w629" /></p><p>上述内存数据多次拷贝的情况，效率是非常低的，其实一块内存通过拷贝的方式得到tmpStr后，如果我们可以将这个tmpStr直接变为str2，也就是将str2对象中的指针直接指向tmpStr创建的空间的话，那就可以减少两次拷贝过程，这对代码的效率提升是可观的，特别是在代码复杂的情况下，能够省略很多次内存拷贝，那么我们就可以对拷贝构造函数以及<code>=</code>运算符重载函数进行重写，通过使用右值引用来减少对象中的内存拷贝，改进代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyString</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CMyString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-literal">nullptr</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CMyString(const char *)&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span>(str != <span class="hljs-literal">nullptr</span>) &#123;<br>            mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(mptr, str);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            *mptr = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">CMyString</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~CMyString&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span> []mptr;<br>        mptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//带右值引用参数的拷贝构造</span><br>    <span class="hljs-built_in">CMyString</span>(CMyString &amp;&amp;str) &#123; <span class="hljs-comment">//str引用就是一个临时对象</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;CMyString(CMyString &amp;&amp;)&quot;</span> &lt;&lt; endl;<br>        mptr = str.mptr;<br>        str.mptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//带右值引用参数的赋值重载函数</span><br>    CMyString &amp;<span class="hljs-keyword">operator</span>=(CMyString &amp;&amp;str) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;operator=(CMyString &amp;&amp;)&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;str)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">delete</span> []mptr;<br>        mptr = str.mptr;<br>        str.mptr = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> mptr;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *mptr;<br>&#125;;<br><br><span class="hljs-function">CMyString <span class="hljs-title">GetString</span><span class="hljs-params">(CMyString &amp;str)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *pstr = str.<span class="hljs-built_in">c_str</span>();<br>    <span class="hljs-function">CMyString <span class="hljs-title">tmpStr</span><span class="hljs-params">(pstr)</span></span>;<br>    <span class="hljs-keyword">return</span> tmpStr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">CMyString <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaaaaaaaaaaaaaaaa&quot;</span>)</span></span>;<br>    CMyString str2;<br>    str2 = <span class="hljs-built_in">GetString</span>(str1);<br>    cout &lt;&lt; str2.<span class="hljs-built_in">c_str</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 执行顺序（不进行编译器优化）： 1.<code>str1</code>调用构造函数<code>CMyString(const char *)</code> 2.<code>str2</code>调用构造函数<code>CMyString(const char *)</code> 3.<code>tmpStr</code>调用拷贝构造函数<code>CMyString(const char *)</code>，创建一片新内存，有内存拷贝，将<code>str1</code>数据拷贝过来。4.<code>tmpStr</code>调用带有右值引用的拷贝构造函数去接收临时对象<code>CMyString(CMyString &amp;&amp;)</code>，这里直接改变指针指向，无内存拷贝，临时对象指针指向第<code>3</code>步创建的空间。5.<code>tmpStr</code>对象中的指针指向<code>nullptr</code>，此时析构<code>tmpStr</code>，调用<code>~CMyString</code>，不会释放第<code>3</code>步创建的空间。6.临时对象要通过<code>=</code>运算符重载来传递给<code>main</code>函数中的<code>str2</code>，调用<code>operator=(CMyString &amp;&amp;)</code>，使用右值引用接收临时对象，并且在内部改变指针指向，而非进行内存拷贝，将临时对象指针置<code>nullptr</code>。7.临时对象指针已经指向<code>nullptr</code>，调用临时对象析构函数<code>~CMyString</code>8. 调用<code>str2</code>的析构函数<code>~CMyString</code> 9.调用<code>str1</code>的析构函数<code>~CMyString</code></p><p>上述代码中，分别对拷贝构造函数和<code>=</code>运算符重载进行了重写，我们发现这两个函数中的代码，我们仅仅只是改变了指针的指向，而并没有创建新的空间来对数据进行拷贝，具体过程如图所示：<img src="media/16224350022491/16400973707975.jpg" alt="-w785" /></p><p>我们发现，和最初的左值常引用接收的方式相比，减少了内存的拷贝过程。<strong>那么我可能会有这样的疑问，难道我不能在左值引用中改写成指针的改变而非内存的拷贝吗</strong>？答案是不能的，首先左值引用是<code>const</code>类型，最终即使让新对象<code>tmpStr</code>或者临时对象也好，它们中的指针指向传入的内存地址（而不是用内存拷贝的方式），那么旧的指针因为受到<code>const</code>的限制，依旧指向该内存区域无法修改其指向，那么当函数<code>GetString</code>生命周期结束时，就会释放<code>const</code>修饰的指针所指向的内存地址，那么最终得到的<code>str2</code>中的指针指向的那片内存也会随着函数<code>GetString</code>生命周期的结束而消失。所以，左值引用改写为非内存拷贝，而是改写指针指向，这样的行为是不可行的。</p><p>与右值或右值引用相关的有两种用法，分别为<code>std::move</code>移动语义和<code>std::forward&lt;T&gt;</code>完美转发，参考链接：<ahref="https://zhuanlan.zhihu.com/p/99524127">现代C++之万能引用、完美转发、引用折叠</a></p><p>我在实现一个带有内存分配器的<code>vector</code>和自定义的<code>CMyString</code>类时遇到了这样的问题，平时我们在写拷贝构造函数也好，写类成员函数也好，传参数一般需要给左值引用加上<code>const</code>类型，如下：<img src="media/16224350022491/cout%20%20C.png" alt="cout C" /> <imgsrc="media/16224350022491/expand%20-%20-%20%3B.png"alt="expand - - ;" /></p><p>那么这里之所以加<code>const</code>，就是为了让左值引用不仅仅可以接收左值，还可以接收右值。所以<strong>这个<code>const</code>是必须带的</strong>！但是，对于上面两个<code>push_back</code>函数，我现在想把他们合并为一个方法，直接通过<strong>模板类型推导</strong>和<strong>引用折叠</strong>去实现：<imgsrc="media/16224350022491/templatetypename%20Ty%2028001W0+31046.png"alt="templatetypename Ty 28001W0+31046" />这样当我接受一个右值时，<code>val</code>就是个右值引用；当我接收一个左值时，<code>val</code>就是一个左值引用。但是此时如果<code>val</code>是一个左值引用，他不需要加<code>const</code>，不像上面<code>CMyString(const CMyString &amp;)</code>和<code>void push_back(const T &amp;val)</code>还要加<code>const</code>，因为上面加<code>const</code>是<strong>为了接收右值</strong>，而这里不需要加<code>const</code>是因为右值传进来后，<code>val</code>直接通过模板类型推导和引用折叠，变为右值引用！所以即使<code>val</code>推导成左值引用，这里也不需要<code>const</code>修饰了。</p><hr /><h2 id="思考1-当引用配合extern关键字时也可以不初始化">思考1当引用配合extern关键字时，也可以不初始化</h2><p>使用<code>const</code>引用接收不同类型变量的时候，我们会这样写：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = d;<br></code></pre></td></tr></table></figure> 但编译器会这么做： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = d;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = temp; <span class="hljs-comment">//让b绑定这个临时变量</span><br></code></pre></td></tr></table></figure>于是我写了这样的代码测试<code>b</code>所引用的地址和<code>d</code>的地址是否相同，按照编译器的优化，按道理说地址是不同的，运行结果正如我们预期，地址不同，说明编译器的确进行了如上优化：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = d;<br>    std::cout &lt;&lt; &amp;d &lt;&lt; std::endl; <span class="hljs-comment">//0x7ffee464d950</span><br>    std::cout &lt;&lt; &amp;b &lt;&lt; std::endl; <span class="hljs-comment">//0x7ffee464d944</span><br>    std::cout &lt;&lt; d &lt;&lt; std::endl;  <span class="hljs-comment">//3.14</span><br>    std::cout &lt;&lt; b &lt;&lt; std::endl;  <span class="hljs-comment">//3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><strong>于是我试问自己为什么会出现这样的优化呢？</strong> &gt;我们使用<code>int</code>接收<code>double</code>的时候肯定会出现截断，那么此时引用截断以后必然会修改原来的<code>d</code>变量，那这样的一个引用操作就无意中修改了原数据，非常的不安全，因此<code>C++</code>直接把这种行为定义为非法，所以怎么可能会让你去直接完成这样的引用操作呢？（55页下方有说到）所以编译器会创建一个临时的<code>temp</code>完成这样不安全的引用操作，但带来的结果就是引用的地址与原本真实的地址不同了（<code>b</code>所引用的地址和<code>d</code>的地址不同），具体结构如下图所示。</p><figure><img src="media/16224350022491/16224417771328.jpg" alt="-w539" /><figcaption aria-hidden="true">-w539</figcaption></figure><p>然后当我想到<code>extern</code>时（用法在41页），若此时有三个文件<code>file1.h</code>、<code>file2.cpp</code>、<code>file3.cpp</code>，我想要在多文件一起使用<strong>引用操作</strong>，看看编译器优化后在多文件之间所引用的地址和原地址有啥区别，于是就写了下面这三个文件，代码如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//file1.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> d; <span class="hljs-comment">//说明d是多文件共享的全局变量 此句只是声明</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b; <span class="hljs-comment">//说明常引用b也是多文件共享使用的，此句也是声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//file2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;file1.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>; <span class="hljs-comment">//此处可加extern 也可不加extern</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = d; <span class="hljs-comment">//需要加extern 因为const默认变量仅用于当前文件</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;main [address d]:&quot;</span> &lt;&lt; &amp;d &lt;&lt; <span class="hljs-string">&quot; d: &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;main [address b, &amp;b=d]:&quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="hljs-string">&quot; b: &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//file3.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;file1.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func [address d]:&quot;</span> &lt;&lt; &amp;d &lt;&lt; <span class="hljs-string">&quot; d: &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func [address b, &amp;b=d]:&quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="hljs-string">&quot; b: &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>对于<code>const int &amp;b</code>接收<code>double d</code>，要进行类型转换（见55页处），因此会申请临时变量<code>temp</code>，这样一来，<strong>引用<code>b</code>所引用的实际地址是<code>temp</code>的地址，而非<code>d</code>的地址</strong>（编译器优化的结果），具体过程如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = d;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = temp; <span class="hljs-comment">//temp为临时变量</span><br></code></pre></td></tr></table></figure> 于是代码执行结果如我们所愿： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">main [address d]: <span class="hljs-number">0x105e420d0</span> d: <span class="hljs-number">3.14</span><br>main [address b, &amp;b=d]: <span class="hljs-number">0x105e420e0</span> b: <span class="hljs-number">3</span><br>func [address d]: <span class="hljs-number">0x105e420d0</span> d: <span class="hljs-number">3.14</span><br>func [address b, &amp;b=d]: <span class="hljs-number">0x105e420e0</span> b: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></p><p><strong>接下来又有个疑问，我们知道引用是要进行初始化的，可是在编译完毕后，发现在<code>file1.h</code>中这样写：<code>extern const int &amp;b</code>居然没有出现<code>ERROR</code>，这是什么情况呢？</strong><ahref="https://stackoverflow.com/questions/47237933/why-does-extern-int-c-working-fine/47238009">参考答案链接</a>&gt; Why Compiler doesn't give an error for extern reference? &gt;<strong>Because <code>extern const int &amp;b;</code> is not adefinition, but merely a declaration. It's informing the compiler that<code>b</code> will be defined somewhere else in theprogram.</strong></p><p>The <ahref="https://en.cppreference.com/w/cpp/language/storage_duration">cppreferencepage on "storage class specifiers"</a> explains the meaning of extern inthis scenario:</p><blockquote><p><strong>The extern specifier is only allowed in the declarations ofvariables and functions</strong> (except class members or functionparameters). It specifies external linkage, and does not technicallyaffect storage duration, but it cannot be used in a definition of anautomatic storage duration object, so all extern objects have static orthread durations. <strong>In addition, a variable declaration that usesextern and has no initializer is not a definition</strong>.</p></blockquote><p>也就是说<strong>引用其实也可以不需要初始化的</strong>，前提是该引用只是声明，以我的认知，目前可以声明引用的方式只有将引用与<code>extern</code>关键词结合起来才行。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> &amp;b; <span class="hljs-comment">//声明引用b 表明引用b可以在多个文件中共享使用 不会报错ERROR</span><br></code></pre></td></tr></table></figure></p><h2 id="思考2-const指针typedef混用时容易出错的地方">思考2const、指针、typedef混用时容易出错的地方</h2><p>对于<strong>常量指针</strong>和<strong>指向常量的指针</strong>，通常可以根据<code>const</code>与<code>*</code>的位置区分：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p; <span class="hljs-comment">//从右向左读：指针，指向的是常量（意味着指针指向可以改变，但必须是常量）</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p; <span class="hljs-comment">//含义同上</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p; <span class="hljs-comment">//常量指针，指向整型的常指针（指针指向不可发生改变，指向内容可以修改）</span><br></code></pre></td></tr></table></figure></p><p>当加入<code>typedef</code>关键字后，就不能使用上述方式去区分是常量指针还是指向常量的指针了，如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *pstring;  <span class="hljs-comment">//声明类型pstring 它实际上是类型char*的别名</span><br><span class="hljs-keyword">using</span> pstring = <span class="hljs-type">char</span> *; <span class="hljs-comment">//和上述typedef等价 C++11新标准 类型char*别名命名为pstring</span><br><br><span class="hljs-type">const</span> pstring cstr = <span class="hljs-number">0</span>; <span class="hljs-comment">//cstr是指向char的常量指针（aka &#x27;char *const&#x27;）</span><br>pstring <span class="hljs-type">const</span> cstr = <span class="hljs-number">0</span>; <span class="hljs-comment">//含义同上 cstr是指向char的常量指针（aka &#x27;char *const&#x27;）</span><br><br><span class="hljs-type">const</span> pstring *ps;      <span class="hljs-comment">//ps是一个指针，它的对象是指向char的常量指针</span><br></code></pre></td></tr></table></figure>对于<code>cstr</code>，如果按照第一种区分常量指针和指向常量的指针的方式，那么<code>const pstring cstr</code>显然被认为是：（从右向左读）指针，指向了一个常量<code>char</code>，但这实际上是错误的。<strong><code>pstring</code>实际上是指向<code>char</code>的指针，因此，<code>const pstring</code>就是指向<code>char</code>的常量指针，而非指向常量字符的指针。</strong></p><p>遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *cstr = <span class="hljs-number">0</span>; <span class="hljs-comment">//是对const pstring cstr的错误理解</span><br></code></pre></td></tr></table></figure>再强调一遍：这种理解是错误的。声明语句中用到<code>pstring</code>时，其基本数据类型是指针。可是用<code>char *</code>重写了声明语句后，数据类型就变成了<code>char</code>，<code>*</code>成为了声明符的一部分。这样改写的结果是，<code>const char</code>成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向<code>char</code>的常量指针，改写后的形式则声明了一个指向<code>const char</code>的指针。&gt; When we use pstring in a declaration, the base type of thedeclaration is a pointer type. When we rewrite the declaration usingchar<em>, the base type is char and the </em> is part of the declarator.In this case, const char is the base type. This rewrite declares cstr asa pointer to const char rather than as a const pointer to char.</p><p>这里特别容易出错，需要注意区分（见61页处）。</p><h2 id="思考3-表达式有size函数时与int混用带来的问题">思考3表达式有size()函数时与int混用带来的问题</h2><p>在学<code>string</code>类型时，对于<code>size</code>函数来说，返回一个<code>int</code>或返回一个<code>unsigned</code>似乎都是合情合理的，但其实<code>size</code>函数返回的是一个<code>string::size_type</code>类型的值，通过作用域操作符表明名字<code>size_type</code>是在类<code>string</code>中定义的，它其实是一个无符号类型的值，而且能够存储下任何<code>string</code>对象的大小。所有用于存放<code>string</code>类的<code>size</code>函数返回值的变量，都应该是<code>string::size_type</code>类型。</p><p>由于<code>size</code>函数返回的是一个无符号整数，因此切记：如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如：假设<code>n</code>是一个具有负值的<code>int</code>，则表达式<code>s.size() &lt; n</code>的判断结果几乎肯定是<code>true</code>，这是因为负值<code>n</code>会自动地转换成一个比较大的无符号值，如下代码正常打印<code>True</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">-10</span>;<br>    string s = <span class="hljs-string">&quot;abcd&quot;</span>;<br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; n)<br>        cout &lt;&lt; <span class="hljs-string">&quot;True&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>我们不妨把<code>int</code>类型的<code>n</code>修改为<code>unsigned int</code>类型，代码如下，输出结果会非常大：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n = <span class="hljs-number">-10</span>;<br>cout &lt;&lt; n &lt;&lt; endl;    <span class="hljs-comment">//4294967286</span><br></code></pre></td></tr></table></figure>因此在使用<code>size</code>函数时，与之混用或匹配的变量也应为<code>unsigned</code>类型，以此来尽量避免可能产生的意想不到的结果。</p><ul><li><strong><code>array</code>、<code>string</code>、<code>vector</code>中的类型</strong><ul><li><code>string</code>中<code>size()</code>返回的是<code>string::size_type</code>无符号类型</li><li><code>vector&lt;type&gt;</code>中<code>size()</code>返回的是<code>vector&lt;type&gt;::size_type</code>无符号类型</li><li>使用数组下标时，对应类型为<code>size_t</code>无符号类型</li><li>标准库函数begin、end两指针做减法，对应类型为<code>ptrdiff_t</code>带符号类型，因为差值可为负</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64</span><br>__MINGW_EXTENSION <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> __int64 <span class="hljs-type">size_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">size_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="思考4-数组内置下标有时也可为负值">思考4数组内置下标有时也可为负值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">666</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>&#125;;<br>    <span class="hljs-type">int</span> *p = &amp;ia[<span class="hljs-number">2</span>];<br>    std::cout &lt;&lt; p[<span class="hljs-number">-2</span>] &lt;&lt; std::endl; <span class="hljs-comment">//等价于输出ia[0]</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码是可执行的，内置的下标运算符可以处理负值，当然结果地址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一个位置）。我们发现内置的下标运算符所用的索引值不是无符号类型，这与<code>vector</code>和<code>string</code>不同，后两者分别为<code>vector&lt;type&gt;::size_type</code>和<code>string::size_type</code>的无符号类型。</p><h2 id="思考5-多维数组使用范围for遍历引用存在的意义">思考5多维数组使用范围for遍历，引用存在的意义</h2><p><code>C++11</code>新增特性范围<code>for</code>语句，进行范围遍历如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">size_t</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;row : arr)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;col : row)&#123;<br>        col = cnt;<br>        ++cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在上面的例子中因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做，举个例子，考虑如下循环：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;row : ia)     <span class="hljs-comment">//对于外层数组的每一个元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> col : row)       <span class="hljs-comment">//对于内层数组的每一个元素</span><br>        cout &lt;&lt; col &lt;&lt; endl;<br></code></pre></td></tr></table></figure>这个循环中并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转成指针。假设不用引用类型，则循环如下述所示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> row : ia)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> col : row)<br></code></pre></td></tr></table></figure>程序将无法通过编译。这是因为，像之前一样第一个循环遍历<code>ia</code>的所有元素，注意这些元素实际上是大小为<code>4</code>的数组。因为<code>row</code>不是引用类型，所以编译器初始化<code>row</code>时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针。这样得到的<code>row</code>的类型就是<code>int *</code>，显然内层的循环就不合法了，编译器将是图在一个<code>int *</code>内遍历，这显然和程序的初衷相去甚远。</p><p><strong>注意：要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</strong></p><h2 id="思考6-程序未定义导致求值顺序不确定可能引发不可预知的错误">思考6程序未定义导致求值顺序不确定，可能引发不可预知的错误</h2><p>看到书123页时，对于表达式<code>int i = f1() * f2()</code>，我们知道<code>f1</code>和<code>f2</code>的结果会做乘法运算，但不可预知的是<code>f1</code>和<code>f2</code>两个函数谁先执行完，其实在编码中，对于那些没由指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。举个简单的例子，<code>&lt;&lt;</code>运算符没有明确规定何时以及如何对运算对象求值，因此下面的输出表达式是未定义的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; endl; <span class="hljs-comment">//未定义的</span><br></code></pre></td></tr></table></figure>因为程序是未定义的，所以我们无法推断它的行为，编译器可能先求<code>++i</code>的值，再求<code>i</code>的值，此时输出结果未<code>1 1</code>；也可能先求<code>i</code>的值，再求<code>++i</code>的值，输出结果是<code>0 1</code>；甚至编译器还可能做完全不同的操作。因为此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的。所以对以上操作需要尤为注意。</p><h2id="思考7-使用范围for时引用不一定为了修改值也可能为了避免拷贝带来的性能损失">思考7使用范围for时引用不一定为了修改值，也可能为了避免拷贝带来的性能损失</h2><p>举个例子，假定有一个存储着若干<code>string</code>对象的<code>vector</code>对象<code>text</code>，即<code>vector&lt;string&gt; text</code>。要求输出<code>string</code>对象的内容并且在遇到空字符串或者以句号结尾的字符串时进行换行。使用基于范围<code>for</code>的循环处理<code>string</code>对象中的每个元素。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;s : text)&#123;                 <span class="hljs-comment">//对于text的每个元素</span><br>    std::cout &lt;&lt; s;                        <span class="hljs-comment">//输出当前元素</span><br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>() || s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-comment">//遇空字符串或句号结尾 打印换行</span><br>        std::cout &lt;&lt; std::endl;<br>    <span class="hljs-keyword">else</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;                  <span class="hljs-comment">//否则用空格隔开</span><br>&#125;<br></code></pre></td></tr></table></figure>值得注意的是：<code>s</code>被声明成了对常量的引用，在之前的学习中，范围<code>for</code>循环中使用引用的目的是对原值进行写操作，但是此处引用是因为：<code>text</code>的元素是<code>string</code>对象，可能非常大，所以将<code>s</code>声明成引用类型可以避免对元素的拷贝；又因为不需要对<code>string</code>对象做写操作，所以<code>s</code>被声明成对常量的引用。以上是在书127页学习逻辑运算符时看到的。</p><p><strong>所以有时为了避免数据大量拷贝，使用<code>&amp;</code>，但又要避免对数据的错误修改，因此加上关键字<code>const</code>。</strong></p><h2 id="思考8-c虚函数可以是内联函数吗">思考8C++虚函数可以是内联函数吗？</h2><p>刚开始想到这个问题的时候，我在学习<code>inline</code>内联相关的知识，当时得知，如果我在声明一个类，那么当我将类中函数实现写在在类内，那么尽管类中的函数没有<code>inline</code>关键字，它依然是内联函数。于是我就在想，如果成员函数被直接定义在类中可以是内联函数的话，那么成员函数如果是一个实现被写入类中的虚函数呢？它依然是内联函数吗？</p><p>先说结论：<strong>C++的虚函数可以是内联函数。但<code>inline</code>和<code>virtual</code>唯一可以内联的前提是编译器知道所调用的对象到底是哪个类。比如，对于多态，在运行时我们才能得知如何调用的情况，是调用父类的成员函数呢还是子类的成员函数，这取决于我们父类指针所指向的对象，因此在编译期间，编译器不知道到底调用哪个类，就无法内联。</strong></p><p><strong>虚函数与内联函数</strong></p><p><strong>虚函数</strong>：虚函数是为了实现多态机制，需要在基类中定义虚函数。多态，就是用基类指针指向其派生类的实例，然后通过基类指针调用实际派生类的成员函数来实现多态。</p><p><strong>内联函数</strong>：内联函数在调用时并不通过函数调用的机制，而是将函数体直接插入调用处，大大减少由函数调用带来的开销，从而提高程序运行效率。需要注意的是：<code>inline</code>声明对编译器来说只是一种建议，编译器可选择忽略此建议。比如将一个<code>1000</code>多行的函数指定为<code>inline</code>，编译器就会忽略这个<code>inline</code>，并将这个函数还原成普通函数。因此，并不是说把一个函数定义为<code>inline</code>函数就一定会被编译器识别为内联函数，具体取决于编译器的实现和函数体的大小。</p><p>对于以下代码： *当使用类的对象来调用时，则虚函数可以当做是内联的，因为编译器在编译时就确切知道对象是哪个类的；*但当使用基类指针或引用来调用虚函数时，它都不能是内联函数，因为调用发生在运行时，是动态绑定的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base: Display&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived: Display&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 这里的虚函数是通过具体对象调用的, 可以是内联的</span><br>    Base b;<br>    b.<span class="hljs-built_in">Display</span>();<br><br>    <span class="hljs-comment">// 这里的虚函数是通过基类指针调用的, 不能是内联的</span><br>    Base* bp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    bp-&gt;<span class="hljs-built_in">Display</span>();<br>    <span class="hljs-keyword">delete</span> bp;<br>    bp = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思考9-私有构造函数所带来的用途">思考9私有构造函数所带来的用途</h2><p>在<code>C++</code>中，一个函数被声明为<code>protected</code>或者<code>private</code>时，那也就意味着不能被外部直接调用了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">A</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">B</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A a; <span class="hljs-comment">//error: calling a protected constructor of class &#x27;A&#x27;</span><br>    B b; <span class="hljs-comment">//error: calling a private   constructor of class &#x27;B&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通常，我们都将构造函数的声明置于<code>public</code>区段，假如我们将其放入<code>private</code>区段中，这意味着什么呢？当一个程序在创建一个对象的时候，如果有我们定义的构造函数的话，编译器会调用对应的构造函数，而这给调用通常是外部调用，也就是说它不属于<code>class</code>对象本身的调用，假如构造函数是私有的，由于在<code>class</code>外部不允许访问私有成员，所以这将导致编译出错。那我们将类构造函数写在<code>private</code>中，岂不是了实现了一个无法外部创建对象的类？当然，但是对于类本身，我们还可以利用它的静态公有成员，因为它们独立于类对象之外，即使我们未创建有确定内存分配的对象，依然可以使用静态公有成员，因为静态变量是在编译时分配的，当然它得是公有的，这样外部才可以访问到。假如在某个<code>static</code>函数中创建了该<code>class</code>的对象，并以<strong>引用或者指针的形式将其返回</strong>（不可以以值的形式返回，因为要跨函数传递，我们在堆创建空间，并将地址传递给指针或引用去接收），我们就获得了这个对象的使用权，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> A *<span class="hljs-title">MakeObj</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> A); <span class="hljs-comment">//在堆空间创建一个A对象并返回其指针</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">A</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A *p = A::<span class="hljs-built_in">MakeObj</span>();<br>    ...       <span class="hljs-comment">//使用*p</span><br>    <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// Not necessary here, but it&#x27;s a good habbit</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例使用了私有构造函数，但它运行的很好：<code>MakeObj()</code>作为<code>A</code>类的静态成员函数，为我们创建对象，由于要跨函数传递并且不能使用值传递方式，所以我们选择在堆上创建对象，这样即使<code>MakeObj()</code>退出，对象也不会随之蒸发掉，当然，使用完之后你可不要忘了手工将它清除。</p><p>回到前面的思路，除了公有的<code>static</code>成员可以帮助我们访问私有域外，还有没有其它可以利用的东西呢？网上说可以使用该类的友元函数或者友元类创建其对象，具体我还不太清楚，等学到友元类再说。</p><p>任何语言上的设计都服务于特定的实际情况，我们不会无聊到无缘无故把一个构造函数设为<code>private</code>属性，然后再写一个和上例一样的<code>MakeObject()</code>来让用户体验一下奇特的感觉。我们也不太相信这只是由于<code>C++</code>的设计原因而导致的一个“顺便的”、“特殊的”、“无用的”边角功能。它应当是有实际用途的。</p><p>比如现在我们想实现这样一个类，它至多只能存在一个或指定数量个的对象（还记得标准输入输出流库中那个独一无二的<code>cout</code>吗？），我们可以在类的私有域中添加一个<code>static</code>类型的计数器，它的初值置为<code>0</code>，然后再对<code>MakeObject()</code>做点手脚，每次调用它时先检查计数器的值是否已经达到对象个数的上限值，如果是，则产生错误，否则才<code>new</code>出新的对象并返回一个指向该对象的指针或引用，同时将计数器的值增<code>1</code>。最后，为了避免值复制时产生新的对象副本，除了将构造函数置为私有外，拷贝构造函数也要特别声明并置为私有。以上则是将构造函数设置为<code>private</code>属性后的应用场景。</p><p><strong>结论</strong>：其实我们将构造函数之所以定义为私有的，就是为了避免在函数中进行显式的创建对象，比如类名加上对象名去创建多个对象；因此我们会避免人为操作，将构造函数加入私有的属性中，然后在公有属性中通过静态成员函数（我们称之为：全剧访问点）去调用私有构造函数，以此来避免人为的多次调用，达到控制对象创建个数的作用，之所以要使用静态成员函数，是因为我们希望这个全局访问点它本身不属于某个特定的对象，而是属于整个类。以上所述实际上就是我们说到的<strong>单例模式</strong>。</p><p><strong>比较疑惑的问题：</strong>在分析了当构造函数写在<code>private</code>下时的场景，我们也可以思考一下当构造函数写在<code>protected</code>后可以用来做什么呢？</p><p>##思考10 const类对象无法使用缺省构造函数，需要用户去自定义构造函数起初一开始，在学习<code>const</code>修饰成员函数的相关知识的时候，我们知道在函数名后加入<code>const</code>说明该成员函数体内无法通过<code>this</code>指针对相关成员变量进行修改操作，同时我们的成员函数带有<code>const</code>和不带有<code>const</code>可以进行重载，如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">x_</span>(x)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetV</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> x_;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetV</span><span class="hljs-params">()</span></span>&#123;<br>        x = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">return</span> x_;<br>    &#125;;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_;<br>&#125;;<br></code></pre></td></tr></table></figure>那么接下来我就想着去验证，到底什么时候调用带有<code>const</code>的<code>GetV()</code>函数，什么时候又调用不带有<code>const</code>的<code>GetV()</code>函数呢？我一个类对象经过构造函数以后，如果给<code>x_</code>通过构造成员列表初始化为一个非<code>100</code>的值，就比如说是<code>60</code>，那么这个时候我这个对象调用<code>GetV()</code>函数，获取到的值到底是<code>60</code>还是<code>100</code>呢？首先有一个结论是：<strong><code>const</code>常量对象可以调⽤类中的<code>const</code>成员函数，但不能调⽤⾮<code>const</code>成员函数</strong>。也就是说，对于上述函数重载，<strong>如果我们创建一个常量对象</strong>，我们调用该对象的成员函数时会选择调用常量成员函数<code>int GetV() const&#123;..&#125;</code>，若类中仅定义非常量成员函数<code>int GetV()&#123;..&#125;</code>，而没有常量成员函数<code>int GetV() const&#123;..&#125;</code>，那么我们的常量对象是无法调用非常量成员函数的，因此就会报错。<strong>如果我们创建一个非常量对象</strong>，此时会优先调用非常量成员函数<code>int GetV&#123;..&#125;</code>，当类中仅定义常量成员函数<code>int GetV() const&#123;..&#125;</code>时，非常量对象就会调用常量成员函数<code>int GetV() const&#123;..&#125;</code>。</p><p>然后我就想创建普通对象和常量对象，那么这时我发现当我要创建一个<code>const</code>对象的时候，如果这个<code>const</code>对象没有成员变量，仅只有成员函数，那没问题可以创建成功（但是如果连成员变量都没有，那也就失去了<code>const</code>的意义了对吧，因此我就开始考虑如果<code>const</code>对象中有成员变量，又是个什么情况）。那么如果这个<code>const</code>常量对象中定义了成员变量，那么我们在创建一个<code>const</code>对象时，需要自定义构造函数，不能使用缺省（默认）构造函数，如果我们不自定义构造函数，而是将希望寄托于缺省构造函数，那么编译就会出错。比如对下面的代码来说：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//A()&#123;&#125;</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetV</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123; <span class="hljs-keyword">return</span> x_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetV</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> x_; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> A obj2;   <span class="hljs-comment">//Error编译不通过 const对象需要调用类构造函数对其进行初始化</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>上述代码无法创建一个常量类对象，为什么呢？首先<code>const</code>对象保证了对象的数据成员在其生命周期内是不会被改变的（除非对想要修改的值加上<code>mutable</code>关键字），其次呢我们知道缺省构造函数是不做任何初始化工作的，对于<code>const</code>对象来说，其数据成员在生命周期均不改变，那既然不能改变，如果不在<code>const</code>对象创建的时候对其进行初始化，那么又能在什么时候进行初始化呢？然后我们发现缺省构造函数却不做任何初始化操作，因此编译器会拒绝这种行为发生。所以这里必须用户自定义构造函数，如果用户定义了上述注释掉的构造函数<code>A()&#123;&#125;</code>，虽然它没有（实际上应该）初始化数据成员，但编译器（实际是编译器的设计者）以为它一定会在用户自定义构造函数中初始化数据成员（因为不做这种定义的话，还不如直接用缺省构造函数省事呢，又何必多次一举），所以编译器一看到有用户自定义的构造函数，就认为它会初始化数据成员，就给它放了行。虽然骗过了编译器，但这种行为是不可取的，我们不应该玩这种欺骗编译器的行为，而是应该实打实的在类创建时对其进行初始化，比如对于上面的代码，我们应该为私有成员变量<code>x_</code>初始化一个值，毕竟初始化完毕后就再也无法对其进行更改操作，如果不进行初始化，那<code>x_</code>会是一个随机值，这是非常危险的，所以编译是不会通过的。</p><p>所以说<code>const</code>类对象无法使用缺省构造函数，需要用户去自定义构造函数。如果<code>const</code>类对象想要使用缺省的构造函数的话，就不应当有需要初始化的成员变量存在，那么此时如果一个类没有要初始化的成员变量，那定义该类的常对象就失去了意义了对吧。</p><h2 id="思考11-可以但没必要重载运算符">思考11可以但没必要重载“&amp;&amp;”、“||”运算符</h2><p>与<code>C</code>一样，<code>C++</code>使用布尔表达式短路求值法。这表示一旦确定了布尔表达式的真假值，即使还有部分表达式没有被计算，布尔表达式也停止运算，比如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *p;<br><span class="hljs-keyword">if</span>((p != <span class="hljs-literal">NULL</span>) &amp;&amp; (<span class="hljs-built_in">strlen</span>(p) &gt; <span class="hljs-number">10</span>)) &#123;...&#125;<br></code></pre></td></tr></table></figure>这里不需要担心当<code>p</code>指针为<code>NULL</code>时<code>strlen</code>无法正确运行的问题，因为如果<code>p ！= NULL</code>判断为否，则<code>&amp;&amp;</code>表达式为<code>false</code>，不会再调用后面的<code>strlen</code>函数。很早以前，上述行为特性就被反复灌输给<code>C</code>和<code>C++</code>的程序员，所以他们都知道该特性。而且他们也依赖于短路求值法来写程序。C++允许根据用户定义的类型来制定<code>&amp;&amp;</code>和<code>||</code>操作符，可以通过<code>operator&amp;&amp;</code>和<code>operator||</code>重载函数的方式定制<code>&amp;&amp;</code>和<code>||</code>的重载。然而这样做就意味着我们正在改变所谓的“游戏规则”，因为这样的函数调用法替代了之前默认的短路求值法。也就是说如果你重载了操作符<code>&amp;&amp;</code>，对你来说，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(expression1 &amp;&amp; expression2) &#123;...&#125;<br><br><span class="hljs-comment">//对编译器来说，等价于以下代码</span><br><span class="hljs-keyword">if</span>(expression1.<span class="hljs-keyword">operator</span>&amp;&amp;(expression2)) &#123;...&#125; <span class="hljs-comment">//operator&amp;&amp;作为成员函数重载</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">operator</span>&amp;&amp;(expression1, expression2)) &#123;...&#125; <span class="hljs-comment">//operator&amp;&amp;作为全局函数重载</span><br></code></pre></td></tr></table></figure></p><p>这看起来好像没什么不同，但是函数调用的方式与短路求值法是绝对不同的。首先当函数被调用时，需要运算其所有参数，所以调用函数<code>operator&amp;&amp;</code>和<code>operator||</code>时，两个参数都需要计算，换言之，函数调用的方式并没有采用短路计算法。第二是<code>C++</code>语言规范没有定义函数参数的计算顺序，所以没有办法知道<code>expression1</code>与<code>expression2</code>哪一个先计算。完全可能与具有从左参数到右参数计算顺序的短路计算法相反。因此，重载<code>&amp;&amp;</code>和<code>||</code>运算符，就没办法提供给程序员所期望和使用的行为特性，所以尽管可以重载，也不要重载<code>&amp;&amp;</code>和<code>||</code>运算符。</p><h2 id="思考12-拷贝构造函数的调用场景及编译优化给我带来的困惑">思考12拷贝构造函数的调用场景及编译优化给我带来的困惑</h2><p>在学习<code>try-catch</code>异常处理相关知识的时候，我们知道，<code>throw</code>不仅可抛出常规类型变量，也可以抛出一个非常规类型的复杂类对象，完整代码如下所示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyException</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *message) : <span class="hljs-built_in">message_</span>(message) &#123;&#125;<br>    <span class="hljs-built_in">MyException</span>(<span class="hljs-type">const</span> MyException &amp;other) : <span class="hljs-built_in">message_</span>(other.message_) &#123;&#125;<br>    ~<span class="hljs-built_in">MyException</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> message_.<span class="hljs-built_in">c_str</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    string message_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Divide</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0.0</span>) &#123;<br>        <span class="hljs-function">MyException <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-string">&quot;division by zero&quot;</span>)</span></span>; <span class="hljs-comment">//构造局部对象</span><br>        <span class="hljs-keyword">throw</span> e; <span class="hljs-comment">//调用拷贝构造函数 构造新对象 销毁上面的局部对象</span><br>        <span class="hljs-comment">//throw MyException(&quot;division by zero&quot;); //不再调用拷贝构造 直接调用构造函数</span><br>    &#125; <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">Divide</span>(<span class="hljs-number">5.0</span>, <span class="hljs-number">0.0</span>) &lt;&lt; endl;<br>    &#125; <span class="hljs-built_in">catch</span>(MyException &amp;e) &#123;<br>        cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>此时，可以观察到<code>Divide</code>函数实现中的异常抛出<code>throw</code>部分。如果先创建复杂类型对象，再<code>throw</code>，那势必会先调用对象的一个参数的构造函数，去创建一个局部对象，然后<code>throw</code>的过程中，会将局部对象拷贝给一个临时对象，拷贝的过程调用的是对象的拷贝构造函数，如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MyException <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-string">&quot;division by zero&quot;</span>)</span></span>; <span class="hljs-comment">//构造局部对象</span><br><span class="hljs-keyword">throw</span> e; <span class="hljs-comment">//调用拷贝构造函数 构造新对象 销毁上面的局部对象</span><br></code></pre></td></tr></table></figure>那如果一次性在<code>throw</code>的过程中直接创建一个对象，我们会<strong>省去拷贝构造的过程</strong>，直接调用对象的一个参数的构造函数去创建该对象，并将该对象作为返回的结果，如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyException</span>(<span class="hljs-string">&quot;division by zero&quot;</span>); <span class="hljs-comment">//不再调用拷贝构造 直接调用构造函数</span><br></code></pre></td></tr></table></figure></p><p>这样的用法其实与函数返回复杂类对象是类似的，例如如下代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() &#123;&#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test &amp;other) &#123;&#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function">Test <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Test</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func1</span>(); <span class="hljs-comment">//先构造函数 再进行拷贝构造</span><br>    <span class="hljs-built_in">func2</span>(); <span class="hljs-comment">//直接进行构造 无需调用拷贝构造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>但是神奇的是，在<code>CentOS 7.2</code>上用<code>gcc(GCC) 8.4.1</code>编译后发现，不论是调用<code>func1</code>还是调用<code>func2</code>，均不会调用拷贝构造函数，仅仅只调用构造函数和析构函数（不信也可自行打印输出信息验证），于是我首先找了下拷贝构造函数的几大场景：#### 场景一 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    Test t2 = t1;   <span class="hljs-comment">//调用拷贝构造函数</span><br>    t2 = t1;        <span class="hljs-comment">//浅拷贝 不会调用拷贝构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="场景二">场景二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(t1)</span></span>;    <span class="hljs-comment">//调用拷贝构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="场景三">场景三</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Test tmp)</span> </span>&#123;...&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t;<br>    <span class="hljs-built_in">func</span>(t);        <span class="hljs-comment">//t实参去初始化形参tmp 会调用拷贝构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="场景四">场景四</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Test <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t;<br>    <span class="hljs-keyword">return</span> a;       <span class="hljs-comment">//先调用拷贝构造函数 用a对象创建了一个匿名对象 再执行a的析构函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t;<br>    t = <span class="hljs-built_in">g</span>();        <span class="hljs-comment">//匿名对象浅拷贝给t 匿名对象被析构</span><br> <br>    Test t = <span class="hljs-built_in">g</span>();   <span class="hljs-comment">//匿名对象直接去初始化t 不会调用拷贝构造函数 c++编译器直接把匿名对象转成t</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现场景四正是我们想要的，也就是说在某函数内部创建局部对象，返回时会先调用拷贝构造函数，但实际却没有调用，于是我又找到知乎的一篇帖子<ahref="https://www.zhihu.com/question/30726582">拷贝构造函数何时调用？</a>。里面回答是因为g++编译器优化的缘故，如果在编译时加入参数选项<code>-fno-elide-constructors</code>，则可避免优化，我试了一下果真如此。可是当我加入参数选项<code>-fno-elide-constructors</code>后，对于不创建局部对象而直接返回对象的情况，也需要调用拷贝构造函数（原本这种情况应该只调用构造函数而非拷贝构造函数），如下所示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Test <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Test</span>(); <span class="hljs-comment">//先调用构造函数 再拷贝构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>同样加入参数选项<code>-fno-elide-constructors</code>给上述一开始提到的<code>try-catch</code>程序后，对两种方式的书写，均会调用拷贝构造函数。所以根据以上学习思考，对于上述情况是否调用拷贝构造函数，我们只需要知道，若创建局部对象，再进行返回，则需要调用构造函数，然后再调用拷贝构造函数；若直接在返回的时候创建对象，则不需调用拷贝构造函数，仅调用构造函数。如果情况与以上推理相违背，那或许就是编译器优化所导致的结果。具体可以看看上面发的知乎的帖子的讨论。即：<ahref="https://www.zhihu.com/question/30726582">拷贝构造函数何时调用？</a></p><h2 id="思考13-类对象若要禁止拷贝在继承时需注意的习惯">思考13类对象若要禁止拷贝，在继承时需注意的习惯</h2><p>如果要让一个类禁止被拷贝，那么需要将其拷贝构造函数和<code>=</code>运算符重载函数均写在<code>private</code>下，这样就不能显式调用拷贝构造或<code>=</code>运算符重载了，具体代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Noncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Noncopyable</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Noncopyable</span>() &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Noncopyable</span>(<span class="hljs-type">const</span> Noncopyable &amp;) &#123;&#125;                 <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-type">const</span> Noncopyable &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Noncopyable &amp;);  <span class="hljs-comment">//=运算符重载</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>但是如果一个新类<code>Parent</code>要继承这个禁止拷贝的<code>Noncopyable</code>类呢？那就要看我们如何理解“继承”二字了，我们所谓的继承必然是继承其禁止拷贝的属性，但是通常在实现继承时，开发者往往会忽视这一点，可能会写成如下代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Noncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Noncopyable</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Noncopyable</span>() &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Noncopyable</span>(<span class="hljs-type">const</span> Noncopyable &amp;);<br>    <span class="hljs-type">const</span> Noncopyable &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Noncopyable &amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> : <span class="hljs-keyword">private</span> Noncopyable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Parent</span>() &#123;&#125;<br>    <span class="hljs-built_in">Parent</span>(<span class="hljs-type">const</span> Parent &amp;other) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Parent p1;<br>    <span class="hljs-function">Parent <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>上面的代码中，<code>p2</code>类对象在初始化时依旧可以调用拷贝构造函数，将<code>p1</code>类对象传入，其原因在于，虽然禁止了基类的拷贝构造，但是在<code>Parent</code>类实现中，其拷贝构造函数是可以被调用的，当我们执行语句<code>Parent p2(p1);</code>，其首先会调用基类的默认构造函数<code>Noncopyable() &#123;&#125;</code>，其次再调用派生类<code>Parent</code>的拷贝构造函数，因此在基类声明的私有的拷贝构造函数及<code>=</code>运算符重载操作就没用了，这是需要注意的一点，为了避免这样的疏忽，使得派生类能够继承禁止拷贝属性，<strong>需要在派生类的拷贝构造函数中显式的调用基类拷贝构造函数才行，以此达到无法调用派生类拷贝构造函数的目的，实现禁止拷贝功能。</strong>具体实现代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Noncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Noncopyable</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Noncopyable</span>() &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Noncopyable</span>(<span class="hljs-type">const</span> Noncopyable &amp;);<br>    <span class="hljs-type">const</span> Noncopyable &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Noncopyable &amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> : <span class="hljs-keyword">private</span> Noncopyable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Parent</span>() &#123;&#125;<br>    <span class="hljs-built_in">Parent</span>(<span class="hljs-type">const</span> Parent &amp;other) : <span class="hljs-built_in">Noncopyable</span>(other) &#123;&#125; <span class="hljs-comment">// 此处通过初始化列表显式调用基类拷贝构造函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Parent p1;<br>    <span class="hljs-function">Parent <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>; <span class="hljs-comment">//Error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>当进行显式调用后，派生类则无法再进行拷贝构造的调用，也达到了继承基类禁止拷贝的这一属性的目的。</p><h2 id="思考14-重载和const形参间微妙的关系">思考14重载和const形参间微妙的关系</h2><p>在<code>C++ Primer 5th P208</code>学习到重载和<code>const</code>形参时，怎样不算重载？怎样又算是重载？一个拥有顶层<code>const</code>的形参无法和另一个没有顶层<code>const</code>的形参区分开来，也就是说他们之间无法重载，示例如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> Phone)</span></span>; <span class="hljs-comment">//重复声明了 Record lookup(Phone)</span><br><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone *)</span></span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone *<span class="hljs-type">const</span>)</span></span>;<span class="hljs-comment">//重复声明了 Record lookup(Phone *)</span><br></code></pre></td></tr></table></figure></p><p>但书中又说另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的<code>const</code>是底层的，示例如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account &amp;)</span></span>;       <span class="hljs-comment">//函数作用于Account的引用</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> Account &amp;)</span></span>; <span class="hljs-comment">//新函数，作用于常量引用</span><br><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone *)</span>          <span class="hljs-comment">//新函数，作用于指向Account的指针</span></span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone *<span class="hljs-type">const</span>)</span></span>;    <span class="hljs-comment">//新函数，作用于指向常量的指针</span><br></code></pre></td></tr></table></figure></p><p>以上就是重载和<code>const</code>形参相关的知识，那么到这里我突然有个想法，<strong>如果说底层<code>const</code>的存在与否可以实现不同的重载，那么比如对一个无<code>const</code>属性的变量传入某个函数，若给这个变量赋于<code>const</code>属性，是不是就可以传入重载的另一个函数中了呢？带着疑问我写了代码验证了这一点，加上<code>const</code>属性确实可以改变函数的调用</strong>，代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;not const&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *a)</span> </span>&#123; <span class="hljs-comment">//该函数被调用 a是底层const指针</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;const&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span>*&gt;(&amp;b)); <span class="hljs-comment">//对变量b赋于const属性 打印&quot;const&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>所以增加或减少变量的<code>const</code>属性，会改变其传入的函数。编译器会根据实参的类型确定应该调用哪一个函数。</p><h2 id="知识点链接">知识点链接：</h2><ul><li><ahref="https://blog.csdn.net/woxiaohahaa/article/details/78512576">constexpr和常量表达式</a></li><li><ahref="https://www.jianshu.com/p/a809eae05ad8">constexpr：编译期与运行期之间的神秘关键词</a></li><li><ahref="https://www.cnblogs.com/ljwgis/p/13095739.html">C++11新特性：constexpr变量和constexpr函数</a></li><li><a href="https://zh.wikipedia.org/wiki/Constexpr">C++11/C++14constexpr</a></li><li><a href="https://www.zhihu.com/question/35614219">C++ const 和constexpr 的区别？</a></li><li><ahref="https://blog.csdn.net/yamingwu/article/details/46041639">C++decltype类型指示符</a></li><li><ahref="https://stackoverflow.com/questions/21369113/what-is-the-difference-between-auto-and-decltypeauto-when-returning-from-a-fun">Whatis the difference between auto and decltype(auto) when returning from afunction?</a></li><li><ahref="https://stackoverflow.com/questions/12084040/decltype-vs-auto">decltypevs auto</a></li><li><a href="https://segmentfault.com/q/1010000005141633">c++自带string类 的对象 字符串结尾带不带‘\0’?（需要先了解模版知识）</a></li><li><a href="https://www.zhihu.com/question/33312840">C++ STL 中的std::string 类以字符'\0'结尾么？（陈硕大佬的回答是有\0存在的）</a></li><li><ahref="https://zhuanlan.zhihu.com/p/158928580">C++类型转换构造函数和析构函数介绍</a></li><li><ahref="https://blog.csdn.net/qianqin_2014/article/details/51316461">C++转换构造函数和隐式转换函数介绍</a></li><li><ahref="https://blog.csdn.net/small_prince_/article/details/80518982">C++重载之类型转换运算符，将类类型转换为其它类型</a></li><li><ahref="https://blog.csdn.net/Hackbuteer1/article/details/6545882">C++拷贝构造函数的参数类型必须是引用</a></li><li><ahref="https://blog.csdn.net/lyyslsw1230_163com/article/details/9278665">C++中const对象与默认构造函数（与思考10相关）</a></li><li><ahref="https://blog.csdn.net/cwcmcw/article/details/53873600">为什么new/delete和new[]/delete[]必须配对使用？如果用new和delete[]或者让new[]和delete配对使用结果如何？</a></li><li><ahref="https://blog.csdn.net/xiaoshengqdlg/article/details/48368379">C++operatornew/delete多参数时需要注意的点（了解继承和虚函数再回头看）</a></li><li><ahref="https://www.cnblogs.com/greatverve/archive/2012/09/12/const-iterator.html">iterator与const_iterator及constiterator区别</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多变量线性变换</title>
    <link href="/2023/08/05/aa/"/>
    <url>/2023/08/05/aa/</url>
    
    <content type="html"><![CDATA[<h1id="第四章-多变量线性回归linear-regression-with-multiple-variables">第四章多变量线性回归（Linear Regression with Multiple Variables）</h1>目前为止，我们探讨了单变量/特征的回归模型，现在我们对房价模型增加更多的特征，例如房间数楼层等，构成一个含有多个变量的模型，模型中的特征为<span class="math inline">\((x_1, x_2, ... , x_n)\)</span><div align=center><figure><img src="media/16008554484862/16008647490984.jpg" alt="-w591" /><figcaption aria-hidden="true">-w591</figcaption></figure><div align=left><p>增添更多特征后，我们需要知道一些新的解释： * <spanclass="math inline">\(n\)</span>代表了特证的数量（每行的特征数），如<code>size</code>、<code>Number of bedrooms</code>、<code>Number of floors</code>、<code>Age of home（years）</code>等。* <span class="math inline">\(m\)</span> 代表了样例个数（图中行数）。 *<span class="math inline">\(x^{(i)}\)</span>代表第 <spanclass="math inline">\(i\)</span> 个训练实例（样例），特征矩阵的第 <spanclass="math inline">\(i\)</span> 行，是一个向量（vector），如上图 <spanclass="math inline">\(x_1^{(2)} = 1416， x_2^{(2)} = 3， x_3^{(2)} = 2，x_4^{(2)} = 40\)</span>。</p><p>支持多变量假设 <span class="math inline">\(h\)</span> 表示为 <spanclass="math inline">\(h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2+...+\theta_nx_n\)</span>，这个公式有n+1个参数和n个变量，为了使得公式能够简化一些，引入<span class="math inline">\(x_0 = 1\)</span>，即转化为 <spanclass="math inline">\(h_\theta(x) =\theta_0x_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n\)</span>，此模型的参数是一个<span class="math inline">\(n+1\)</span>维的向量，任何一个训练实例也都是 <spanclass="math inline">\(n+1\)</span> 维的向量，特征矩阵 <spanclass="math inline">\(X\)</span> 的维度是 <spanclass="math inline">\((n+1)\times m\)</span>。公式 <spanclass="math inline">\(h_\theta(x)=\theta^TX\)</span>，特征矩阵 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(\theta^T\)</span> 如下： <spanclass="math display">\[X=\left[\begin{matrix}x_0^{(1)}&amp;x_0^{(2)}&amp;x_0^{(3)}&amp;...&amp;x_0^{(m)}\\x_1^{(1)}&amp;x_1^{(2)}&amp;x_1^{(3)}&amp;...&amp;x_1^{(m)}\\&amp;...&amp;&amp;...\\x_n^{(1)}&amp;x_n^{(2)}&amp;x_n^{(3)}&amp;...&amp;x_n^{(m)}\end{matrix}\right]=\left[\begin{matrix}x_0\\x_1\\...\\x_n\end{matrix}\right],\theta^T=\left[\begin{matrix}\theta_0&amp;\theta_1&amp;\theta_2&amp;...&amp;\theta_n\end{matrix}\right]\]</span>所以 <span class="math inline">\(h_\theta(x)\)</span>的值为： <spanclass="math display">\[h_\theta(x)=\left[\begin{matrix}h_\theta(x^{(1)})&amp;h_\theta(x^{(2)})&amp;...&amp;h_\theta(x^{(m)})\end{matrix}\right]=\theta_0x_0+\theta_1x_1+...\theta_nx_n\ \ \ (x_0 = 1)\]</span></p><h2 id="多变量梯度下降">多变量梯度下降</h2><p>与单变量线性回归类似，在多变量线性回归中，我们也构建代价函数，这个代价函数是所有建模误差的平方和，即<span class="math inline">\(J(\theta_0, \theta_1, ..., \theta_n) =\frac{1}{2m}\sum\limits_{i = 1}^m(h_\theta(x^{(i)}) -y^{(i)})^2\)</span>, <span class="math inline">\(h_\theta(x) = \theta^TX= \theta_0 + \theta_1x_1 + ... +\theta_nx_n\)</span>，我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。多变量线性回归的批量梯度下降算法为：<span class="math inline">\(repeat\ \{ \\ \quad \theta_j := \theta_j -\alpha \frac{\partial}{\partial{\theta_j}}J(\theta_0, \theta_1, ..,\theta_n)\\ \}\)</span> 将代价函数带入并求导后，结果如下： <spanclass="math inline">\(repeat\ \{ \\ \quad \theta_j := \theta_j -\alpha\frac{1}{m}\sum\limits_{i = 1}^m((h_\theta(x^{(i)}) -y^{(i)})\cdot x_j^{(i)}) \ \ (simultaneously\ update\ \theta_j\ for\j=0, 1, 2, ..., n)\\ \}\)</span> 当特征数量 <spanclass="math inline">\(n=1\)</span>时，仅需要对 <spanclass="math inline">\(\theta_0\)</span> 和 <spanclass="math inline">\(\theta_1\)</span> 进行迭代（ <spanclass="math inline">\(j=0, 1\)</span> ），但是如果特征数量 <spanclass="math inline">\(n&gt;=1\)</span>，则 <spanclass="math inline">\(j=0, 1, 2, ..., n\)</span>，对 <spanclass="math inline">\(\theta_0, \theta_1, ..., \theta_n\)</span>均进行迭代。以上为多元线性回归模型。</p>当我们面对多维特征问题时，我们要保证这些特征都具有相近的尺度（即数量级相近），这将帮助梯度下降算法更快地收敛。以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为<span class="math inline">\(0-2000\)</span> 平方英尺，而房间数量的值则是<spanclass="math inline">\(0-5\)</span>，以两个参数分别为横纵坐标，绘制代价函数的等高线图，能看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。<div align=center><figure><img src="media/16008554484862/16009330200273.jpg" alt="-w200" /><figcaption aria-hidden="true">-w200</figcaption></figure><div align=left>解决的方法是尝试将所有特征的尺度都尽量缩放到 <spanclass="math inline">\(-1\)</span> 到 <spanclass="math inline">\(1\)</span> 之间。<div align=center><figure><img src="media/16008554484862/16009330631397.jpg" alt="-w600" /><figcaption aria-hidden="true">-w600</figcaption></figure><div align=left><h3 id="平均归一化mean-normalization">平均归一化（Meannormalization）</h3><p><strong>平均归一化：Replace <span class="math inline">\(x_i\)</span>with <span class="math inline">\(x_i - \mu_i\)</span> to make featureshave approximately zero mean（Do not apply to <spanclass="math inline">\(x_0=1\)</span>）</strong>，最简单的方法是令 <spanclass="math inline">\(x_n = \frac{x_n-\mu_n}{s_n}\)</span>，其中 <spanclass="math inline">\(\mu_n\)</span> 是平均值，<spanclass="math inline">\(s_n\)</span>是标准差。比如对于房屋尺寸 <spanclass="math inline">\(size\)</span> 的范围在 <spanclass="math inline">\(0\)</span> 到 <spanclass="math inline">\(2000\)</span>之间，平均值为 <spanclass="math inline">\(1000\)</span>，现在将尺寸特征转化，即是用公式：<spanclass="math inline">\(x_1 = \frac{size(feet^2) -1000}{2000}\)</span>，如房屋数量 <span class="math inline">\(0\)</span>到 <span class="math inline">\(5\)</span>，则 <spanclass="math inline">\(x_2 = \frac{number\ of\ bedrooms -2}{5}\)</span>。</p><h3 id="梯度下降法实践-学习率-alpha">梯度下降法实践-学习率 <spanclass="math inline">\(\alpha\)</span></h3>梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制<strong>迭代次数和代价函数的图</strong>来观测算法在何时趋于收敛。<div align=center><figure><img src="media/16008554484862/16009344410536.jpg" alt="-w358" /><figcaption aria-hidden="true">-w358</figcaption></figure><div align=left><p>也有一些自动测试是否收敛的方法，例如将代价函数的变化值与某个阀值（例如0.001）进行比较，但通常看上面这样的图表更好。梯度下降算法的每次迭代受到学习率的影响，如果学习率<span class="math inline">\(\alpha\)</span>过小，则达到收敛所需的迭代次数会非常高；如果学习率 <spanclass="math inline">\(\alpha\)</span>过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。通常可以考虑尝试些学习率：<span class="math display">\[\alpha = 0.01, 0.03, 0.1, 0.3, 1, 3,10\]</span></p><h3 id="特征和多项式回归">特征和多项式回归</h3><strong>Housing prices prediction</strong>： <spanclass="math inline">\(h_\theta(x) = \theta_0 + \theta_1\cdot frontage +\theta_2\cdot depth\)</span>，其中 <spanclass="math inline">\(frontage\)</span>为临街宽度，<spanclass="math inline">\(depth\)</span> 为纵向深度。<div align=center><figure><img src="media/16008554484862/16009366079427.jpg" alt="-w200" /><figcaption aria-hidden="true">-w200</figcaption></figure><div align=left><p>已知临街宽度和纵向深度，我们也可以得出面积 <spanclass="math inline">\(Area = x = frontage \timesdepth\)</span>，因此我们可以得出另一个 <spanclass="math inline">\(h_\theta(x)\)</span> 的式子： <spanclass="math inline">\(h_\theta(x) = \theta_0 + \theta_1 \cdotx\)</span>，其中 <span class="math inline">\(x =Area\)</span>。我们会发现构建一个线性回归的形式可能有多种。</p>对于我们构建的回归模型来说，有时候线性模型不一定适合于所有数据，那么这个时候我们可以变换线性回归的形式，将其改变为二次模型或者三次模型，比如说对于一个二次模型：<spanclass="math inline">\(h_\theta(x) = \theta_0 + \theta_1x_1 +\theta_2x_2^2\)</span>，或者三次模型：<spanclass="math inline">\(h_\theta(x) = \theta_0 + \theta_1x_1 +\theta_2x_2^2+\theta_3x_3^3\)</span><div align=center><figure><img src="media/16008554484862/16010155840042.jpg" alt="-w514" /><figcaption aria-hidden="true">-w514</figcaption></figure><div align=left><p>我们通常需要先观察数据的变化，然后再决定准备尝试怎样的模型。对于上图，按照常理来说随着面积尺寸的增大，价格是不会降低的，所以二次模型就不符合我们所要构建的回归模型，但是如果是三次模型，则不会像二次模型那样离谱。我们可以加入一个<span class="math inline">\(\theta_3\cdotx^3\)</span>，从而将模型转为线性回归模型，其中图中的 <spanclass="math inline">\(x=frontage\timesdepth\)</span>。我们还可以这样构建模型： <spanclass="math display">\[h_\theta(x) = \theta_0 + \theta_1(size) +\theta_2(size)^2\\h_\theta(x) = \theta_0 + \theta_1(size) + \theta_2\sqrt{(size)}\]</span>注：如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要，即上面说到的平均归一化。</p><h3 id="正归方程标准方程法">正归方程（标准方程法）</h3>前面我们一直在介绍梯度下降法，但是对于某些线性回归问题，正规方程的方法是更好的解决方案，如：<div align=center><figure><img src="media/16008554484862/16010405332699.jpg" alt="-w600" /><figcaption aria-hidden="true">-w600</figcaption></figure><div align=left>正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：<spanclass="math inline">\(\frac{\partial}{\partial\theta_j}J(\theta_j) =0\)</span>，假设我们的训练集特征矩阵为 <spanclass="math inline">\(X\)</span>（包含了 <span class="math inline">\(x_0= 1\)</span>），并且我们的训练结果为向量 <spanclass="math inline">\(y\)</span>，则利用正规方程解出向量 <strong><spanclass="math inline">\(\theta = (X^TX)^{-1}X^Ty\)</span></strong>。以下表数据为例：<div align=center><img src="media/16008554484862/16010436650415.jpg" alt="-w600" /> <imgsrc="media/16008554484862/16010437029411.jpg" alt="-w257" /><div align=left>运用正规方程求解参数 <span class="math inline">\(\theta\)</span>：<div align=center><figure><img src="media/16008554484862/16010437332345.jpg" alt="-w520" /><figcaption aria-hidden="true">-w520</figcaption></figure><div align=left><p>注：对于那些不可逆的矩阵（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量，导致多个特征值之间线性相关），正规方程方法是不能用的。</p><p>梯度下降与正规方程的比较：</p><table><thead><tr class="header"><th>梯度下降</th><th>正规方程</th></tr></thead><tbody><tr class="odd"><td>需要选择学习率 <span class="math inline">\(\alpha\)</span></td><td>不需要</td></tr><tr class="even"><td>需要对此迭代运算</td><td>一次运算得出</td></tr><tr class="odd"><td>当特征数量 <span class="math inline">\(n\)</span>大时也能较好适用</td><td>需要计算 <span class="math inline">\((X^TX)^{-1}\)</span>如果特征数量 <span class="math inline">\(n\)</span>大则运算代价大，因为矩阵逆的计算时间复杂度为 <spanclass="math inline">\(O(n^3)\)</span>，通常来说当 <spanclass="math inline">\(n &lt; 10000\)</span> 时还是可以接受的</td></tr><tr class="even"><td>适用于各种类型的模型</td><td>只适用于线性模型，不适合逻辑回归模型等其他模型</td></tr></tbody></table><p>总结一下，只要特征变量的数目并不大，正规方程是一个很好的计算参数<span class="math inline">\(\theta\)</span> 的替代方法。具体地说，<strong>只要特征变量数量小于一万，我通常使用正规方程的方法而不使用梯度下降法</strong>。</p><p>随着后面要讲的学习算法越来越复杂，例如，当我们讲到分类算法中逻辑回归算法，我们会看到，实际上对于那些算法，并不能使用正规方程的方法（标准方程法）。对于那些更复杂的学习算法，我们将不得不仍然使用梯度下降法。因此，梯度下降法是一个非常有用的算法，可以用在有大量特征变量的线性回归问题，因为正规方程（标准方程法）不适合或者不能用在它们上。但对于这个特定的线性回归模型，标准方程法是一个比梯度下降法更快的替代算法。所以根据具体的问题以及你的特征变量的数量，这两种算法都是值得学习的。</p><blockquote><p>What if <span class="math inline">\(X^TX\)</span> is<strong>non-invertible</strong>？ * <strong>Redundant features（linearlydependent）</strong></p></blockquote><blockquote><blockquote><p>E.g. <span class="math inline">\(x_1 = size\ in\feet^2\)</span>，<span class="math inline">\(x_2 = size\ in\m^2\)</span>， <span class="math inline">\(x_1\ x_2\)</span>属于同一类特征，线性相关了，所以不可逆</p></blockquote></blockquote><blockquote><ul><li>Too many features （E.g. <span class="math inline">\(m \leqslantn\)</span>）</li><li>Delete some features, or use regularization（正则化的方法）。</li></ul></blockquote><blockquote><blockquote><p>E.g. <span class="math inline">\(m = 10, n =100\)</span>，你要找到适合的参数 <span class="math inline">\(\theta \in\mathbb{R^{n+1}}\)</span>，要拟合 <spanclass="math inline">\(100\)</span> 个特征，但 <spanclass="math inline">\(10\)</span>个样本有些少，解决的办法通常是删除一些特征，或者使用一种叫做正则化的方法。</p></blockquote></blockquote><h3 id="theta-xtx-1xty-的推导"><span class="math inline">\(\theta =(X^TX)^{-1}X^Ty\)</span> 的推导</h3><p><span class="math inline">\(J(\theta) = \frac{1}{2m}\sum\limits_{i =1}^m(h_\theta(x^{(i)}) - y^{(i)})^2\)</span>，其中 <spanclass="math inline">\(h_\theta(x) = \theta^TX =\theta_0x_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n\)</span>，将向量表达式转化为矩阵表达式，则有<span class="math inline">\(J(\theta) =\frac{1}{2}(X\theta-y)^2\)</span>，其中 <spanclass="math inline">\(X\)</span> 为 <spanclass="math inline">\(m\)</span> 行 <spanclass="math inline">\(n\)</span> 列的矩阵（ <spanclass="math inline">\(m\)</span> 为样本个数，<spanclass="math inline">\(n\)</span> 为特征个数），<spanclass="math inline">\(\theta\)</span> 为 <spanclass="math inline">\(n\)</span> 行 <spanclass="math inline">\(1\)</span> 列的矩阵，对 <spanclass="math inline">\(J(\theta)\)</span> 进行如下变换： <spanclass="math display">\[J(\theta) =\frac{1}{2}(X\theta-y)^T(X\theta-y)\\\quad\quad\quad=\frac{1}{2}(\theta^TX^T-y^T)(X\theta-y)\\\quad\quad\quad\quad\quad\quad\quad\quad\quad=\frac{1}{2}(\theta^TX^TX\theta-\theta^TX^Ty-y^TX\theta-y^Ty)\]</span>接下来对 <span class="math inline">\(J(\theta)\)</span>求偏导，需要用到几个矩阵的求导法则：<spanclass="math inline">\(\frac{dAB}{dB} = A^T，\frac{dX^TAX}{dX} =2AX\)</span>，所以有： <span class="math display">\[\frac{\partialJ(\theta)}{\partial\theta} = \frac{1}{2}(2X^TX\theta-X^Ty-(y^TX)^T -0)\\\quad\quad\quad\quad\quad\quad\quad\quad\quad=\frac{1}{2}(2X^TX\theta-X^Ty-X^Ty-0)=X^TX\theta-X^Ty\]</span>令 <span class="math inline">\(\frac{\partial J(\theta)}{\partial\theta}= 0\)</span>，则有 <span class="math inline">\(\theta =(X^TX)^{-1}X^Ty\)</span></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/05/hello-world/"/>
    <url>/2023/08/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
