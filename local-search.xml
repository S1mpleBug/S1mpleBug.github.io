<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AcWing算法基础课知识点汇总</title>
    <link href="/2023/08/06/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <url>/2023/08/06/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="算法知识点讲解">算法知识点讲解</h2><ul><li><ahref="https://s1mplebug.github.io/2023/08/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/">二分查找模板</a></li></ul><h2 id="题目">题目</h2><h3 id="第二讲-数据结构">第二讲 数据结构</h3><ul><li><a href="">单链表</a></li></ul><h3 id="第四讲-数学知识">第四讲 数学知识</h3><ul><li><a href="">试除法判定质数</a></li><li><a href="">分解质因数</a></li><li><a href="">质数筛</a></li></ul><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找模板</title>
    <link href="/2023/08/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/08/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#一、整数二分">一、整数二分</a><ul><li><a href="#1-1整数二分查找模板">1.1 整数二分查找模板</a><ul><li><a href="#1-1-1寻找右边界的二分查找">1.1.1寻找右边界的二分查找</a></li><li><a href="#1-1-2寻找左边界的二分查找">1.1.2寻找左边界的二分查找</a></li></ul></li></ul></li><li><a href="#二、浮点数二分">二、浮点数二分</a><ul><li><a href="#2-1浮点数二分查找模板">2.1 浮点数二分查找模板</a></li></ul></li><li><a href="#三、使用stl进行二分查找">三、使用STL进行二分查找</a><ul><li><a href="#3-1-std-binary-search">3.1 std::binary_search</a></li><li><a href="#3-2-std-lower-bound">3.2 std::lower_bound</a></li><li><a href="#3-3-std-upper-bound">3.3 std::upper_bound</a></li><li><a href="#3-4-std-equal-range">3.4 std::equal_range</a></li></ul></li></ul><h1 id="一整数二分">一、整数二分</h1><p>二分查找分为整数二分和浮点数二分，一般所说的二分查找都是指整数二分。</p><h2 id="整数二分查找模板">1.1 整数二分查找模板</h2><p><strong>满足单调性的数组一定可以使用二分查找，但可以使用二分查找的数组不一定需要满足单调性。</strong></p><p>不妨假设我们找到了条件 <spanclass="math inline">\(C_1\)</span>​，它和它的 <strong>对立条件</strong><span class="math inline">\(C_2\)</span> 能够将数组 <spanclass="math inline">\(a\)</span> 一分为二，如下图所示：</p><figure><img src="/images/img-0.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption></figure><p>因为 <span class="math inline">\(C_1\)</span>​ 和 <spanclass="math inline">\(C_2\)</span> 互为对立，故总有 <spanclass="math inline">\(C_1\cup C_2\equiv \text{True}\)</span>，<spanclass="math inline">\(C_1\cap C_2\equiv\text{False}\)</span>（用C++语言描述，就是 <code>c1 || !c1</code>总是为真，<code>c1 &amp;&amp; !c1</code> 总是为假）。换句话说，<spanclass="math inline">\(\forall \,x\in a\)</span>，<spanclass="math inline">\(x\)</span> <strong>至少</strong> 满足 <spanclass="math inline">\(C_1\)</span> 和 <spanclass="math inline">\(C_2\)</span>​ 中的一个，且 <spanclass="math inline">\(x\)</span> <strong>不会同时满足</strong> <spanclass="math inline">\(C_1\)</span> 和 <spanclass="math inline">\(C_2\)</span>​。</p><p>观察上图可以发现，索引3和索引4这两个位置都可以作为<spanclass="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>的分界点。其中，索引3是红色区域的右边界，索引4是绿色区域的左边界。而我们接下来要讨论的二分查找模板就是用来<strong>寻找<span class="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>的分界点的</strong>。</p><h3 id="寻找右边界的二分查找">1.1.1 寻找右边界的二分查找</h3><p>前面说过，<span class="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>的分界点 <strong>一共有两个</strong>，因此我们的整数二分查找模板也有两个。一个用来查找右边界（即左侧的分界点，对应索引3），一个用来查找左边界（即右侧的分界点，对应索引3）。这里首先介绍查找右边界的模板。</p><p>因为查找的是 <strong>红色区域的右边界</strong> ，所以先定义一个函数<code>check(i)</code>，其中参数<code>i</code>是索引。当<code>i</code>位于红色区域，即<span class="math inline">\(0\leq i \leq 3\)</span>时，<code>check(i)</code> 为真；当<code>i</code>位于绿色区域，即<spanclass="math inline">\(4\leq i \leq 7\)</span>时，<code>check(i)</code>为假。</p><p>初始时设置左右两个指针分别位于数组的左右两端，每次循环时计算 <spanclass="math inline">\(mid=\frac{l+r}{2}\)</span>（至于<code>mid</code>到底取多少稍后会说），然后判断<code>check(mid)</code> 的值（为实现二分查找，<strong>我们需要确保每次缩小区间时答案都落在区间内</strong>。这样一来，当最终 <code>l == r</code> 时，<code>l</code>就是我们需要的答案）。如果 <code>check(mid)</code>为真，说明<code>mid</code>位于红色区域，且<code>mid</code><strong>有可能就是右边界</strong>，因此接下来令<code>l=mid</code>来缩小查找范围（因为我们要保证缩小后的区间仍然包含答案）；如果<code>check(mid)</code>为假，说明<code>mid</code>位于绿色区域，且<code>mid</code><strong>必不可能是红色区域的右边界</strong>，因为<code>mid</code>最多是索引4，因此令<code>r=mid-1</code>来缩小查找范围。</p><p>接下来重点关注<code>mid</code>到底该取多少。如果<spanclass="math inline">\(mid=\frac{l+r}{2}\)</span>​，其中的除法代表整除，在某一轮循环出现了<code>r-l=1</code>，则<spanclass="math inline">\(mid=\frac{2l+1}{2}=l\)</span>。若<code>check(mid)</code> 为真，则更新后的区间仍然为<spanclass="math inline">\([l,r]\)</span>，这就会导致无限循环。事实上，只需要取<spanclass="math inline">\(mid=\frac{l+r+1}{2}\)</span>​，若<code>check(mid)</code> 为真，则<code>mid=r</code>，更新后的区间为<spanclass="math inline">\([r,r]\)</span>，循环结束。若<code>check(mid)</code> 为假，则更新后的区间为<spanclass="math inline">\([l,l]\)</span>，循环结束。</p><p><strong>寻找右边界的二分查找模板：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = (l+r+<span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="寻找左边界的二分查找">1.1.2 寻找左边界的二分查找</h3><p>类似<code>1.1.1</code>节中的分析，因为查找的是<strong>绿色区域的左边界</strong> ，所以先定义一个函数<code>check(i)</code>，其中参数<code>i</code>是索引。当<code>i</code>位于绿色区域，即<span class="math inline">\(4\leq i \leq 7\)</span>时，<code>check(i)</code> 为真；当<code>i</code>位于红色区域，即 <spanclass="math inline">\(0\leq i \leq 3\)</span> 时，<code>check(i)</code>为假。</p><p>初始时设置左右两个指针分别位于数组的左右两端，每次循环时计算 <spanclass="math inline">\(mid=\frac{l+r}{2}\)</span>（至于<code>mid</code>到底取多少稍后会说），然后判断<code>check(mid)</code> 的值。如果 <code>check(mid)</code>为真，说明<code>mid</code>位于绿色区域，且<code>mid</code><strong>有可能就是左边界</strong>，因此接下来令<code>r=mid</code>来缩小查找范围；如果<code>check(mid)</code>为假，说明<code>mid</code>位于红色区域，且<code>mid</code><strong>必不可能是绿色区域的左边界</strong>，因为<code>mid</code>最多是索引3，因此令<code>l=mid+1</code>来缩小查找范围。</p><p>接下来重点关注<code>mid</code>到底该取多少。如果 <spanclass="math inline">\(mid=\frac{l+r}{2}\)</span>，其中的除法代表整除，在某一轮循环出现了<code>r-l=1</code>，则<span class="math inline">\(mid=\frac{2l+1}{2}=l\)</span>。若<code>check(mid)</code> 为真，则更新后的区间为<spanclass="math inline">\([l,l]\)</span>，循环结束。若<code>check(mid)</code> 为假，则更新后的区间为<spanclass="math inline">\([r,r]\)</span>，循环结束。综上所述，<code>mid</code>取<span class="math inline">\(\frac{l+r}{2}\)</span> 即可。</p><p><strong>寻找左边界的二分查找模板：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="二浮点数二分">二、浮点数二分</h1><h2 id="浮点数二分查找模板">2.1 浮点数二分查找模板</h2><p>相比整数二分，浮点数二分就要简单许多了，因为浮点数二分不涉及到边界问题。</p><p>浮点数二分 <strong>通常用来求某个数 <spanclass="math inline">\(x\)</span> 的近似值</strong>（ <spanclass="math inline">\(x\)</span> 不易直接求得，例如 <spanclass="math inline">\(x=\sqrt{2}\)</span>等）。由于此时左右两个指针也均为浮点数，所以我们不能直接判断<code>l == r</code>，而是判断 <code>r - l</code>是否小于预先设定的精度。</p><p>模板如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fsearch</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r, <span class="hljs-type">double</span> eps)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(r - l &gt; eps) &#123;<br>        <span class="hljs-type">double</span> mid = (l+r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>一些注意事项： *若要求精确到小数点后<code>k</code>位，则<code>eps</code>取 <spanclass="math inline">\(10^{-(k+2)}\)</span> * 若 <spanclass="math inline">\(mid\geq x\)</span>，则 <code>check(mid)</code>为真，否则为假</p><h1 id="三使用stl进行二分查找">三、使用STL进行二分查找</h1><h2 id="stdbinary_search">3.1 std::binary_search</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">binary_search</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br>```    <br><br><br>该函数用来检查 `[first, last)` 区间内（该区间已排序）是否有数字 **等于** `value`，如果有返回 `<span class="hljs-literal">true</span>`，否则返回 `<span class="hljs-literal">false</span>`。<br><br>## <span class="hljs-number">3.2</span> std::lower_bound<br>    <br>```<span class="hljs-function">cpp</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">lower_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure><p>该函数用来返回 <code>[first, last)</code> 区间内（该区间已排序）<strong>首个大于等于</strong> <code>value</code>的元素的迭代器，如果找不到这种元素则返回 <code>last</code>。</p><h2 id="stdupper_bound">3.3 std::upper_bound</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">upper_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure><p>该函数用来返回 <code>[first, last)</code> 区间内（该区间已排序）<strong>首个大于</strong> <code>value</code>的元素的迭代器，如果找不到这种元素则返回 <code>last</code>。</p><h2 id="stdequal_range">3.4 std::equal_range</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">std::pair&lt;ForwardIt, ForwardIt&gt;</span><br><span class="hljs-function">    <span class="hljs-title">equal_range</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure><p>该函数用来返回 <code>[first, last)</code> 区间内（该区间已排序）<strong>所有等于</strong> <code>value</code>的元素的「范围」。「范围」实际上是由两个迭代器构成的<code>pair</code>。<code>pair</code> 中的第一个元素是<code>std::lower_bound</code> 的返回值，<code>pair</code>中的第二个元素是 <code>std::upper_bound</code> 的返回值。</p><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode题解目录</title>
    <link href="/2023/08/06/Leetcode%E9%A2%98%E8%A7%A3%E7%9B%AE%E5%BD%95/"/>
    <url>/2023/08/06/Leetcode%E9%A2%98%E8%A7%A3%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>还没有开始捏，虚晃一枪，嘻嘻</p></blockquote><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
