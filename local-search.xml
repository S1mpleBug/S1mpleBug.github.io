<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>866.试除法判定质数</title>
    <link href="/2023/08/06/866-%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0/"/>
    <url>/2023/08/06/866-%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>时/空限制：1s / 64MB</p><h2 id="题目描述">题目描述</h2><p>给定n个正整数<spanclass="math inline">\(a_i\)</span>，判定每个数是否是质数。</p><h2 id="输入格式">输入格式</h2><p>第一行包含整数<span class="math inline">\(n\)</span>。</p><p>接下来<spanclass="math inline">\(n\)</span>行，每行包含一个正整数<spanclass="math inline">\(a_i\)</span>。</p><h2 id="输出格式">输出格式</h2><p>共<span class="math inline">\(n\)</span>行，其中第 <spanclass="math inline">\(i\)</span> 行输出第 <spanclass="math inline">\(i\)</span> 个正整数<spanclass="math inline">\(a_i\)</span>是否为质数，是则输出「Yes」，否则输出「No」。</p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(1 \le n \le 100\)</span>, <spanclass="math inline">\(1 \le a_i \le 2\times10^9\)</span></p><h2 id="输入样例">输入样例</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>2<br>6<br></code></pre></td></tr></table></figure><h2 id="输出样例">输出样例</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Yes</span><br><span class="hljs-keyword">No</span><br></code></pre></td></tr></table></figure><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 暴力O(n)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 这里是&lt; 不是&lt;=</span><br><span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上暴力做法「时间复杂度太高」，可根据「质数性质」对其优化。</p><blockquote><p><strong>质数性质</strong>：假设 <spanclass="math inline">\(|\)</span> 为整除符号，若 <spanclass="math inline">\(d | n\)</span> 成立，则 <spanclass="math inline">\(\frac{n}{d} | n\)</span> 成立。 举例：假设 <spanclass="math inline">\(n = 12\)</span>，若 <spanclass="math inline">\(2\)</span> 为 <spanclass="math inline">\(12\)</span> 的约数，那 <spanclass="math inline">\(6\)</span> 也是 <spanclass="math inline">\(12\)</span> 的约数；若 <spanclass="math inline">\(3\)</span> 为 <spanclass="math inline">\(12\)</span> 的约数，那 <spanclass="math inline">\(4\)</span> 也是 <spanclass="math inline">\(12\)</span>的约数。可发现「约数都是成对出现」。所以在枚举时，只需枚举出「成对约数」中较小的那一个即可。假设<span class="math inline">\(d\)</span> 为较小的数，即满足 <spanclass="math inline">\(d \le \frac{n}{d}\)</span>，此时要枚举区间 <spanclass="math inline">\([2, d]\)</span> 的所有正整数，整理得：<spanclass="math inline">\(d \le \sqrt{n}\)</span>，因此只需枚举区间 <spanclass="math inline">\([2, \sqrt{n}]\)</span> 范围的数即可。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 优化O(sqrt(n))</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n/i; ++i) &#123; <span class="hljs-comment">// 不推荐i*i &lt;= n的写法 和 i &lt;= sqrt(n)的写法</span><br><span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>循环终止条件用 <code>i &lt;= n/i</code> 最好，原因如下：<ul><li>若使用 <code>i &lt;= sqrt(n)</code>，每次循环都会使用 sqrt函数计算，产生时间开销。</li><li>若使用 <code>i*i &lt;= n</code>，<code>i*i</code>可能会造成数值溢出。</li></ul></li><li><code>x &lt; 2</code>时直接返回<code>false</code>。</li></ul><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>质数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>826.单链表</title>
    <link href="/2023/08/06/826-%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/08/06/826-%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#题目描述">题目描述</a></li><li><a href="#输入格式">输入格式</a></li><li><a href="#输出格式">输出格式</a></li><li><a href="#数据范围">数据范围</a></li><li><a href="#输入样例">输入样例</a></li><li><a href="#输出样例">输出样例</a></li><li><a href="#代码">代码</a></li><li><a href="#本题思路分析">本题思路分析</a></li><li><a href="#单链表知识点问题汇总">单链表知识点问题汇总</a><ul><li><a href="#1-head是什么？它的具体作用又是啥？">1.head是什么？它的具体作用又是啥？</a></li><li><a href="#2对于-k-1的相关问题？">2. 对于k-1的相关问题？</a></li><li><a href="#3关于-e-idx、-ne-idx和-idx的问题？">3.关于e[idx]、ne[idx]和idx的问题？</a></li><li><a href="#4对于删除头节点：-head-ne-head的操作？">4.对于删除头节点：head=ne[head]的操作？</a></li><li><a href="#5为什么最后一个节点的-ne-idx一定等于-1？">5.为什么最后一个节点的<code>ne[idx]</code>一定等于<code>-1</code>？</a></li><li><ahref="#6为什么每次循环输入的字符-op，用-cin-op可以-ac，而-scanf-c-op结果就不行？">6.为什么每次循环输入的字符op，用<code>cin &gt;&gt; op</code>可以<code>ac</code>，而<code>scanf("%c", &amp;op)</code>结果就不行？</a></li><li><a href="#7-head-idx等价于-head-idx-idx">7.<code>head = idx++</code> 等价于 <code>head=idx, idx++</code></a></li><li><a href="#8根据-1、3和5应该也就不难理解这句话了吧">8.根据1、3和5应该也就不难理解这句话了吧</a></li><li><a href="#9为何不用结构体方式构造链表？">9.为何不用结构体方式构造链表？</a></li></ul></li><li><a href="#参考文章">参考文章</a></li></ul><h2 id="题目描述">题目描述</h2><p>实现一个单链表，链表初始为空，支持三种操作：</p><ol type="1"><li>向链表头插入一个数；</li><li>删除第<spanclass="math inline">\(k\)</span>个插入的数后面的数；</li><li>在第<spanclass="math inline">\(k\)</span>个插入的数后插入一个数。</li></ol><p>现在要对该链表进行<spanclass="math inline">\(M\)</span>次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>：题目中第<spanclass="math inline">\(k\)</span>个插入的数并不是指当前链表的第<spanclass="math inline">\(k\)</span>个数。例如操作过程中一共插入了<spanclass="math inline">\(n\)</span>个数，则按照插入的时间顺序，这<spanclass="math inline">\(n\)</span>个数依次为：第<spanclass="math inline">\(1\)</span>个插入的数，第<spanclass="math inline">\(2\)</span>个插入的数，第<spanclass="math inline">\(n\)</span>个插入的数。</p><h2 id="输入格式">输入格式</h2><p>第一行包含整数 <spanclass="math inline">\(M\)</span>，表示操作次数。</p><p>接下来<spanclass="math inline">\(M\)</span>行，每行包含一个操作命令，操作命令可能为以下几种：</p><ol type="1"><li><code>H x</code>，表示向链表头插入一个数<spanclass="math inline">\(x\)</span>。</li><li><code>D k</code>，表示删除第<spanclass="math inline">\(k\)</span>个插入的数后面的数（当<spanclass="math inline">\(k\)</span>为<spanclass="math inline">\(0\)</span>时，表示删除头结点）。</li><li><code>I k x</code>，表示在第<spanclass="math inline">\(k\)</span>个插入的数后面插入一个数<spanclass="math inline">\(x\)</span>（此操作中<spanclass="math inline">\(k\)</span>均大于<spanclass="math inline">\(0\)</span>）。</li></ol><h2 id="输出格式">输出格式</h2><p>共一行，将整个链表从头到尾输出。</p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(1 \leq M\leq 100000\)</span></p><p>所有操作保证合法。</p><h2 id="输入样例">输入样例</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">10</span><br><span class="hljs-attribute">H</span> <span class="hljs-number">9</span><br><span class="hljs-attribute">I</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">D</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">D</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">H</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">I</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">I</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">I</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">I</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">D</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="输出样例">输出样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// head 表示头结点的下标</span><br><span class="hljs-comment">// e[i] 表示结点i的值</span><br><span class="hljs-comment">// ne[i] 表示结点i的next指针是多少</span><br><span class="hljs-comment">// idx 存储当前已经用到了哪个点</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> e[N], ne[N];<br><span class="hljs-type">int</span> head, idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; head = <span class="hljs-number">-1</span>, idx = <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-comment">// 单独处理头插</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; e[idx] = x; ne[idx] = head; head = idx; ++idx; &#125;<br><br><span class="hljs-comment">// 将value为x的结点插入到下标是k的结点后面</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123; e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; ++idx; &#125;<br><br><span class="hljs-comment">// 移除第k个结点后面的一个节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123; ne[k] = ne[ne[k]]; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n; cin &gt;&gt; n; <span class="hljs-built_in">init</span>(); <span class="hljs-comment">// init()初始化不要忘掉</span><br>    <span class="hljs-keyword">while</span>(n--) &#123;<br>        <span class="hljs-type">char</span> op; cin &gt;&gt; op;<br>        <span class="hljs-type">int</span> k, x;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;H&#x27;</span>) &#123;<br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">insert_head</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;D&#x27;</span>) &#123;<br>            cin &gt;&gt; k;<br>            <span class="hljs-keyword">if</span>(!k) head = ne[head];<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">remove</span>(k<span class="hljs-number">-1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cin &gt;&gt; k &gt;&gt; x;<br>            <span class="hljs-built_in">add</span>(k<span class="hljs-number">-1</span>, x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head; i != <span class="hljs-number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="本题思路分析">本题思路分析</h2><p>在本题中，第<code>k</code>个插入的元素位置到底在哪里？本题首先需要理解两个问题：1. 删除第<code>k</code>个插入的数后面的数 2.在第<code>k</code>个插入的数后面插入一个数</p><p>先解释一下什么叫第<code>k</code>个插入的元素： *把插入操作按先后排序，第<code>k</code>次执行插入操作的那个元素。 *注意：并不是链表中从前往后数第<code>k</code>个元素。</p><p>在链表中删除指针指向的元素的后一个元素，或者在指针指向的某个元素后面插入一个新元素是很容易实现的。所以，只要弄明白第<code>k</code>个插入的数的指针在哪里，这两个问题就很容易解决。</p><p>来分析一下插入操作： *链表为空的时候：<code>idx</code>的值为<code>0</code>， *插入第一个元素<code>a</code>后：<code>e[0] = a</code>，<code>idx</code>的值变为<code>1</code>，*插入第二个元素<code>b</code>后：<code>e[1] = b</code>，<code>idx</code>的值变为<code>2</code>，*插入第三个元素<code>c</code>后：<code>e[2] = c</code>，<code>idx</code>的值变为<code>3</code>，</p><p>所以：<strong>第<code>k</code>个出入元素的索引值<code>k - 1</code>。</strong></p><p>有人会说，如果中间删除了某些元素呢？</p><p>在看一下伴随着删除操作的插入： *链表为空的时候：<code>idx</code>的值为<code>0</code>， *插入第一个元素<code>a</code>后：<code>e[0] = a</code>，<code>idx</code>的值变为<code>1</code>，*插入第二个元素<code>b</code>后：<code>e[1] = b</code>，<code>idx</code>的值变为<code>2</code>，*删除第一个插入的元素<code>a</code>：<code>head</code>变为<code>1</code>，<code>idx</code>不变，依旧为<code>2</code>。*删除第二个插入的元素<code>b</code>：<code>head</code>变为<code>2</code>，<code>idx</code>不变，依旧为<code>2</code>。*插入第三个元素<code>c</code>后：<code>e[2] = c</code>，<code>idx</code>的值变为<code>3</code>。</p><p>所以删除操作并不改变第<code>k</code>个插入元素的索引。故第<code>k</code>个元素的索引一定是<code>k - 1</code>。</p><p>对于本题输入样例： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">10</span><br><span class="hljs-attribute">H</span> <span class="hljs-number">9</span><br><span class="hljs-attribute">I</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">D</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">D</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">H</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">I</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">I</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">I</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">I</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">D</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></p><p>我们给出操作图示：</p><p><img src="/images/img-1.png" /></p><p>最终链表结果如图： <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></p><figure><img src="/images/img-2.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption></figure><h2 id="单链表知识点问题汇总">单链表知识点问题汇总</h2><h3 id="head是什么它的具体作用又是啥">1.head是什么？它的具体作用又是啥？</h3><p><code>head</code>应该是一个特殊的指针，一开始指向<code>-1</code>，表示链表里没有内容，为空节点，当链表里有元素的时候，它变成了一个指向第一个元素的指针。还有就是为了最后遍历链表时，知道链表什么时候结束（因为最后实现的链表，它最后一个节点的<code>ne[i]</code>一定等于<code>-1</code>）</p><h3 id="对于k-1的相关问题">2. 对于k-1的相关问题？</h3><p>这个函数含义是将<code>x</code>插到下标是<code>k</code>的点后面。题目里要将<code>x</code>插入到第<code>k</code>个插入的数后面，第<code>k</code>个插入的数下标是<code>k - 1</code>，所以调用的时候是<code>add(k - 1, x)</code>和<code>remove(k - 1)</code>。如果你一开始将<code>idx = 1</code>（初始化），那么下标和<code>k</code>就统一了，就不需要再<code>k - 1</code>了。</p><h3 id="关于eidxneidx和idx的问题">3.关于e[idx]、ne[idx]和idx的问题？</h3><p><code>idx</code>可以理解为一个结点！！准确来说是某个结点的唯一标识，也是链表中结点的索引下标。</p><p><strong>结点</strong>：链表的元素，含<code>e[idx]</code>，<code>ne[idx]</code>两个部分：1. <code>e[idx]</code>：结点编号为<code>idx</code>对应的节点值 2.<code>ne[idx]</code>：结点编号为<code>idx</code>对应的下一个结点的编号</p><p>要明白<code>idx</code>只是记录当前的操作的位置，一般实现的链表<code>idx</code>是乱序的（前后的节点的数组下标不需要连续【不理解，可以带入样例观察】），需要通过当前的<code>ne[i]</code>找到下一个<code>idx</code>。这也是两者的联系。</p><h3 id="对于删除头节点headnehead的操作">4.对于删除头节点：head=ne[head]的操作？</h3><p>删除头结点是<code>head</code>指向的结点，也就是链表中的第一个结点，<code>head</code>指向可能是一个空结点（<code>e</code>数组不存值），或者是非空结点。指向空结点的叫头结点，指向非空结点的叫首元结点。但是y总并没有区分这个概念，所以删除头结点就是删除链表的第一个有值的结点，<code>head</code>指向<code>ne[head]</code>是因为<code>head</code>本来就指向它的下一个结点，所以<code>ne[head]</code>就是头结点的下一个结点。</p><h3 id="为什么最后一个节点的neidx一定等于-1">5.为什么最后一个节点的<code>ne[idx]</code>一定等于<code>-1</code>？</h3><p>首先这个<code>head</code>指的是链表中头节点的下标，当链表中没有节点时<code>head = -1</code>，但当链表中有值插到头节点的时候，<code>head</code>储存的就是这个值的<code>idx</code>，通过<code>e[idx]</code>可以求出这个节点的值。而<code>ne[idx]</code>就等于<code>head</code>之前的值，即<code>-1</code>。如果再在头节点插入一个元素，则<code>head</code>指向这个元素的<code>idx2</code>，而<code>ne[idx2]</code>就等于上一次插入的<code>head</code>值，即<code>idx</code>。此时，<code>head = idx2</code>，<code>ne[idx2] = idx</code>，<code>ne[idx] = -1</code>。</p><p>比如：因为初始化<code>head = -1</code>，<code>head</code>指向链表的头节点地址；例如输入<code>H 9</code>后，则有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">e[<span class="hljs-number">0</span>] = <span class="hljs-number">9</span>; ne[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>; head = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>之后无论进行什么操作，链表最后一个节点，其对应的<code>ne</code>数组值一定为<code>-1</code>。</p><h3id="为什么每次循环输入的字符op用cin-op可以ac而scanfc-op结果就不行">6.为什么每次循环输入的字符op，用<code>cin &gt;&gt; op</code>可以<code>ac</code>，而<code>scanf("%c", &amp;op)</code>结果就不行？</h3><p>这个是分情况的。有一个特殊的格式<code>%c</code>，当<code>%c</code>格式的时候，会读取任何字符，包括换行和空格。当其他格式的时候（不包括正则表达式），如果空格或者换行出现在前面，会被读取并抛弃。在后面的时候，不会读取，而只是检测。</p><p>其实这里也可以写成<code>scanf(" %c", &amp;op)</code>【<code>%c</code>前面要加空格】，以过滤空格和回车。</p><h3 id="head-idx-等价于-headidx-idx">7. <code>head = idx++</code> 等价于<code>head=idx, idx++</code></h3><h3 id="根据13和5应该也就不难理解这句话了吧">8.根据1、3和5应该也就不难理解这句话了吧</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head; i != <span class="hljs-number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="为何不用结构体方式构造链表">9. 为何不用结构体方式构造链表？</h3><p>链表由节点构成，每个节点保存了<strong>值</strong>和<strong>下一个元素的位置</strong>这两个信息。节点的表示形式如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> val;<br>    Node* next;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>这样构造出链表节点的是一个好方法，也是许多人一开始就学到的。使用这种方法，在创建一个值为<code>x</code>新节点的时候，语法是：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>node-&gt;val = x<br></code></pre></td></tr></table></figure></p><p>看一下创建新节点的代码的第一行： <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span><span class="hljs-title">* node</span> = new <span class="hljs-keyword">Node</span><span class="hljs-title">();，</span><br></code></pre></td></tr></table></figure>中间有一个<code>new</code>关键字来为新对象分配空间。<code>new</code>的底层涉及内存分配，调用构造函数，指针转换等多种复杂且费时的操作。在平时的工程代码中，不会涉及上万次的<code>new</code>操作，所以这种结构是一种见代码知意的好结构。</p><p>但是在算法比赛中，经常碰到操作在<code>10</code>万级别的链表操作，如果使用结构体这种操作，是无法在算法规定时间完成的。所以，在算法比赛这种有严格的时间要求的环境中，不能频繁使用<code>new</code>操作。也就不能使用结构体来实现数组。</p><h2 id="参考文章">参考文章</h2><ul><li><ahref="https://blog.csdn.net/weixin_49486457/article/details/122825779">数组实现单链表Acwing.826 单链表</a></li></ul><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing算法基础课知识点汇总</title>
    <link href="/2023/08/06/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <url>/2023/08/06/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="算法知识点讲解">算法知识点讲解</h2><ul><li><ahref="https://s1mplebug.github.io/2023/08/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/">二分查找模板</a></li></ul><h2 id="题目">题目</h2><h3 id="第二讲-数据结构">第二讲 数据结构</h3><ul><li><ahref="https://s1mplebug.github.io/2023/08/06/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/">单链表</a></li></ul><h3 id="第四讲-数学知识">第四讲 数学知识</h3><ul><li><ahref="https://s1mplebug.github.io/2023/08/06/866-%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0/">试除法判定质数</a></li><li><a href="">分解质因数</a></li><li><a href="">质数筛</a></li></ul><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>无标签</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找模板</title>
    <link href="/2023/08/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/08/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#一、整数二分">一、整数二分</a><ul><li><a href="#1-1整数二分查找模板">1.1 整数二分查找模板</a><ul><li><a href="#1-1-1寻找右边界的二分查找">1.1.1寻找右边界的二分查找</a></li><li><a href="#1-1-2寻找左边界的二分查找">1.1.2寻找左边界的二分查找</a></li></ul></li></ul></li><li><a href="#二、浮点数二分">二、浮点数二分</a><ul><li><a href="#2-1浮点数二分查找模板">2.1 浮点数二分查找模板</a></li></ul></li><li><a href="#三、使用stl进行二分查找">三、使用STL进行二分查找</a><ul><li><a href="#3-1-std-binary-search">3.1 std::binary_search</a></li><li><a href="#3-2-std-lower-bound">3.2 std::lower_bound</a></li><li><a href="#3-3-std-upper-bound">3.3 std::upper_bound</a></li><li><a href="#3-4-std-equal-range">3.4 std::equal_range</a></li></ul></li></ul><h1 id="一整数二分">一、整数二分</h1><p>二分查找分为整数二分和浮点数二分，一般所说的二分查找都是指整数二分。</p><h2 id="整数二分查找模板">1.1 整数二分查找模板</h2><p><strong>满足单调性的数组一定可以使用二分查找，但可以使用二分查找的数组不一定需要满足单调性。</strong></p><p>不妨假设我们找到了条件 <spanclass="math inline">\(C_1\)</span>​，它和它的 <strong>对立条件</strong><span class="math inline">\(C_2\)</span> 能够将数组 <spanclass="math inline">\(a\)</span> 一分为二，如下图所示：</p><figure><img src="/images/img-0.png" alt="upload successful" /><figcaption aria-hidden="true">upload successful</figcaption></figure><p>因为 <span class="math inline">\(C_1\)</span>​ 和 <spanclass="math inline">\(C_2\)</span> 互为对立，故总有 <spanclass="math inline">\(C_1\cup C_2\equiv \text{True}\)</span>，<spanclass="math inline">\(C_1\cap C_2\equiv\text{False}\)</span>（用C++语言描述，就是 <code>c1 || !c1</code>总是为真，<code>c1 &amp;&amp; !c1</code> 总是为假）。换句话说，<spanclass="math inline">\(\forall \,x\in a\)</span>，<spanclass="math inline">\(x\)</span> <strong>至少</strong> 满足 <spanclass="math inline">\(C_1\)</span> 和 <spanclass="math inline">\(C_2\)</span>​ 中的一个，且 <spanclass="math inline">\(x\)</span> <strong>不会同时满足</strong> <spanclass="math inline">\(C_1\)</span> 和 <spanclass="math inline">\(C_2\)</span>​。</p><p>观察上图可以发现，索引3和索引4这两个位置都可以作为<spanclass="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>的分界点。其中，索引3是红色区域的右边界，索引4是绿色区域的左边界。而我们接下来要讨论的二分查找模板就是用来<strong>寻找<span class="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>的分界点的</strong>。</p><h3 id="寻找右边界的二分查找">1.1.1 寻找右边界的二分查找</h3><p>前面说过，<span class="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>的分界点 <strong>一共有两个</strong>，因此我们的整数二分查找模板也有两个。一个用来查找右边界（即左侧的分界点，对应索引3），一个用来查找左边界（即右侧的分界点，对应索引3）。这里首先介绍查找右边界的模板。</p><p>因为查找的是 <strong>红色区域的右边界</strong> ，所以先定义一个函数<code>check(i)</code>，其中参数<code>i</code>是索引。当<code>i</code>位于红色区域，即<span class="math inline">\(0\leq i \leq 3\)</span>时，<code>check(i)</code> 为真；当<code>i</code>位于绿色区域，即<spanclass="math inline">\(4\leq i \leq 7\)</span>时，<code>check(i)</code>为假。</p><p>初始时设置左右两个指针分别位于数组的左右两端，每次循环时计算 <spanclass="math inline">\(mid=\frac{l+r}{2}\)</span>（至于<code>mid</code>到底取多少稍后会说），然后判断<code>check(mid)</code> 的值（为实现二分查找，<strong>我们需要确保每次缩小区间时答案都落在区间内</strong>。这样一来，当最终 <code>l == r</code> 时，<code>l</code>就是我们需要的答案）。如果 <code>check(mid)</code>为真，说明<code>mid</code>位于红色区域，且<code>mid</code><strong>有可能就是右边界</strong>，因此接下来令<code>l=mid</code>来缩小查找范围（因为我们要保证缩小后的区间仍然包含答案）；如果<code>check(mid)</code>为假，说明<code>mid</code>位于绿色区域，且<code>mid</code><strong>必不可能是红色区域的右边界</strong>，因为<code>mid</code>最多是索引4，因此令<code>r=mid-1</code>来缩小查找范围。</p><p>接下来重点关注<code>mid</code>到底该取多少。如果<spanclass="math inline">\(mid=\frac{l+r}{2}\)</span>​，其中的除法代表整除，在某一轮循环出现了<code>r-l=1</code>，则<spanclass="math inline">\(mid=\frac{2l+1}{2}=l\)</span>。若<code>check(mid)</code> 为真，则更新后的区间仍然为<spanclass="math inline">\([l,r]\)</span>，这就会导致无限循环。事实上，只需要取<spanclass="math inline">\(mid=\frac{l+r+1}{2}\)</span>​，若<code>check(mid)</code> 为真，则<code>mid=r</code>，更新后的区间为<spanclass="math inline">\([r,r]\)</span>，循环结束。若<code>check(mid)</code> 为假，则更新后的区间为<spanclass="math inline">\([l,l]\)</span>，循环结束。</p><p><strong>寻找右边界的二分查找模板：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = (l+r+<span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="寻找左边界的二分查找">1.1.2 寻找左边界的二分查找</h3><p>类似<code>1.1.1</code>节中的分析，因为查找的是<strong>绿色区域的左边界</strong> ，所以先定义一个函数<code>check(i)</code>，其中参数<code>i</code>是索引。当<code>i</code>位于绿色区域，即<span class="math inline">\(4\leq i \leq 7\)</span>时，<code>check(i)</code> 为真；当<code>i</code>位于红色区域，即 <spanclass="math inline">\(0\leq i \leq 3\)</span> 时，<code>check(i)</code>为假。</p><p>初始时设置左右两个指针分别位于数组的左右两端，每次循环时计算 <spanclass="math inline">\(mid=\frac{l+r}{2}\)</span>（至于<code>mid</code>到底取多少稍后会说），然后判断<code>check(mid)</code> 的值。如果 <code>check(mid)</code>为真，说明<code>mid</code>位于绿色区域，且<code>mid</code><strong>有可能就是左边界</strong>，因此接下来令<code>r=mid</code>来缩小查找范围；如果<code>check(mid)</code>为假，说明<code>mid</code>位于红色区域，且<code>mid</code><strong>必不可能是绿色区域的左边界</strong>，因为<code>mid</code>最多是索引3，因此令<code>l=mid+1</code>来缩小查找范围。</p><p>接下来重点关注<code>mid</code>到底该取多少。如果 <spanclass="math inline">\(mid=\frac{l+r}{2}\)</span>，其中的除法代表整除，在某一轮循环出现了<code>r-l=1</code>，则<span class="math inline">\(mid=\frac{2l+1}{2}=l\)</span>。若<code>check(mid)</code> 为真，则更新后的区间为<spanclass="math inline">\([l,l]\)</span>，循环结束。若<code>check(mid)</code> 为假，则更新后的区间为<spanclass="math inline">\([r,r]\)</span>，循环结束。综上所述，<code>mid</code>取<span class="math inline">\(\frac{l+r}{2}\)</span> 即可。</p><p><strong>寻找左边界的二分查找模板：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="二浮点数二分">二、浮点数二分</h1><h2 id="浮点数二分查找模板">2.1 浮点数二分查找模板</h2><p>相比整数二分，浮点数二分就要简单许多了，因为浮点数二分不涉及到边界问题。</p><p>浮点数二分 <strong>通常用来求某个数 <spanclass="math inline">\(x\)</span> 的近似值</strong>（ <spanclass="math inline">\(x\)</span> 不易直接求得，例如 <spanclass="math inline">\(x=\sqrt{2}\)</span>等）。由于此时左右两个指针也均为浮点数，所以我们不能直接判断<code>l == r</code>，而是判断 <code>r - l</code>是否小于预先设定的精度。</p><p>模板如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fsearch</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r, <span class="hljs-type">double</span> eps)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(r - l &gt; eps) &#123;<br>        <span class="hljs-type">double</span> mid = (l+r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>一些注意事项： *若要求精确到小数点后<code>k</code>位，则<code>eps</code>取 <spanclass="math inline">\(10^{-(k+2)}\)</span> * 若 <spanclass="math inline">\(mid\geq x\)</span>，则 <code>check(mid)</code>为真，否则为假</p><h1 id="三使用stl进行二分查找">三、使用STL进行二分查找</h1><h2 id="stdbinary_search">3.1 std::binary_search</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">binary_search</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br>```    <br><br><br>该函数用来检查 `[first, last)` 区间内（该区间已排序）是否有数字 **等于** `value`，如果有返回 `<span class="hljs-literal">true</span>`，否则返回 `<span class="hljs-literal">false</span>`。<br><br>## <span class="hljs-number">3.2</span> std::lower_bound<br><br>```<span class="hljs-function">cpp</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">lower_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure><p>该函数用来返回 <code>[first, last)</code> 区间内（该区间已排序）<strong>首个大于等于</strong> <code>value</code>的元素的迭代器，如果找不到这种元素则返回 <code>last</code>。</p><h2 id="stdupper_bound">3.3 std::upper_bound</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">upper_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure><p>该函数用来返回 <code>[first, last)</code> 区间内（该区间已排序）<strong>首个大于</strong> <code>value</code>的元素的迭代器，如果找不到这种元素则返回 <code>last</code>。</p><h2 id="stdequal_range">3.4 std::equal_range</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">std::pair&lt;ForwardIt, ForwardIt&gt;</span><br><span class="hljs-function">    <span class="hljs-title">equal_range</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure><p>该函数用来返回 <code>[first, last)</code> 区间内（该区间已排序）<strong>所有等于</strong> <code>value</code>的元素的「范围」。「范围」实际上是由两个迭代器构成的<code>pair</code>。<code>pair</code> 中的第一个元素是<code>std::lower_bound</code> 的返回值，<code>pair</code>中的第二个元素是 <code>std::upper_bound</code> 的返回值。</p><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode题解目录</title>
    <link href="/2023/08/06/Leetcode%E9%A2%98%E8%A7%A3%E7%9B%AE%E5%BD%95/"/>
    <url>/2023/08/06/Leetcode%E9%A2%98%E8%A7%A3%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>还没有开始捏，虚晃一枪，嘻嘻</p></blockquote><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
