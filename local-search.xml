<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>868.质数筛</title>
    <link href="/2023/08/06/868-%E8%B4%A8%E6%95%B0%E7%AD%9B/"/>
    <url>/2023/08/06/868-%E8%B4%A8%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<p>时/空限制：0.2s / 64MB</p><h2 id="题目描述">题目描述</h2><p>给定一个正整数 <span class="math inline">\(n\)</span>，请你求出 <spanclass="math inline">\(1 \sim n\)</span> 中质数的个数。</p><h2 id="输入格式">输入格式</h2><p>共一行，包含整数 <span class="math inline">\(n\)</span>。</p><h2 id="输出格式">输出格式</h2><p>共一行，包含一个整数，表示 <span class="math inline">\(1 \simn\)</span> 中质数的个数。</p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(1 \le n \le 10^6\)</span></p><h2 id="输入样例">输入样例</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h2 id="输出样例">输出样例</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><blockquote><p>解释：输入 <span class="math inline">\(8\)</span>，则 <spanclass="math inline">\(8\)</span> 以内有 <spanclass="math inline">\(4\)</span> 个质数，分别为 <spanclass="math inline">\(2\)</span>、<spanclass="math inline">\(3\)</span>、<spanclass="math inline">\(5\)</span>、<spanclass="math inline">\(7\)</span>。</p></blockquote><h2 id="代码">代码</h2><blockquote><p>筛质数：先去掉 <span class="math inline">\(2\)</span> 的倍数，再去掉<span class="math inline">\(3\)</span> 的倍数，再去掉 <spanclass="math inline">\(4\)</span>的倍数，…依此类推，最后剩下的就是素数。</p></blockquote><p><code>primes</code>数组存放的是 <span class="math inline">\(1 \simn\)</span>中的质数。<code>cnt</code>只是一个索引，<code>st</code>数组用来标记对应索引是否筛掉，初始默认<code>false</code>。</p><h3 id="埃氏筛法">埃氏筛法</h3><p>思路是，每次遍历找出一个数，第一次筛出来的 <spanclass="math inline">\(2\)</span> 肯定是质数，将 <spanclass="math inline">\(2\)</span>加入到<code>primes</code>数组中，然后成倍增加其值，<spanclass="math inline">\(2\)</span>的倍数都不是质数，直接筛除掉，然后继续筛 <spanclass="math inline">\(3\)</span>，将 <spanclass="math inline">\(3\)</span>加入到<code>primes</code>数组中，依次遍历下去，最后始终筛不出来的一定是质数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<span class="hljs-comment">// primes数组存储所有质数</span><br><span class="hljs-type">bool</span> st[N];<span class="hljs-comment">// 初始化为false，st数组标记被筛掉的索引</span><br><br><span class="hljs-comment">// 暴力做法O(n log(logn)) 埃氏筛法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) primes[cnt++] = i;<span class="hljs-comment">// 记录筛出的质数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>*i; j &lt;= n; j += i) st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉筛法线性筛法">欧拉筛法（线性筛法）</h3><p><strong>核心思想</strong>：每个合数必有一个最小质因数，用这个最小的质因数筛掉合数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">// 线性O(n)优化 欧拉筛法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) primes[cnt++] = i;<span class="hljs-comment">// 没有被筛去 说明是质数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n/i; ++j) &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 用最小质因子去筛合数primes[j] * i</span><br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;   <span class="hljs-comment">// 当该条件成立 primes[j]一定是i的最小质因子</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>理解：</strong> *当<code>i % primes[j] != 0</code>时，说明此时遍历到的<code>primes[j]</code>不是<code>i</code>的质因子，那么此时的<code>primes[j]</code>一定小于所有<code>i</code>的质因子，但是能说明：-<code>primes[j] * i</code>的<strong>最小质因子</strong>是<code>primes[j]</code>」*当有<code>i % primes[j] == 0</code>时，说明<code>i</code>的<strong>最小质因子</strong>是<code>primes[j]</code>，因此能说明：-<code>primes[j] * i</code>的<strong>最小质因子</strong>也就应该是<code>prime[j]</code></p><p>综上两种情况，不论是什么情况，都可以得出结论：<code>primes[j] * i</code>的最小质因子是<code>primes[j]</code>。</p><p>所以上述代码中第二层<code>for</code>循环里，无论什么情况，<code>primes[j]</code>都是<code>primes[j] * i</code>的最小质因子，所以在枚举时都会执行语句：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">st[primes[j] * i] = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>来通过当前<code>primes[j] * i</code>的最小质因子<code>primes[j]</code>去把<code>primes[j] * i</code>删除掉。</p><p>总之，对于一个合数<code>x</code>，假设<code>primes[j]</code>是<code>x</code>的最小质因子，当<code>i</code>枚举到<code>x / primes[j]</code>时，一定能够把对应的合数<code>x</code>筛掉。</p><h4 id="注意">注意</h4><ul><li>在第二层<code>for</code>循环中，判断条件不必写为：<code>for(int j = 0; j &lt; cnt &amp;&amp; primes[j] &lt;= n/i; ++j)</code>，原因有两点：<ul><li>若<code>i</code>为合数，当<code>primes[j]</code>枚举到<code>i</code>的<strong>最小质因子</strong>时，就一定会通过<code>break</code>语句跳出循环。</li><li>若<code>i</code>为质数，当<code>primes[j]</code>遍历到<code>primes[j] = i</code>时也会通过<code>break</code>语句跳出循环。</li><li>所以综上两点原因，一定会在<code>cnt</code>之前就停下来，所以<code>j &lt; cnt</code>这条语句是不需要添加的。</li></ul></li><li>线性筛法保证了所有的合数都是被它的最小质因子筛掉的。</li></ul><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>质数筛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>867.分解质因数</title>
    <link href="/2023/08/06/867-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/"/>
    <url>/2023/08/06/867-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>时/空限制：1s / 64MB</p><h2 id="题目描述">题目描述</h2><p>给定<span class="math inline">\(n\)</span>个正整数<spanclass="math inline">\(a_i\)</span>，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。</p><h2 id="输入格式">输入格式</h2><p>第一行包含整数<span class="math inline">\(n\)</span>。</p><p>接下来<spanclass="math inline">\(n\)</span>行，每行包含一个正整数<spanclass="math inline">\(a_i\)</span>。</p><h2 id="输出格式">输出格式</h2><p>对于每个正整数<spanclass="math inline">\(a_i\)</span>，按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。</p><p>每个正整数的质因数全部输出完毕后，输出一个空行。</p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(1 \le n \le 100\)</span>, <spanclass="math inline">\(1 \le a_i \le 2\times10^9\)</span></p><h2 id="输入样例">输入样例</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>6<br>8<br></code></pre></td></tr></table></figure><h2 id="输出样例">输出样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><br><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><blockquote><p>解释：第一行输入 <spanclass="math inline">\(2\)</span>，说明接下来两行输入两个数，第一个输入是<spanclass="math inline">\(6\)</span>，输出结果为两行，每行的含义是：底数为数字<span class="math inline">\(2\)</span>，指数为 <spanclass="math inline">\(1\)</span>，底数为数字 <spanclass="math inline">\(3\)</span>，指数为 <spanclass="math inline">\(1\)</span>，即 <span class="math inline">\(6 = 2^1\times 3^1\)</span>。第二个输入是 <spanclass="math inline">\(8\)</span>，则输出结果为一行，含义是：底数为数字<span class="math inline">\(2\)</span>，指数为 <spanclass="math inline">\(3\)</span>，即 <span class="math inline">\(8 =2^3\)</span>。</p></blockquote><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 暴力枚举</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>) &#123;<br>n /= i;<br>++s;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);<br>&#125;<br>&#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>前文 「<ahref="https://s1mplebug.github.io/2023/08/06/866-%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0/">866.试除法判定质数</a>」谈及到「质数性质」可用于优化本题，可知：输入数字<span class="math inline">\(n\)</span> 中最多只包含一个大于 <spanclass="math inline">\(\sqrt{n}\)</span>的质因子（假设某数分解出来的两个质因子均大于 <spanclass="math inline">\(\sqrt{n}\)</span>，则乘积就会大于 <spanclass="math inline">\(n\)</span>，那这显然不成立）。因此枚举时，可先枚举<span class="math inline">\(\le \sqrt{n}\)</span>的质因子，优化代码如下，将<code>for</code>循环范围改至<code>n/i</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 优化版本O(sqrt(n))</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; ++i) &#123; <span class="hljs-comment">// 优化为 i &lt;= n / i</span><br><span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>) &#123;<br>n /= i;<br>++s;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 质数最多存在一个大于sqrt(n)的质因子</span><br><span class="hljs-comment">// 例如：6 = 2 * 3，sqrt(6) = 2.44949，存在一个大于sqrt(6)的质因子3</span><br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, n, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>本题优化版本相比「<ahref="https://s1mplebug.github.io/2023/08/06/866-%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0/">866.试除法判定质数</a>」优化版本，时间复杂度不同，<code>866</code>题优化版本时间复杂度一定为<spanclass="math inline">\(\text{O}(\sqrt{n})\)</span>；本题优化版本有可能当<span class="math inline">\(i = 2\)</span>成立后，进入<code>while</code>执行完毕，直接跳出循环，导致最快时间复杂度为<span class="math inline">\(\text{O}({\logn})\)</span>，因此本题优化版本时间复杂度介于 <spanclass="math inline">\(\text{O}({\log n})\)</span> 和 <spanclass="math inline">\(\text{O}(\sqrt{n})\)</span> 之间。</p><table><thead><tr class="header"><th style="text-align: left;">算法</th><th style="text-align: center;">时间复杂度</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">判断是否为质数「<ahref="https://s1mplebug.github.io/2023/08/06/866-%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0/">866.试除法判定质数</a>」优化版本</td><td style="text-align: center;"><spanclass="math inline">\(\text{O}(\sqrt{n})\)</span></td></tr><tr class="even"><tdstyle="text-align: left;">分解某数为多个质因数乘积（本题优化版本）</td><td style="text-align: center;">介于 <spanclass="math inline">\(\text{O}({\log n})\)</span> 和 <spanclass="math inline">\(\text{O}(\sqrt{n})\)</span> 之间</td></tr></tbody></table><h2 id="补充">补充</h2><ol type="1"><li>算术基本定理（唯一分解定理） <spanclass="math inline">\(\forall\)</span> 大于 <spanclass="math inline">\(1\)</span> 的正整数 <spanclass="math inline">\(N\)</span>，若 <spanclass="math inline">\(N\)</span>不为质数，都可以唯一分解成有限个质数的乘积。<spanclass="math inline">\(N = P_1^{a_1} \times P_2^{a_2} \times ... \timesP_n^{a_n}\)</span>，这里 <span class="math inline">\(P_1 &lt; P_2 &lt;... &lt; P_n\)</span> 均为质数，指数 <spanclass="math inline">\(a_i\)</span> 是正整数。</li><li>算法思路：枚举 <span class="math inline">\(i\)</span> 从 <spanclass="math inline">\(2\)</span> 到 <spanclass="math inline">\(\sqrt{n}\)</span>，如果<code>n % i == 0</code>，就一直用 <span class="math inline">\(n\)</span>除以 <span class="math inline">\(i\)</span>，求出来 <spanclass="math inline">\(i\)</span> 的指数，并用 <spanclass="math inline">\(s\)</span> 来记录；若最终 <spanclass="math inline">\(n &gt; 1\)</span>，则此时的 <spanclass="math inline">\(n\)</span> 是大于 <spanclass="math inline">\(\sqrt{n}\)</span> 的那个唯一的质因数；</li></ol><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>质数分解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing算法基础课知识点汇总</title>
    <link href="/2023/08/06/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <url>/2023/08/06/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>AcWing算法基础课页面：<ahref="https://www.acwing.com/activity/content/11/">🔗 Link</a></p><h2 id="算法知识点讲解">算法知识点讲解</h2><ul><li><ahref="https://s1mplebug.github.io/2023/08/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/">二分查找模板</a></li></ul><h2 id="题目">题目</h2><h3 id="第二讲-数据结构">第二讲 数据结构</h3><ul><li><ahref="https://s1mplebug.github.io/2023/08/06/826-%E5%8D%95%E9%93%BE%E8%A1%A8/">单链表</a></li></ul><h3 id="第四讲-数学知识">第四讲 数学知识</h3><ul><li><ahref="https://s1mplebug.github.io/2023/08/06/866-%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0/">826.试除法判定质数</a></li><li><ahref="https://s1mplebug.github.io/2023/08/06/867-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/">867.分解质因数</a></li><li><ahref="https://s1mplebug.github.io/2023/08/06/868-%E8%B4%A8%E6%95%B0%E7%AD%9B/">868.质数筛</a></li></ul><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>无标签</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode题解目录</title>
    <link href="/2023/08/06/Leetcode%E9%A2%98%E8%A7%A3%E7%9B%AE%E5%BD%95/"/>
    <url>/2023/08/06/Leetcode%E9%A2%98%E8%A7%A3%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>还没有开始捏，虚晃一枪，嘻嘻</p></blockquote><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4R6NZH87R3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'G-4R6NZH87R3');</script>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
